{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar JsSIP = require(\"jssip\");\n\nvar PropTypes = require(\"prop-types\");\n\nvar React = require(\"react\");\n\nvar dummyLogger_1 = require(\"../../lib/dummyLogger\");\n\nvar enums_1 = require(\"../../lib/enums\");\n\nvar types_1 = require(\"../../lib/types\");\n\nvar SipProvider = function (_super) {\n  __extends(SipProvider, _super);\n\n  function SipProvider(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.registerSip = function () {\n      if (_this.props.autoRegister) {\n        throw new Error(\"Calling registerSip is not allowed when autoRegister === true\");\n      }\n\n      if (_this.state.sipStatus !== enums_1.SIP_STATUS_CONNECTED) {\n        throw new Error(\"Calling registerSip is not allowed when sip status is \" + _this.state.sipStatus + \" (expected \" + enums_1.SIP_STATUS_CONNECTED + \")\");\n      }\n\n      return _this.ua.register();\n    };\n\n    _this.unregisterSip = function () {\n      if (_this.props.autoRegister) {\n        throw new Error(\"Calling registerSip is not allowed when autoRegister === true\");\n      }\n\n      if (_this.state.sipStatus !== enums_1.SIP_STATUS_REGISTERED) {\n        throw new Error(\"Calling unregisterSip is not allowed when sip status is \" + _this.state.sipStatus + \" (expected \" + enums_1.SIP_STATUS_CONNECTED + \")\");\n      }\n\n      return _this.ua.unregister();\n    };\n\n    _this.answerCall = function () {\n      if (_this.state.callStatus !== enums_1.CALL_STATUS_STARTING || _this.state.callDirection !== enums_1.CALL_DIRECTION_INCOMING) {\n        throw new Error(\"Calling answerCall() is not allowed when call status is \" + _this.state.callStatus + \" and call direction is \" + _this.state.callDirection + \"  (expected \" + enums_1.CALL_STATUS_STARTING + \" and \" + enums_1.CALL_DIRECTION_INCOMING + \")\");\n      }\n\n      _this.state.rtcSession.answer({\n        mediaConstraints: {\n          audio: true,\n          video: false\n        },\n        pcConfig: {\n          iceServers: _this.props.iceServers\n        }\n      });\n    };\n\n    _this.startCall = function (destination) {\n      if (!destination) {\n        throw new Error(\"Destination must be defined (\" + destination + \" given)\");\n      }\n\n      if (_this.state.sipStatus !== enums_1.SIP_STATUS_CONNECTED && _this.state.sipStatus !== enums_1.SIP_STATUS_REGISTERED) {\n        throw new Error(\"Calling startCall() is not allowed when sip status is \" + _this.state.sipStatus + \" (expected \" + enums_1.SIP_STATUS_CONNECTED + \" or \" + enums_1.SIP_STATUS_REGISTERED + \")\");\n      }\n\n      if (_this.state.callStatus !== enums_1.CALL_STATUS_IDLE) {\n        throw new Error(\"Calling startCall() is not allowed when call status is \" + _this.state.callStatus + \" (expected \" + enums_1.CALL_STATUS_IDLE + \")\");\n      }\n\n      var _a = _this.props,\n          iceServers = _a.iceServers,\n          sessionTimersExpires = _a.sessionTimersExpires;\n      var extraHeaders = _this.props.extraHeaders.invite;\n      var options = {\n        extraHeaders: extraHeaders,\n        mediaConstraints: {\n          audio: true,\n          video: false\n        },\n        rtcOfferConstraints: {\n          iceRestart: _this.props.iceRestart\n        },\n        pcConfig: {\n          iceServers: iceServers\n        },\n        sessionTimersExpires: sessionTimersExpires\n      };\n\n      _this.ua.call(destination, options);\n\n      _this.setState({\n        callStatus: enums_1.CALL_STATUS_STARTING\n      });\n    };\n\n    _this.stopCall = function () {\n      _this.setState({\n        callStatus: enums_1.CALL_STATUS_STOPPING\n      });\n\n      _this.ua.terminateSessions();\n    };\n\n    _this.state = {\n      sipStatus: enums_1.SIP_STATUS_DISCONNECTED,\n      sipErrorType: null,\n      sipErrorMessage: null,\n      rtcSession: null,\n      callStatus: enums_1.CALL_STATUS_IDLE,\n      callDirection: null,\n      callCounterpart: null\n    };\n    _this.ua = null;\n    return _this;\n  }\n\n  SipProvider.prototype.getChildContext = function () {\n    return {\n      sip: __assign({}, this.props, {\n        status: this.state.sipStatus,\n        errorType: this.state.sipErrorType,\n        errorMessage: this.state.sipErrorMessage\n      }),\n      call: {\n        id: \"??\",\n        status: this.state.callStatus,\n        direction: this.state.callDirection,\n        counterpart: this.state.callCounterpart\n      },\n      registerSip: this.registerSip,\n      unregisterSip: this.unregisterSip,\n      answerCall: this.answerCall,\n      startCall: this.startCall,\n      stopCall: this.stopCall\n    };\n  };\n\n  SipProvider.prototype.componentDidMount = function () {\n    if (window.document.getElementById(\"sip-provider-audio\")) {\n      throw new Error(\"Creating two SipProviders in one application is forbidden. If that's not the case \" + \"then check if you're using \\\"sip-provider-audio\\\" as id attribute for any existing \" + \"element\");\n    }\n\n    this.remoteAudio = window.document.createElement(\"audio\");\n    this.remoteAudio.id = \"sip-provider-audio\";\n    window.document.body.appendChild(this.remoteAudio);\n    this.reconfigureDebug();\n    this.reinitializeJsSIP();\n  };\n\n  SipProvider.prototype.componentDidUpdate = function (prevProps) {\n    if (this.props.debug !== prevProps.debug) {\n      this.reconfigureDebug();\n    }\n\n    if (this.props.host !== prevProps.host || this.props.port !== prevProps.port || this.props.pathname !== prevProps.pathname || this.props.user !== prevProps.user || this.props.password !== prevProps.password || this.props.autoRegister !== prevProps.autoRegister) {\n      this.reinitializeJsSIP();\n    }\n  };\n\n  SipProvider.prototype.componentWillUnmount = function () {\n    this.remoteAudio.parentNode.removeChild(this.remoteAudio);\n    delete this.remoteAudio;\n\n    if (this.ua) {\n      this.ua.stop();\n      this.ua = null;\n    }\n  };\n\n  SipProvider.prototype.reconfigureDebug = function () {\n    var debug = this.props.debug;\n\n    if (debug) {\n      JsSIP.debug.enable(\"JsSIP:*\");\n      this.logger = console;\n    } else {\n      JsSIP.debug.disable(\"JsSIP:*\");\n      this.logger = dummyLogger_1.default;\n    }\n  };\n\n  SipProvider.prototype.reinitializeJsSIP = function () {\n    var _this = this;\n\n    if (this.ua) {\n      this.ua.stop();\n      this.ua = null;\n    }\n\n    var _a = this.props,\n        host = _a.host,\n        port = _a.port,\n        pathname = _a.pathname,\n        user = _a.user,\n        password = _a.password,\n        autoRegister = _a.autoRegister;\n\n    if (!host || !port || !user) {\n      this.setState({\n        sipStatus: enums_1.SIP_STATUS_DISCONNECTED,\n        sipErrorType: null,\n        sipErrorMessage: null\n      });\n      return;\n    }\n\n    try {\n      var socket = new JsSIP.WebSocketInterface(\"wss://\" + host + \":\" + port + pathname);\n      this.ua = new JsSIP.UA({\n        uri: \"sip:\" + user + \"@\" + host,\n        password: password,\n        sockets: [socket],\n        register: autoRegister\n      });\n    } catch (error) {\n      this.logger.debug(\"Error\", error.message, error);\n      this.setState({\n        sipStatus: enums_1.SIP_STATUS_ERROR,\n        sipErrorType: enums_1.SIP_ERROR_TYPE_CONFIGURATION,\n        sipErrorMessage: error.message\n      });\n      return;\n    }\n\n    var ua = this.ua;\n    ua.on(\"connecting\", function () {\n      _this.logger.debug('UA \"connecting\" event');\n\n      if (_this.ua !== ua) {\n        return;\n      }\n\n      _this.setState({\n        sipStatus: enums_1.SIP_STATUS_CONNECTING,\n        sipErrorType: null,\n        sipErrorMessage: null\n      });\n    });\n    ua.on(\"connected\", function () {\n      _this.logger.debug('UA \"connected\" event');\n\n      if (_this.ua !== ua) {\n        return;\n      }\n\n      _this.setState({\n        sipStatus: enums_1.SIP_STATUS_CONNECTED,\n        sipErrorType: null,\n        sipErrorMessage: null\n      });\n    });\n    ua.on(\"disconnected\", function () {\n      _this.logger.debug('UA \"disconnected\" event');\n\n      if (_this.ua !== ua) {\n        return;\n      }\n\n      _this.setState({\n        sipStatus: enums_1.SIP_STATUS_ERROR,\n        sipErrorType: enums_1.SIP_ERROR_TYPE_CONNECTION,\n        sipErrorMessage: \"disconnected\"\n      });\n    });\n    ua.on(\"registered\", function (data) {\n      _this.logger.debug('UA \"registered\" event', data);\n\n      if (_this.ua !== ua) {\n        return;\n      }\n\n      _this.setState({\n        sipStatus: enums_1.SIP_STATUS_REGISTERED,\n        callStatus: enums_1.CALL_STATUS_IDLE\n      });\n    });\n    ua.on(\"unregistered\", function () {\n      _this.logger.debug('UA \"unregistered\" event');\n\n      if (_this.ua !== ua) {\n        return;\n      }\n\n      if (ua.isConnected()) {\n        _this.setState({\n          sipStatus: enums_1.SIP_STATUS_CONNECTED,\n          callStatus: enums_1.CALL_STATUS_IDLE,\n          callDirection: null\n        });\n      } else {\n        _this.setState({\n          sipStatus: enums_1.SIP_STATUS_DISCONNECTED,\n          callStatus: enums_1.CALL_STATUS_IDLE,\n          callDirection: null\n        });\n      }\n    });\n    ua.on(\"registrationFailed\", function (data) {\n      _this.logger.debug('UA \"registrationFailed\" event');\n\n      if (_this.ua !== ua) {\n        return;\n      }\n\n      _this.setState({\n        sipStatus: enums_1.SIP_STATUS_ERROR,\n        sipErrorType: enums_1.SIP_ERROR_TYPE_REGISTRATION,\n        sipErrorMessage: data\n      });\n    });\n    ua.on(\"newRTCSession\", function (_a) {\n      var originator = _a.originator,\n          rtcSession = _a.session,\n          rtcRequest = _a.request;\n\n      if (!_this || _this.ua !== ua) {\n        return;\n      }\n\n      if (originator === \"local\") {\n        var foundUri = rtcRequest.to.toString();\n        var delimiterPosition = foundUri.indexOf(\";\") || null;\n\n        _this.setState({\n          callDirection: enums_1.CALL_DIRECTION_OUTGOING,\n          callStatus: enums_1.CALL_STATUS_STARTING,\n          callCounterpart: foundUri.substring(0, delimiterPosition) || foundUri\n        });\n      } else if (originator === \"remote\") {\n        var foundUri = rtcRequest.from.toString();\n        var delimiterPosition = foundUri.indexOf(\";\") || null;\n\n        _this.setState({\n          callDirection: enums_1.CALL_DIRECTION_INCOMING,\n          callStatus: enums_1.CALL_STATUS_STARTING,\n          callCounterpart: foundUri.substring(0, delimiterPosition) || foundUri\n        });\n      }\n\n      var rtcSessionInState = _this.state.rtcSession;\n\n      if (rtcSessionInState) {\n        _this.logger.debug('incoming call replied with 486 \"Busy Here\"');\n\n        rtcSession.terminate({\n          status_code: 486,\n          reason_phrase: \"Busy Here\"\n        });\n        return;\n      }\n\n      _this.setState({\n        rtcSession: rtcSession\n      });\n\n      rtcSession.on(\"failed\", function () {\n        if (_this.ua !== ua) {\n          return;\n        }\n\n        _this.setState({\n          rtcSession: null,\n          callStatus: enums_1.CALL_STATUS_IDLE,\n          callDirection: null,\n          callCounterpart: null\n        });\n      });\n      rtcSession.on(\"ended\", function () {\n        if (_this.ua !== ua) {\n          return;\n        }\n\n        _this.setState({\n          rtcSession: null,\n          callStatus: enums_1.CALL_STATUS_IDLE,\n          callDirection: null,\n          callCounterpart: null\n        });\n      });\n      rtcSession.on(\"accepted\", function () {\n        if (_this.ua !== ua) {\n          return;\n        }\n\n        _this.remoteAudio.srcObject = rtcSession.connection.getRemoteStreams()[0];\n\n        var played = _this.remoteAudio.play();\n\n        if (typeof played !== \"undefined\") {\n          played.catch(function () {}).then(function () {\n            setTimeout(function () {\n              _this.remoteAudio.play();\n            }, 2000);\n          });\n\n          _this.setState({\n            callStatus: enums_1.CALL_STATUS_ACTIVE\n          });\n\n          return;\n        }\n\n        setTimeout(function () {\n          _this.remoteAudio.play();\n        }, 2000);\n\n        _this.setState({\n          callStatus: enums_1.CALL_STATUS_ACTIVE\n        });\n      });\n\n      if (_this.state.callDirection === enums_1.CALL_DIRECTION_INCOMING && _this.props.autoAnswer) {\n        _this.logger.log(\"Answer auto ON\");\n\n        _this.answerCall();\n      } else if (_this.state.callDirection === enums_1.CALL_DIRECTION_INCOMING && !_this.props.autoAnswer) {\n        _this.logger.log(\"Answer auto OFF\");\n      } else if (_this.state.callDirection === enums_1.CALL_DIRECTION_OUTGOING) {\n        _this.logger.log(\"OUTGOING call\");\n      }\n    });\n    var extraHeadersRegister = this.props.extraHeaders.register || [];\n\n    if (extraHeadersRegister.length) {\n      ua.registrator().setExtraHeaders(extraHeadersRegister);\n    }\n\n    ua.start();\n  };\n\n  SipProvider.prototype.render = function () {\n    return this.props.children;\n  };\n\n  SipProvider.childContextTypes = {\n    sip: types_1.sipPropType,\n    call: types_1.callPropType,\n    registerSip: PropTypes.func,\n    unregisterSip: PropTypes.func,\n    answerCall: PropTypes.func,\n    startCall: PropTypes.func,\n    stopCall: PropTypes.func\n  };\n  SipProvider.propTypes = {\n    host: PropTypes.string,\n    port: PropTypes.number,\n    pathname: PropTypes.string,\n    user: PropTypes.string,\n    password: PropTypes.string,\n    autoRegister: PropTypes.bool,\n    autoAnswer: PropTypes.bool,\n    iceRestart: PropTypes.bool,\n    sessionTimersExpires: PropTypes.number,\n    extraHeaders: types_1.extraHeadersPropType,\n    iceServers: types_1.iceServersPropType,\n    debug: PropTypes.bool,\n    children: PropTypes.node\n  };\n  SipProvider.defaultProps = {\n    host: null,\n    port: null,\n    pathname: \"\",\n    user: null,\n    password: null,\n    autoRegister: true,\n    autoAnswer: false,\n    iceRestart: false,\n    sessionTimersExpires: 120,\n    extraHeaders: {\n      register: [],\n      invite: []\n    },\n    iceServers: [],\n    debug: false,\n    children: null\n  };\n  return SipProvider;\n}(React.Component);\n\nexports.default = SipProvider;","map":null,"metadata":{},"sourceType":"script"}