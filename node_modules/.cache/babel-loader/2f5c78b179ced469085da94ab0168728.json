{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar sdp_transform = require('sdp-transform');\n\nvar JsSIP_C = require('./Constants');\n\nvar Utils = require('./Utils');\n\nvar NameAddrHeader = require('./NameAddrHeader');\n\nvar Grammar = require('./Grammar');\n\nvar debug = require('debug')('JsSIP:SIPMessage');\n/**\n * -param {String} method request method\n * -param {String} ruri request uri\n * -param {UA} ua\n * -param {Object} params parameters that will have priority over ua.configuration parameters:\n * <br>\n *  - cseq, call_id, from_tag, from_uri, from_display_name, to_uri, to_tag, route_set\n * -param {Object} [headers] extra headers\n * -param {String} [body]\n */\n\n\nvar OutgoingRequest =\n/*#__PURE__*/\nfunction () {\n  function OutgoingRequest(method, ruri, ua, params, extraHeaders, body) {\n    _classCallCheck(this, OutgoingRequest); // Mandatory parameters check.\n\n\n    if (!method || !ruri || !ua) {\n      return null;\n    }\n\n    params = params || {};\n    this.ua = ua;\n    this.headers = {};\n    this.method = method;\n    this.ruri = ruri;\n    this.body = body;\n    this.extraHeaders = Utils.cloneArray(extraHeaders); // Fill the Common SIP Request Headers.\n    // Route.\n\n    if (params.route_set) {\n      this.setHeader('route', params.route_set);\n    } else if (ua.configuration.use_preloaded_route) {\n      this.setHeader('route', \"<\".concat(ua.transport.sip_uri, \";lr>\"));\n    } // Via.\n    // Empty Via header. Will be filled by the client transaction.\n\n\n    this.setHeader('via', ''); // Max-Forwards.\n\n    this.setHeader('max-forwards', JsSIP_C.MAX_FORWARDS); // To\n\n    var to_uri = params.to_uri || ruri;\n    var to_params = params.to_tag ? {\n      tag: params.to_tag\n    } : null;\n    var to_display_name = typeof params.to_display_name !== 'undefined' ? params.to_display_name : null;\n    this.to = new NameAddrHeader(to_uri, to_display_name, to_params);\n    this.setHeader('to', this.to.toString()); // From.\n\n    var from_uri = params.from_uri || ua.configuration.uri;\n    var from_params = {\n      tag: params.from_tag || Utils.newTag()\n    };\n    var display_name;\n\n    if (typeof params.from_display_name !== 'undefined') {\n      display_name = params.from_display_name;\n    } else if (ua.configuration.display_name) {\n      display_name = ua.configuration.display_name;\n    } else {\n      display_name = null;\n    }\n\n    this.from = new NameAddrHeader(from_uri, display_name, from_params);\n    this.setHeader('from', this.from.toString()); // Call-ID.\n\n    var call_id = params.call_id || ua.configuration.jssip_id + Utils.createRandomToken(15);\n    this.call_id = call_id;\n    this.setHeader('call-id', call_id); // CSeq.\n\n    var cseq = params.cseq || Math.floor(Math.random() * 10000);\n    this.cseq = cseq;\n    this.setHeader('cseq', \"\".concat(cseq, \" \").concat(method));\n  }\n  /**\n   * Replace the the given header by the given value.\n   * -param {String} name header name\n   * -param {String | Array} value header value\n   */\n\n\n  _createClass(OutgoingRequest, [{\n    key: \"setHeader\",\n    value: function setHeader(name, value) {\n      // Remove the header from extraHeaders if present.\n      var regexp = new RegExp(\"^\\\\s*\".concat(name, \"\\\\s*:\"), 'i');\n\n      for (var idx = 0; idx < this.extraHeaders.length; idx++) {\n        if (regexp.test(this.extraHeaders[idx])) {\n          this.extraHeaders.splice(idx, 1);\n        }\n      }\n\n      this.headers[Utils.headerize(name)] = Array.isArray(value) ? value : [value];\n    }\n    /**\n     * Get the value of the given header name at the given position.\n     * -param {String} name header name\n     * -returns {String|undefined} Returns the specified header, null if header doesn't exist.\n     */\n\n  }, {\n    key: \"getHeader\",\n    value: function getHeader(name) {\n      var headers = this.headers[Utils.headerize(name)];\n\n      if (headers) {\n        if (headers[0]) {\n          return headers[0];\n        }\n      } else {\n        var regexp = new RegExp(\"^\\\\s*\".concat(name, \"\\\\s*:\"), 'i');\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.extraHeaders[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var header = _step.value;\n\n            if (regexp.test(header)) {\n              return header.substring(header.indexOf(':') + 1).trim();\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      return;\n    }\n    /**\n     * Get the header/s of the given name.\n     * -param {String} name header name\n     * -returns {Array} Array with all the headers of the specified name.\n     */\n\n  }, {\n    key: \"getHeaders\",\n    value: function getHeaders(name) {\n      var headers = this.headers[Utils.headerize(name)];\n      var result = [];\n\n      if (headers) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = headers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var header = _step2.value;\n            result.push(header);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        return result;\n      } else {\n        var regexp = new RegExp(\"^\\\\s*\".concat(name, \"\\\\s*:\"), 'i');\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = this.extraHeaders[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var _header = _step3.value;\n\n            if (regexp.test(_header)) {\n              result.push(_header.substring(_header.indexOf(':') + 1).trim());\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        return result;\n      }\n    }\n    /**\n     * Verify the existence of the given header.\n     * -param {String} name header name\n     * -returns {boolean} true if header with given name exists, false otherwise\n     */\n\n  }, {\n    key: \"hasHeader\",\n    value: function hasHeader(name) {\n      if (this.headers[Utils.headerize(name)]) {\n        return true;\n      } else {\n        var regexp = new RegExp(\"^\\\\s*\".concat(name, \"\\\\s*:\"), 'i');\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = this.extraHeaders[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var header = _step4.value;\n\n            if (regexp.test(header)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Parse the current body as a SDP and store the resulting object\n     * into this.sdp.\n     * -param {Boolean} force: Parse even if this.sdp already exists.\n     *\n     * Returns this.sdp.\n     */\n\n  }, {\n    key: \"parseSDP\",\n    value: function parseSDP(force) {\n      if (!force && this.sdp) {\n        return this.sdp;\n      } else {\n        this.sdp = sdp_transform.parse(this.body || '');\n        return this.sdp;\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var msg = \"\".concat(this.method, \" \").concat(this.ruri, \" SIP/2.0\\r\\n\");\n\n      for (var headerName in this.headers) {\n        if (Object.prototype.hasOwnProperty.call(this.headers, headerName)) {\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = this.headers[headerName][Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var headerValue = _step5.value;\n              msg += \"\".concat(headerName, \": \").concat(headerValue, \"\\r\\n\");\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this.extraHeaders[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var header = _step6.value;\n          msg += \"\".concat(header.trim(), \"\\r\\n\");\n        } // Supported.\n\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      var supported = [];\n\n      switch (this.method) {\n        case JsSIP_C.REGISTER:\n          supported.push('path', 'gruu');\n          break;\n\n        case JsSIP_C.INVITE:\n          if (this.ua.configuration.session_timers) {\n            supported.push('timer');\n          }\n\n          if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu) {\n            supported.push('gruu');\n          }\n\n          supported.push('ice', 'replaces');\n          break;\n\n        case JsSIP_C.UPDATE:\n          if (this.ua.configuration.session_timers) {\n            supported.push('timer');\n          }\n\n          supported.push('ice');\n          break;\n      }\n\n      supported.push('outbound');\n      var userAgent = this.ua.configuration.user_agent || JsSIP_C.USER_AGENT; // Allow.\n\n      msg += \"Allow: \".concat(JsSIP_C.ALLOWED_METHODS, \"\\r\\n\");\n      msg += \"Supported: \".concat(supported, \"\\r\\n\");\n      msg += \"User-Agent: \".concat(userAgent, \"\\r\\n\");\n\n      if (this.body) {\n        var length = Utils.str_utf8_length(this.body);\n        msg += \"Content-Length: \".concat(length, \"\\r\\n\\r\\n\");\n        msg += this.body;\n      } else {\n        msg += 'Content-Length: 0\\r\\n\\r\\n';\n      }\n\n      return msg;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var request = new OutgoingRequest(this.method, this.ruri, this.ua);\n      Object.keys(this.headers).forEach(function (name) {\n        request.headers[name] = this.headers[name].slice();\n      }, this);\n      request.body = this.body;\n      request.extraHeaders = Utils.cloneArray(this.extraHeaders);\n      request.to = this.to;\n      request.from = this.from;\n      request.call_id = this.call_id;\n      request.cseq = this.cseq;\n      return request;\n    }\n  }]);\n\n  return OutgoingRequest;\n}();\n\nvar InitialOutgoingInviteRequest =\n/*#__PURE__*/\nfunction (_OutgoingRequest) {\n  _inherits(InitialOutgoingInviteRequest, _OutgoingRequest);\n\n  function InitialOutgoingInviteRequest(ruri, ua, params, extraHeaders, body) {\n    var _this;\n\n    _classCallCheck(this, InitialOutgoingInviteRequest);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(InitialOutgoingInviteRequest).call(this, JsSIP_C.INVITE, ruri, ua, params, extraHeaders, body));\n    _this.transaction = null;\n    return _this;\n  }\n\n  _createClass(InitialOutgoingInviteRequest, [{\n    key: \"cancel\",\n    value: function cancel(reason) {\n      this.transaction.cancel(reason);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var request = new InitialOutgoingInviteRequest(this.ruri, this.ua);\n      Object.keys(this.headers).forEach(function (name) {\n        request.headers[name] = this.headers[name].slice();\n      }, this);\n      request.body = this.body;\n      request.extraHeaders = Utils.cloneArray(this.extraHeaders);\n      request.to = this.to;\n      request.from = this.from;\n      request.call_id = this.call_id;\n      request.cseq = this.cseq;\n      request.transaction = this.transaction;\n      return request;\n    }\n  }]);\n\n  return InitialOutgoingInviteRequest;\n}(OutgoingRequest);\n\nvar IncomingMessage =\n/*#__PURE__*/\nfunction () {\n  function IncomingMessage() {\n    _classCallCheck(this, IncomingMessage);\n\n    this.data = null;\n    this.headers = null;\n    this.method = null;\n    this.via = null;\n    this.via_branch = null;\n    this.call_id = null;\n    this.cseq = null;\n    this.from = null;\n    this.from_tag = null;\n    this.to = null;\n    this.to_tag = null;\n    this.body = null;\n    this.sdp = null;\n  }\n  /**\n  * Insert a header of the given name and value into the last position of the\n  * header array.\n  */\n\n\n  _createClass(IncomingMessage, [{\n    key: \"addHeader\",\n    value: function addHeader(name, value) {\n      var header = {\n        raw: value\n      };\n      name = Utils.headerize(name);\n\n      if (this.headers[name]) {\n        this.headers[name].push(header);\n      } else {\n        this.headers[name] = [header];\n      }\n    }\n    /**\n     * Get the value of the given header name at the given position.\n     */\n\n  }, {\n    key: \"getHeader\",\n    value: function getHeader(name) {\n      var header = this.headers[Utils.headerize(name)];\n\n      if (header) {\n        if (header[0]) {\n          return header[0].raw;\n        }\n      } else {\n        return;\n      }\n    }\n    /**\n     * Get the header/s of the given name.\n     */\n\n  }, {\n    key: \"getHeaders\",\n    value: function getHeaders(name) {\n      var headers = this.headers[Utils.headerize(name)];\n      var result = [];\n\n      if (!headers) {\n        return [];\n      }\n\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = headers[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var header = _step7.value;\n          result.push(header.raw);\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Verify the existence of the given header.\n     */\n\n  }, {\n    key: \"hasHeader\",\n    value: function hasHeader(name) {\n      return this.headers[Utils.headerize(name)] ? true : false;\n    }\n    /**\n    * Parse the given header on the given index.\n    * -param {String} name header name\n    * -param {Number} [idx=0] header index\n    * -returns {Object|undefined} Parsed header object, undefined if the header\n    *  is not present or in case of a parsing error.\n    */\n\n  }, {\n    key: \"parseHeader\",\n    value: function parseHeader(name) {\n      var idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      name = Utils.headerize(name);\n\n      if (!this.headers[name]) {\n        debug(\"header \\\"\".concat(name, \"\\\" not present\"));\n        return;\n      } else if (idx >= this.headers[name].length) {\n        debug(\"not so many \\\"\".concat(name, \"\\\" headers present\"));\n        return;\n      }\n\n      var header = this.headers[name][idx];\n      var value = header.raw;\n\n      if (header.parsed) {\n        return header.parsed;\n      } // Substitute '-' by '_' for grammar rule matching.\n\n\n      var parsed = Grammar.parse(value, name.replace(/-/g, '_'));\n\n      if (parsed === -1) {\n        this.headers[name].splice(idx, 1); // delete from headers\n\n        debug(\"error parsing \\\"\".concat(name, \"\\\" header field with value \\\"\").concat(value, \"\\\"\"));\n        return;\n      } else {\n        header.parsed = parsed;\n        return parsed;\n      }\n    }\n    /**\n     * Message Header attribute selector. Alias of parseHeader.\n     * -param {String} name header name\n     * -param {Number} [idx=0] header index\n     * -returns {Object|undefined} Parsed header object, undefined if the header\n     *  is not present or in case of a parsing error.\n     *\n     * -example\n     * message.s('via',3).port\n     */\n\n  }, {\n    key: \"s\",\n    value: function s(name, idx) {\n      return this.parseHeader(name, idx);\n    }\n    /**\n    * Replace the value of the given header by the value.\n    * -param {String} name header name\n    * -param {String} value header value\n    */\n\n  }, {\n    key: \"setHeader\",\n    value: function setHeader(name, value) {\n      var header = {\n        raw: value\n      };\n      this.headers[Utils.headerize(name)] = [header];\n    }\n    /**\n     * Parse the current body as a SDP and store the resulting object\n     * into this.sdp.\n     * -param {Boolean} force: Parse even if this.sdp already exists.\n     *\n     * Returns this.sdp.\n     */\n\n  }, {\n    key: \"parseSDP\",\n    value: function parseSDP(force) {\n      if (!force && this.sdp) {\n        return this.sdp;\n      } else {\n        this.sdp = sdp_transform.parse(this.body || '');\n        return this.sdp;\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data;\n    }\n  }]);\n\n  return IncomingMessage;\n}();\n\nvar IncomingRequest =\n/*#__PURE__*/\nfunction (_IncomingMessage) {\n  _inherits(IncomingRequest, _IncomingMessage);\n\n  function IncomingRequest(ua) {\n    var _this2;\n\n    _classCallCheck(this, IncomingRequest);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(IncomingRequest).call(this));\n    _this2.ua = ua;\n    _this2.headers = {};\n    _this2.ruri = null;\n    _this2.transport = null;\n    _this2.server_transaction = null;\n    return _this2;\n  }\n  /**\n  * Stateful reply.\n  * -param {Number} code status code\n  * -param {String} reason reason phrase\n  * -param {Object} headers extra headers\n  * -param {String} body body\n  * -param {Function} [onSuccess] onSuccess callback\n  * -param {Function} [onFailure] onFailure callback\n  */\n\n\n  _createClass(IncomingRequest, [{\n    key: \"reply\",\n    value: function reply(code, reason, extraHeaders, body, onSuccess, onFailure) {\n      var supported = [];\n      var to = this.getHeader('To');\n      code = code || null;\n      reason = reason || null; // Validate code and reason values.\n\n      if (!code || code < 100 || code > 699) {\n        throw new TypeError(\"Invalid status_code: \".concat(code));\n      } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n        throw new TypeError(\"Invalid reason_phrase: \".concat(reason));\n      }\n\n      reason = reason || JsSIP_C.REASON_PHRASE[code] || '';\n      extraHeaders = Utils.cloneArray(extraHeaders);\n      var response = \"SIP/2.0 \".concat(code, \" \").concat(reason, \"\\r\\n\");\n\n      if (this.method === JsSIP_C.INVITE && code > 100 && code <= 200) {\n        var headers = this.getHeaders('record-route');\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n\n        try {\n          for (var _iterator8 = headers[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var header = _step8.value;\n            response += \"Record-Route: \".concat(header, \"\\r\\n\");\n          }\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n              _iterator8.return();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n      }\n\n      var vias = this.getHeaders('via');\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = vias[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var via = _step9.value;\n          response += \"Via: \".concat(via, \"\\r\\n\");\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      if (!this.to_tag && code > 100) {\n        to += \";tag=\".concat(Utils.newTag());\n      } else if (this.to_tag && !this.s('to').hasParam('tag')) {\n        to += \";tag=\".concat(this.to_tag);\n      }\n\n      response += \"To: \".concat(to, \"\\r\\n\");\n      response += \"From: \".concat(this.getHeader('From'), \"\\r\\n\");\n      response += \"Call-ID: \".concat(this.call_id, \"\\r\\n\");\n      response += \"CSeq: \".concat(this.cseq, \" \").concat(this.method, \"\\r\\n\");\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = extraHeaders[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var _header2 = _step10.value;\n          response += \"\".concat(_header2.trim(), \"\\r\\n\");\n        } // Supported.\n\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n\n      switch (this.method) {\n        case JsSIP_C.INVITE:\n          if (this.ua.configuration.session_timers) {\n            supported.push('timer');\n          }\n\n          if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu) {\n            supported.push('gruu');\n          }\n\n          supported.push('ice', 'replaces');\n          break;\n\n        case JsSIP_C.UPDATE:\n          if (this.ua.configuration.session_timers) {\n            supported.push('timer');\n          }\n\n          if (body) {\n            supported.push('ice');\n          }\n\n          supported.push('replaces');\n      }\n\n      supported.push('outbound'); // Allow and Accept.\n\n      if (this.method === JsSIP_C.OPTIONS) {\n        response += \"Allow: \".concat(JsSIP_C.ALLOWED_METHODS, \"\\r\\n\");\n        response += \"Accept: \".concat(JsSIP_C.ACCEPTED_BODY_TYPES, \"\\r\\n\");\n      } else if (code === 405) {\n        response += \"Allow: \".concat(JsSIP_C.ALLOWED_METHODS, \"\\r\\n\");\n      } else if (code === 415) {\n        response += \"Accept: \".concat(JsSIP_C.ACCEPTED_BODY_TYPES, \"\\r\\n\");\n      }\n\n      response += \"Supported: \".concat(supported, \"\\r\\n\");\n\n      if (body) {\n        var length = Utils.str_utf8_length(body);\n        response += 'Content-Type: application/sdp\\r\\n';\n        response += \"Content-Length: \".concat(length, \"\\r\\n\\r\\n\");\n        response += body;\n      } else {\n        response += \"Content-Length: \".concat(0, \"\\r\\n\\r\\n\");\n      }\n\n      this.server_transaction.receiveResponse(code, response, onSuccess, onFailure);\n    }\n    /**\n    * Stateless reply.\n    * -param {Number} code status code\n    * -param {String} reason reason phrase\n    */\n\n  }, {\n    key: \"reply_sl\",\n    value: function reply_sl() {\n      var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var vias = this.getHeaders('via'); // Validate code and reason values.\n\n      if (!code || code < 100 || code > 699) {\n        throw new TypeError(\"Invalid status_code: \".concat(code));\n      } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n        throw new TypeError(\"Invalid reason_phrase: \".concat(reason));\n      }\n\n      reason = reason || JsSIP_C.REASON_PHRASE[code] || '';\n      var response = \"SIP/2.0 \".concat(code, \" \").concat(reason, \"\\r\\n\");\n      var _iteratorNormalCompletion11 = true;\n      var _didIteratorError11 = false;\n      var _iteratorError11 = undefined;\n\n      try {\n        for (var _iterator11 = vias[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n          var via = _step11.value;\n          response += \"Via: \".concat(via, \"\\r\\n\");\n        }\n      } catch (err) {\n        _didIteratorError11 = true;\n        _iteratorError11 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n            _iterator11.return();\n          }\n        } finally {\n          if (_didIteratorError11) {\n            throw _iteratorError11;\n          }\n        }\n      }\n\n      var to = this.getHeader('To');\n\n      if (!this.to_tag && code > 100) {\n        to += \";tag=\".concat(Utils.newTag());\n      } else if (this.to_tag && !this.s('to').hasParam('tag')) {\n        to += \";tag=\".concat(this.to_tag);\n      }\n\n      response += \"To: \".concat(to, \"\\r\\n\");\n      response += \"From: \".concat(this.getHeader('From'), \"\\r\\n\");\n      response += \"Call-ID: \".concat(this.call_id, \"\\r\\n\");\n      response += \"CSeq: \".concat(this.cseq, \" \").concat(this.method, \"\\r\\n\");\n      response += \"Content-Length: \".concat(0, \"\\r\\n\\r\\n\");\n      this.transport.send(response);\n    }\n  }]);\n\n  return IncomingRequest;\n}(IncomingMessage);\n\nvar IncomingResponse =\n/*#__PURE__*/\nfunction (_IncomingMessage2) {\n  _inherits(IncomingResponse, _IncomingMessage2);\n\n  function IncomingResponse() {\n    var _this3;\n\n    _classCallCheck(this, IncomingResponse);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(IncomingResponse).call(this));\n    _this3.headers = {};\n    _this3.status_code = null;\n    _this3.reason_phrase = null;\n    return _this3;\n  }\n\n  return IncomingResponse;\n}(IncomingMessage);\n\nmodule.exports = {\n  OutgoingRequest: OutgoingRequest,\n  InitialOutgoingInviteRequest: InitialOutgoingInviteRequest,\n  IncomingRequest: IncomingRequest,\n  IncomingResponse: IncomingResponse\n};","map":null,"metadata":{},"sourceType":"script"}