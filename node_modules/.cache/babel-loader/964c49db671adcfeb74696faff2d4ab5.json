{"ast":null,"code":"/* globals RTCPeerConnection: false, RTCSessionDescription: false */\nconst EventEmitter = require('events').EventEmitter;\n\nconst sdp_transform = require('sdp-transform');\n\nconst JsSIP_C = require('./Constants');\n\nconst Exceptions = require('./Exceptions');\n\nconst Transactions = require('./Transactions');\n\nconst Utils = require('./Utils');\n\nconst Timers = require('./Timers');\n\nconst SIPMessage = require('./SIPMessage');\n\nconst Dialog = require('./Dialog');\n\nconst RequestSender = require('./RequestSender');\n\nconst RTCSession_DTMF = require('./RTCSession/DTMF');\n\nconst RTCSession_Info = require('./RTCSession/Info');\n\nconst RTCSession_ReferNotifier = require('./RTCSession/ReferNotifier');\n\nconst RTCSession_ReferSubscriber = require('./RTCSession/ReferSubscriber');\n\nconst URI = require('./URI');\n\nconst debug = require('debug')('JsSIP:RTCSession');\n\nconst debugerror = require('debug')('JsSIP:ERROR:RTCSession');\n\ndebugerror.log = console.warn.bind(console);\nconst C = {\n  // RTCSession states.\n  STATUS_NULL: 0,\n  STATUS_INVITE_SENT: 1,\n  STATUS_1XX_RECEIVED: 2,\n  STATUS_INVITE_RECEIVED: 3,\n  STATUS_WAITING_FOR_ANSWER: 4,\n  STATUS_ANSWERED: 5,\n  STATUS_WAITING_FOR_ACK: 6,\n  STATUS_CANCELED: 7,\n  STATUS_TERMINATED: 8,\n  STATUS_CONFIRMED: 9\n};\n/**\n * Local variables.\n */\n\nconst holdMediaTypes = ['audio', 'video'];\nmodule.exports = class RTCSession extends EventEmitter {\n  /**\n   * Expose C object.\n   */\n  static get C() {\n    return C;\n  }\n\n  constructor(ua) {\n    debug('new');\n    super();\n    this._id = null;\n    this._ua = ua;\n    this._status = C.STATUS_NULL;\n    this._dialog = null;\n    this._earlyDialogs = {};\n    this._contact = null;\n    this._from_tag = null;\n    this._to_tag = null; // The RTCPeerConnection instance (public attribute).\n\n    this._connection = null; // Prevent races on serial PeerConnction operations.\n\n    this._connectionPromiseQueue = Promise.resolve(); // Incoming/Outgoing request being currently processed.\n\n    this._request = null; // Cancel state for initial outgoing request.\n\n    this._is_canceled = false;\n    this._cancel_reason = ''; // RTCSession confirmation flag.\n\n    this._is_confirmed = false; // Is late SDP being negotiated.\n\n    this._late_sdp = false; // Default rtcOfferConstraints and rtcAnswerConstrainsts (passed in connect() or answer()).\n\n    this._rtcOfferConstraints = null;\n    this._rtcAnswerConstraints = null; // Local MediaStream.\n\n    this._localMediaStream = null;\n    this._localMediaStreamLocallyGenerated = false; // Flag to indicate PeerConnection ready for new actions.\n\n    this._rtcReady = true; // SIP Timers.\n\n    this._timers = {\n      ackTimer: null,\n      expiresTimer: null,\n      invite2xxTimer: null,\n      userNoAnswerTimer: null\n    }; // Session info.\n\n    this._direction = null;\n    this._local_identity = null;\n    this._remote_identity = null;\n    this._start_time = null;\n    this._end_time = null;\n    this._tones = null; // Mute/Hold state.\n\n    this._audioMuted = false;\n    this._videoMuted = false;\n    this._localHold = false;\n    this._remoteHold = false; // Session Timers (RFC 4028).\n\n    this._sessionTimers = {\n      enabled: this._ua.configuration.session_timers,\n      refreshMethod: this._ua.configuration.session_timers_refresh_method,\n      defaultExpires: JsSIP_C.SESSION_EXPIRES,\n      currentExpires: null,\n      running: false,\n      refresher: false,\n      timer: null // A setTimeout.\n\n    }; // Map of ReferSubscriber instances indexed by the REFER's CSeq number.\n\n    this._referSubscribers = {}; // Custom session empty object for high level use.\n\n    this._data = {};\n  }\n  /**\n   * User API\n   */\n  // Expose RTCSession constants as a property of the RTCSession instance.\n\n\n  get C() {\n    return C;\n  } // Expose session failed/ended causes as a property of the RTCSession instance.\n\n\n  get causes() {\n    return JsSIP_C.causes;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get connection() {\n    return this._connection;\n  }\n\n  get contact() {\n    return this._contact;\n  }\n\n  get direction() {\n    return this._direction;\n  }\n\n  get local_identity() {\n    return this._local_identity;\n  }\n\n  get remote_identity() {\n    return this._remote_identity;\n  }\n\n  get start_time() {\n    return this._start_time;\n  }\n\n  get end_time() {\n    return this._end_time;\n  }\n\n  get data() {\n    return this._data;\n  }\n\n  set data(_data) {\n    this._data = _data;\n  }\n\n  get status() {\n    return this._status;\n  }\n\n  isInProgress() {\n    switch (this._status) {\n      case C.STATUS_NULL:\n      case C.STATUS_INVITE_SENT:\n      case C.STATUS_1XX_RECEIVED:\n      case C.STATUS_INVITE_RECEIVED:\n      case C.STATUS_WAITING_FOR_ANSWER:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  isEstablished() {\n    switch (this._status) {\n      case C.STATUS_ANSWERED:\n      case C.STATUS_WAITING_FOR_ACK:\n      case C.STATUS_CONFIRMED:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  isEnded() {\n    switch (this._status) {\n      case C.STATUS_CANCELED:\n      case C.STATUS_TERMINATED:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  isMuted() {\n    return {\n      audio: this._audioMuted,\n      video: this._videoMuted\n    };\n  }\n\n  isOnHold() {\n    return {\n      local: this._localHold,\n      remote: this._remoteHold\n    };\n  }\n\n  connect(target, options = {}, initCallback) {\n    debug('connect()');\n    const originalTarget = target;\n    const eventHandlers = options.eventHandlers || {};\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const mediaConstraints = options.mediaConstraints || {\n      audio: true,\n      video: true\n    };\n    const mediaStream = options.mediaStream || null;\n    const pcConfig = options.pcConfig || {\n      iceServers: []\n    };\n    const rtcConstraints = options.rtcConstraints || null;\n    const rtcOfferConstraints = options.rtcOfferConstraints || null;\n    this._rtcOfferConstraints = rtcOfferConstraints;\n    this._rtcAnswerConstraints = options.rtcAnswerConstraints || null;\n    this._data = options.data || this._data; // Check target.\n\n    if (target === undefined) {\n      throw new TypeError('Not enough arguments');\n    } // Check Session Status.\n\n\n    if (this._status !== C.STATUS_NULL) {\n      throw new Exceptions.InvalidStateError(this._status);\n    } // Check WebRTC support.\n\n\n    if (!window.RTCPeerConnection) {\n      throw new Exceptions.NotSupportedError('WebRTC not supported');\n    } // Check target validity.\n\n\n    target = this._ua.normalizeTarget(target);\n\n    if (!target) {\n      throw new TypeError(\"Invalid target: \".concat(originalTarget));\n    } // Session Timers.\n\n\n    if (this._sessionTimers.enabled) {\n      if (Utils.isDecimal(options.sessionTimersExpires)) {\n        if (options.sessionTimersExpires >= JsSIP_C.MIN_SESSION_EXPIRES) {\n          this._sessionTimers.defaultExpires = options.sessionTimersExpires;\n        } else {\n          this._sessionTimers.defaultExpires = JsSIP_C.SESSION_EXPIRES;\n        }\n      }\n    } // Set event handlers.\n\n\n    for (const event in eventHandlers) {\n      if (Object.prototype.hasOwnProperty.call(eventHandlers, event)) {\n        this.on(event, eventHandlers[event]);\n      }\n    } // Session parameter initialization.\n\n\n    this._from_tag = Utils.newTag(); // Set anonymous property.\n\n    const anonymous = options.anonymous || false;\n    const requestParams = {\n      from_tag: this._from_tag\n    };\n    this._contact = this._ua.contact.toString({\n      anonymous,\n      outbound: true\n    });\n\n    if (anonymous) {\n      requestParams.from_display_name = 'Anonymous';\n      requestParams.from_uri = new URI('sip', 'anonymous', 'anonymous.invalid');\n      extraHeaders.push(\"P-Preferred-Identity: \".concat(this._ua.configuration.uri.toString()));\n      extraHeaders.push('Privacy: id');\n    }\n\n    extraHeaders.push(\"Contact: \".concat(this._contact));\n    extraHeaders.push('Content-Type: application/sdp');\n\n    if (this._sessionTimers.enabled) {\n      extraHeaders.push(\"Session-Expires: \".concat(this._sessionTimers.defaultExpires));\n    }\n\n    this._request = new SIPMessage.InitialOutgoingInviteRequest(target, this._ua, requestParams, extraHeaders);\n    this._id = this._request.call_id + this._from_tag; // Create a new RTCPeerConnection instance.\n\n    this._createRTCConnection(pcConfig, rtcConstraints); // Set internal properties.\n\n\n    this._direction = 'outgoing';\n    this._local_identity = this._request.from;\n    this._remote_identity = this._request.to; // User explicitly provided a newRTCSession callback for this session.\n\n    if (initCallback) {\n      initCallback(this);\n    }\n\n    this._newRTCSession('local', this._request);\n\n    this._sendInitialRequest(mediaConstraints, rtcOfferConstraints, mediaStream);\n  }\n\n  init_incoming(request, initCallback) {\n    debug('init_incoming()');\n    let expires;\n    const contentType = request.getHeader('Content-Type'); // Check body and content type.\n\n    if (request.body && contentType !== 'application/sdp') {\n      request.reply(415);\n      return;\n    } // Session parameter initialization.\n\n\n    this._status = C.STATUS_INVITE_RECEIVED;\n    this._from_tag = request.from_tag;\n    this._id = request.call_id + this._from_tag;\n    this._request = request;\n    this._contact = this._ua.contact.toString(); // Get the Expires header value if exists.\n\n    if (request.hasHeader('expires')) {\n      expires = request.getHeader('expires') * 1000;\n    }\n    /* Set the to_tag before\n     * replying a response code that will create a dialog.\n     */\n\n\n    request.to_tag = Utils.newTag(); // An error on dialog creation will fire 'failed' event.\n\n    if (!this._createDialog(request, 'UAS', true)) {\n      request.reply(500, 'Missing Contact header field');\n      return;\n    }\n\n    if (request.body) {\n      this._late_sdp = false;\n    } else {\n      this._late_sdp = true;\n    }\n\n    this._status = C.STATUS_WAITING_FOR_ANSWER; // Set userNoAnswerTimer.\n\n    this._timers.userNoAnswerTimer = setTimeout(() => {\n      request.reply(408);\n\n      this._failed('local', null, JsSIP_C.causes.NO_ANSWER);\n    }, this._ua.configuration.no_answer_timeout);\n    /* Set expiresTimer\n     * RFC3261 13.3.1\n     */\n\n    if (expires) {\n      this._timers.expiresTimer = setTimeout(() => {\n        if (this._status === C.STATUS_WAITING_FOR_ANSWER) {\n          request.reply(487);\n\n          this._failed('system', null, JsSIP_C.causes.EXPIRES);\n        }\n      }, expires);\n    } // Set internal properties.\n\n\n    this._direction = 'incoming';\n    this._local_identity = request.to;\n    this._remote_identity = request.from; // A init callback was specifically defined.\n\n    if (initCallback) {\n      initCallback(this);\n    } // Fire 'newRTCSession' event.\n\n\n    this._newRTCSession('remote', request); // The user may have rejected the call in the 'newRTCSession' event.\n\n\n    if (this._status === C.STATUS_TERMINATED) {\n      return;\n    } // Reply 180.\n\n\n    request.reply(180, null, [\"Contact: \".concat(this._contact)]); // Fire 'progress' event.\n    // TODO: Document that 'response' field in 'progress' event is null for incoming calls.\n\n    this._progress('local', null);\n  }\n  /**\n   * Answer the call.\n   */\n\n\n  answer(options = {}) {\n    debug('answer()');\n    const request = this._request;\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const mediaConstraints = options.mediaConstraints || {};\n    const mediaStream = options.mediaStream || null;\n    const pcConfig = options.pcConfig || {\n      iceServers: []\n    };\n    const rtcConstraints = options.rtcConstraints || null;\n    const rtcAnswerConstraints = options.rtcAnswerConstraints || null;\n    let tracks;\n    let peerHasAudioLine = false;\n    let peerHasVideoLine = false;\n    let peerOffersFullAudio = false;\n    let peerOffersFullVideo = false;\n    this._rtcAnswerConstraints = rtcAnswerConstraints;\n    this._rtcOfferConstraints = options.rtcOfferConstraints || null;\n    this._data = options.data || this._data; // Check Session Direction and Status.\n\n    if (this._direction !== 'incoming') {\n      throw new Exceptions.NotSupportedError('\"answer\" not supported for outgoing RTCSession');\n    } // Check Session status.\n\n\n    if (this._status !== C.STATUS_WAITING_FOR_ANSWER) {\n      throw new Exceptions.InvalidStateError(this._status);\n    } // Session Timers.\n\n\n    if (this._sessionTimers.enabled) {\n      if (Utils.isDecimal(options.sessionTimersExpires)) {\n        if (options.sessionTimersExpires >= JsSIP_C.MIN_SESSION_EXPIRES) {\n          this._sessionTimers.defaultExpires = options.sessionTimersExpires;\n        } else {\n          this._sessionTimers.defaultExpires = JsSIP_C.SESSION_EXPIRES;\n        }\n      }\n    }\n\n    this._status = C.STATUS_ANSWERED; // An error on dialog creation will fire 'failed' event.\n\n    if (!this._createDialog(request, 'UAS')) {\n      request.reply(500, 'Error creating dialog');\n      return;\n    }\n\n    clearTimeout(this._timers.userNoAnswerTimer);\n    extraHeaders.unshift(\"Contact: \".concat(this._contact)); // Determine incoming media from incoming SDP offer (if any).\n\n    const sdp = request.parseSDP(); // Make sure sdp.media is an array, not the case if there is only one media.\n\n    if (!Array.isArray(sdp.media)) {\n      sdp.media = [sdp.media];\n    } // Go through all medias in SDP to find offered capabilities to answer with.\n\n\n    for (const m of sdp.media) {\n      if (m.type === 'audio') {\n        peerHasAudioLine = true;\n\n        if (!m.direction || m.direction === 'sendrecv') {\n          peerOffersFullAudio = true;\n        }\n      }\n\n      if (m.type === 'video') {\n        peerHasVideoLine = true;\n\n        if (!m.direction || m.direction === 'sendrecv') {\n          peerOffersFullVideo = true;\n        }\n      }\n    } // Remove audio from mediaStream if suggested by mediaConstraints.\n\n\n    if (mediaStream && mediaConstraints.audio === false) {\n      tracks = mediaStream.getAudioTracks();\n\n      for (const track of tracks) {\n        mediaStream.removeTrack(track);\n      }\n    } // Remove video from mediaStream if suggested by mediaConstraints.\n\n\n    if (mediaStream && mediaConstraints.video === false) {\n      tracks = mediaStream.getVideoTracks();\n\n      for (const track of tracks) {\n        mediaStream.removeTrack(track);\n      }\n    } // Set audio constraints based on incoming stream if not supplied.\n\n\n    if (!mediaStream && mediaConstraints.audio === undefined) {\n      mediaConstraints.audio = peerOffersFullAudio;\n    } // Set video constraints based on incoming stream if not supplied.\n\n\n    if (!mediaStream && mediaConstraints.video === undefined) {\n      mediaConstraints.video = peerOffersFullVideo;\n    } // Don't ask for audio if the incoming offer has no audio section.\n\n\n    if (!mediaStream && !peerHasAudioLine) {\n      mediaConstraints.audio = false;\n    } // Don't ask for video if the incoming offer has no video section.\n\n\n    if (!mediaStream && !peerHasVideoLine) {\n      mediaConstraints.video = false;\n    } // Create a new RTCPeerConnection instance.\n    // TODO: This may throw an error, should react.\n\n\n    this._createRTCConnection(pcConfig, rtcConstraints);\n\n    Promise.resolve() // Handle local MediaStream.\n    .then(() => {\n      // A local MediaStream is given, use it.\n      if (mediaStream) {\n        return mediaStream;\n      } // Audio and/or video requested, prompt getUserMedia.\n      else if (mediaConstraints.audio || mediaConstraints.video) {\n          this._localMediaStreamLocallyGenerated = true;\n          return navigator.mediaDevices.getUserMedia(mediaConstraints).catch(error => {\n            if (this._status === C.STATUS_TERMINATED) {\n              throw new Error('terminated');\n            }\n\n            request.reply(480);\n\n            this._failed('local', null, JsSIP_C.causes.USER_DENIED_MEDIA_ACCESS);\n\n            debugerror('emit \"getusermediafailed\" [error:%o]', error);\n            this.emit('getusermediafailed', error);\n            throw new Error('getUserMedia() failed');\n          });\n        }\n    }) // Attach MediaStream to RTCPeerconnection.\n    .then(stream => {\n      if (this._status === C.STATUS_TERMINATED) {\n        throw new Error('terminated');\n      }\n\n      this._localMediaStream = stream;\n\n      if (stream) {\n        stream.getTracks().forEach(track => {\n          this._connection.addTrack(track, stream);\n        });\n      }\n    }) // Set remote description.\n    .then(() => {\n      if (this._late_sdp) {\n        return;\n      }\n\n      const e = {\n        originator: 'remote',\n        type: 'offer',\n        sdp: request.body\n      };\n      debug('emit \"sdp\"');\n      this.emit('sdp', e);\n      const offer = new RTCSessionDescription({\n        type: 'offer',\n        sdp: e.sdp\n      });\n      this._connectionPromiseQueue = this._connectionPromiseQueue.then(() => this._connection.setRemoteDescription(offer)).catch(error => {\n        request.reply(488);\n\n        this._failed('system', null, JsSIP_C.causes.WEBRTC_ERROR);\n\n        debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n        this.emit('peerconnection:setremotedescriptionfailed', error);\n        throw new Error('peerconnection.setRemoteDescription() failed');\n      });\n      return this._connectionPromiseQueue;\n    }) // Create local description.\n    .then(() => {\n      if (this._status === C.STATUS_TERMINATED) {\n        throw new Error('terminated');\n      } // TODO: Is this event already useful?\n\n\n      this._connecting(request);\n\n      if (!this._late_sdp) {\n        return this._createLocalDescription('answer', rtcAnswerConstraints).catch(() => {\n          request.reply(500);\n          throw new Error('_createLocalDescription() failed');\n        });\n      } else {\n        return this._createLocalDescription('offer', this._rtcOfferConstraints).catch(() => {\n          request.reply(500);\n          throw new Error('_createLocalDescription() failed');\n        });\n      }\n    }) // Send reply.\n    .then(desc => {\n      if (this._status === C.STATUS_TERMINATED) {\n        throw new Error('terminated');\n      }\n\n      this._handleSessionTimersInIncomingRequest(request, extraHeaders);\n\n      request.reply(200, null, extraHeaders, desc, () => {\n        this._status = C.STATUS_WAITING_FOR_ACK;\n\n        this._setInvite2xxTimer(request, desc);\n\n        this._setACKTimer();\n\n        this._accepted('local');\n      }, () => {\n        this._failed('system', null, JsSIP_C.causes.CONNECTION_ERROR);\n      });\n    }).catch(error => {\n      if (this._status === C.STATUS_TERMINATED) {\n        return;\n      }\n\n      debugerror(error);\n    });\n  }\n  /**\n   * Terminate the call.\n   */\n\n\n  terminate(options = {}) {\n    debug('terminate()');\n    const cause = options.cause || JsSIP_C.causes.BYE;\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const body = options.body;\n    let cancel_reason;\n    let status_code = options.status_code;\n    let reason_phrase = options.reason_phrase; // Check Session Status.\n\n    if (this._status === C.STATUS_TERMINATED) {\n      throw new Exceptions.InvalidStateError(this._status);\n    }\n\n    switch (this._status) {\n      // - UAC -\n      case C.STATUS_NULL:\n      case C.STATUS_INVITE_SENT:\n      case C.STATUS_1XX_RECEIVED:\n        debug('canceling session');\n\n        if (status_code && (status_code < 200 || status_code >= 700)) {\n          throw new TypeError(\"Invalid status_code: \".concat(status_code));\n        } else if (status_code) {\n          reason_phrase = reason_phrase || JsSIP_C.REASON_PHRASE[status_code] || '';\n          cancel_reason = \"SIP ;cause=\".concat(status_code, \" ;text=\\\"\").concat(reason_phrase, \"\\\"\");\n        } // Check Session Status.\n\n\n        if (this._status === C.STATUS_NULL || this._status === C.STATUS_INVITE_SENT) {\n          this._is_canceled = true;\n          this._cancel_reason = cancel_reason;\n        } else if (this._status === C.STATUS_1XX_RECEIVED) {\n          this._request.cancel(cancel_reason);\n        }\n\n        this._status = C.STATUS_CANCELED;\n\n        this._failed('local', null, JsSIP_C.causes.CANCELED);\n\n        break;\n      // - UAS -\n\n      case C.STATUS_WAITING_FOR_ANSWER:\n      case C.STATUS_ANSWERED:\n        debug('rejecting session');\n        status_code = status_code || 480;\n\n        if (status_code < 300 || status_code >= 700) {\n          throw new TypeError(\"Invalid status_code: \".concat(status_code));\n        }\n\n        this._request.reply(status_code, reason_phrase, extraHeaders, body);\n\n        this._failed('local', null, JsSIP_C.causes.REJECTED);\n\n        break;\n\n      case C.STATUS_WAITING_FOR_ACK:\n      case C.STATUS_CONFIRMED:\n        debug('terminating session');\n        reason_phrase = options.reason_phrase || JsSIP_C.REASON_PHRASE[status_code] || '';\n\n        if (status_code && (status_code < 200 || status_code >= 700)) {\n          throw new TypeError(\"Invalid status_code: \".concat(status_code));\n        } else if (status_code) {\n          extraHeaders.push(\"Reason: SIP ;cause=\".concat(status_code, \"; text=\\\"\").concat(reason_phrase, \"\\\"\"));\n        }\n        /* RFC 3261 section 15 (Terminating a session):\n          *\n          * \"...the callee's UA MUST NOT send a BYE on a confirmed dialog\n          * until it has received an ACK for its 2xx response or until the server\n          * transaction times out.\"\n          */\n\n\n        if (this._status === C.STATUS_WAITING_FOR_ACK && this._direction === 'incoming' && this._request.server_transaction.state !== Transactions.C.STATUS_TERMINATED) {\n          // Save the dialog for later restoration.\n          const dialog = this._dialog; // Send the BYE as soon as the ACK is received...\n\n          this.receiveRequest = ({\n            method\n          }) => {\n            if (method === JsSIP_C.ACK) {\n              this.sendRequest(JsSIP_C.BYE, {\n                extraHeaders,\n                body\n              });\n              dialog.terminate();\n            }\n          }; // .., or when the INVITE transaction times out\n\n\n          this._request.server_transaction.on('stateChanged', () => {\n            if (this._request.server_transaction.state === Transactions.C.STATUS_TERMINATED) {\n              this.sendRequest(JsSIP_C.BYE, {\n                extraHeaders,\n                body\n              });\n              dialog.terminate();\n            }\n          });\n\n          this._ended('local', null, cause); // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-).\n\n\n          this._dialog = dialog; // Restore the dialog into 'ua' so the ACK can reach 'this' session.\n\n          this._ua.newDialog(dialog);\n        } else {\n          this.sendRequest(JsSIP_C.BYE, {\n            extraHeaders,\n            body\n          });\n\n          this._ended('local', null, cause);\n        }\n\n    }\n  }\n\n  sendDTMF(tones, options = {}) {\n    debug('sendDTMF() | tones: %s', tones);\n    let position = 0;\n    let duration = options.duration || null;\n    let interToneGap = options.interToneGap || null;\n\n    if (tones === undefined) {\n      throw new TypeError('Not enough arguments');\n    } // Check Session Status.\n\n\n    if (this._status !== C.STATUS_CONFIRMED && this._status !== C.STATUS_WAITING_FOR_ACK) {\n      throw new Exceptions.InvalidStateError(this._status);\n    } // Convert to string.\n\n\n    if (typeof tones === 'number') {\n      tones = tones.toString();\n    } // Check tones.\n\n\n    if (!tones || typeof tones !== 'string' || !tones.match(/^[0-9A-DR#*,]+$/i)) {\n      throw new TypeError(\"Invalid tones: \".concat(tones));\n    } // Check duration.\n\n\n    if (duration && !Utils.isDecimal(duration)) {\n      throw new TypeError(\"Invalid tone duration: \".concat(duration));\n    } else if (!duration) {\n      duration = RTCSession_DTMF.C.DEFAULT_DURATION;\n    } else if (duration < RTCSession_DTMF.C.MIN_DURATION) {\n      debug(\"\\\"duration\\\" value is lower than the minimum allowed, setting it to \".concat(RTCSession_DTMF.C.MIN_DURATION, \" milliseconds\"));\n      duration = RTCSession_DTMF.C.MIN_DURATION;\n    } else if (duration > RTCSession_DTMF.C.MAX_DURATION) {\n      debug(\"\\\"duration\\\" value is greater than the maximum allowed, setting it to \".concat(RTCSession_DTMF.C.MAX_DURATION, \" milliseconds\"));\n      duration = RTCSession_DTMF.C.MAX_DURATION;\n    } else {\n      duration = Math.abs(duration);\n    }\n\n    options.duration = duration; // Check interToneGap.\n\n    if (interToneGap && !Utils.isDecimal(interToneGap)) {\n      throw new TypeError(\"Invalid interToneGap: \".concat(interToneGap));\n    } else if (!interToneGap) {\n      interToneGap = RTCSession_DTMF.C.DEFAULT_INTER_TONE_GAP;\n    } else if (interToneGap < RTCSession_DTMF.C.MIN_INTER_TONE_GAP) {\n      debug(\"\\\"interToneGap\\\" value is lower than the minimum allowed, setting it to \".concat(RTCSession_DTMF.C.MIN_INTER_TONE_GAP, \" milliseconds\"));\n      interToneGap = RTCSession_DTMF.C.MIN_INTER_TONE_GAP;\n    } else {\n      interToneGap = Math.abs(interToneGap);\n    }\n\n    if (this._tones) {\n      // Tones are already queued, just add to the queue.\n      this._tones += tones;\n      return;\n    }\n\n    this._tones = tones; // Send the first tone.\n\n    _sendDTMF.call(this);\n\n    function _sendDTMF() {\n      let timeout;\n\n      if (this._status === C.STATUS_TERMINATED || !this._tones || position >= this._tones.length) {\n        // Stop sending DTMF.\n        this._tones = null;\n        return;\n      }\n\n      const tone = this._tones[position];\n      position += 1;\n\n      if (tone === ',') {\n        timeout = 2000;\n      } else {\n        const dtmf = new RTCSession_DTMF(this);\n        options.eventHandlers = {\n          onFailed: () => {\n            this._tones = null;\n          }\n        };\n        dtmf.send(tone, options);\n        timeout = duration + interToneGap;\n      } // Set timeout for the next tone.\n\n\n      setTimeout(_sendDTMF.bind(this), timeout);\n    }\n  }\n\n  sendInfo(contentType, body, options = {}) {\n    debug('sendInfo()'); // Check Session Status.\n\n    if (this._status !== C.STATUS_CONFIRMED && this._status !== C.STATUS_WAITING_FOR_ACK) {\n      throw new Exceptions.InvalidStateError(this._status);\n    }\n\n    const info = new RTCSession_Info(this);\n    info.send(contentType, body, options);\n  }\n  /**\n   * Mute\n   */\n\n\n  mute(options = {\n    audio: true,\n    video: false\n  }) {\n    debug('mute()');\n    let audioMuted = false,\n        videoMuted = false;\n\n    if (this._audioMuted === false && options.audio) {\n      audioMuted = true;\n      this._audioMuted = true;\n\n      this._toggleMuteAudio(true);\n    }\n\n    if (this._videoMuted === false && options.video) {\n      videoMuted = true;\n      this._videoMuted = true;\n\n      this._toggleMuteVideo(true);\n    }\n\n    if (audioMuted === true || videoMuted === true) {\n      this._onmute({\n        audio: audioMuted,\n        video: videoMuted\n      });\n    }\n  }\n  /**\n   * Unmute\n   */\n\n\n  unmute(options = {\n    audio: true,\n    video: true\n  }) {\n    debug('unmute()');\n    let audioUnMuted = false,\n        videoUnMuted = false;\n\n    if (this._audioMuted === true && options.audio) {\n      audioUnMuted = true;\n      this._audioMuted = false;\n\n      if (this._localHold === false) {\n        this._toggleMuteAudio(false);\n      }\n    }\n\n    if (this._videoMuted === true && options.video) {\n      videoUnMuted = true;\n      this._videoMuted = false;\n\n      if (this._localHold === false) {\n        this._toggleMuteVideo(false);\n      }\n    }\n\n    if (audioUnMuted === true || videoUnMuted === true) {\n      this._onunmute({\n        audio: audioUnMuted,\n        video: videoUnMuted\n      });\n    }\n  }\n  /**\n   * Hold\n   */\n\n\n  hold(options = {}, done) {\n    debug('hold()');\n\n    if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n      return false;\n    }\n\n    if (this._localHold === true) {\n      return false;\n    }\n\n    if (!this._isReadyToReOffer()) {\n      return false;\n    }\n\n    this._localHold = true;\n\n    this._onhold('local');\n\n    const eventHandlers = {\n      succeeded: () => {\n        if (done) {\n          done();\n        }\n      },\n      failed: () => {\n        this.terminate({\n          cause: JsSIP_C.causes.WEBRTC_ERROR,\n          status_code: 500,\n          reason_phrase: 'Hold Failed'\n        });\n      }\n    };\n\n    if (options.useUpdate) {\n      this._sendUpdate({\n        sdpOffer: true,\n        eventHandlers,\n        extraHeaders: options.extraHeaders\n      });\n    } else {\n      this._sendReinvite({\n        eventHandlers,\n        extraHeaders: options.extraHeaders\n      });\n    }\n\n    return true;\n  }\n\n  unhold(options = {}, done) {\n    debug('unhold()');\n\n    if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n      return false;\n    }\n\n    if (this._localHold === false) {\n      return false;\n    }\n\n    if (!this._isReadyToReOffer()) {\n      return false;\n    }\n\n    this._localHold = false;\n\n    this._onunhold('local');\n\n    const eventHandlers = {\n      succeeded: () => {\n        if (done) {\n          done();\n        }\n      },\n      failed: () => {\n        this.terminate({\n          cause: JsSIP_C.causes.WEBRTC_ERROR,\n          status_code: 500,\n          reason_phrase: 'Unhold Failed'\n        });\n      }\n    };\n\n    if (options.useUpdate) {\n      this._sendUpdate({\n        sdpOffer: true,\n        eventHandlers,\n        extraHeaders: options.extraHeaders\n      });\n    } else {\n      this._sendReinvite({\n        eventHandlers,\n        extraHeaders: options.extraHeaders\n      });\n    }\n\n    return true;\n  }\n\n  renegotiate(options = {}, done) {\n    debug('renegotiate()');\n    const rtcOfferConstraints = options.rtcOfferConstraints || null;\n\n    if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n      return false;\n    }\n\n    if (!this._isReadyToReOffer()) {\n      return false;\n    }\n\n    const eventHandlers = {\n      succeeded: () => {\n        if (done) {\n          done();\n        }\n      },\n      failed: () => {\n        this.terminate({\n          cause: JsSIP_C.causes.WEBRTC_ERROR,\n          status_code: 500,\n          reason_phrase: 'Media Renegotiation Failed'\n        });\n      }\n    };\n\n    this._setLocalMediaStatus();\n\n    if (options.useUpdate) {\n      this._sendUpdate({\n        sdpOffer: true,\n        eventHandlers,\n        rtcOfferConstraints,\n        extraHeaders: options.extraHeaders\n      });\n    } else {\n      this._sendReinvite({\n        eventHandlers,\n        rtcOfferConstraints,\n        extraHeaders: options.extraHeaders\n      });\n    }\n\n    return true;\n  }\n  /**\n   * Refer\n   */\n\n\n  refer(target, options) {\n    debug('refer()');\n    const originalTarget = target;\n\n    if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n      return false;\n    } // Check target validity.\n\n\n    target = this._ua.normalizeTarget(target);\n\n    if (!target) {\n      throw new TypeError(\"Invalid target: \".concat(originalTarget));\n    }\n\n    const referSubscriber = new RTCSession_ReferSubscriber(this);\n    referSubscriber.sendRefer(target, options); // Store in the map.\n\n    const id = referSubscriber.id;\n    this._referSubscribers[id] = referSubscriber; // Listen for ending events so we can remove it from the map.\n\n    referSubscriber.on('requestFailed', () => {\n      delete this._referSubscribers[id];\n    });\n    referSubscriber.on('accepted', () => {\n      delete this._referSubscribers[id];\n    });\n    referSubscriber.on('failed', () => {\n      delete this._referSubscribers[id];\n    });\n    return referSubscriber;\n  }\n  /**\n   * Send a generic in-dialog Request\n   */\n\n\n  sendRequest(method, options) {\n    debug('sendRequest()');\n    return this._dialog.sendRequest(method, options);\n  }\n  /**\n   * In dialog Request Reception\n   */\n\n\n  receiveRequest(request) {\n    debug('receiveRequest()');\n\n    if (request.method === JsSIP_C.CANCEL) {\n      /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL\n      * was in progress and that the UAC MAY continue with the session established by\n      * any 2xx response, or MAY terminate with BYE. JsSIP does continue with the\n      * established session. So the CANCEL is processed only if the session is not yet\n      * established.\n      */\n\n      /*\n      * Terminate the whole session in case the user didn't accept (or yet send the answer)\n      * nor reject the request opening the session.\n      */\n      if (this._status === C.STATUS_WAITING_FOR_ANSWER || this._status === C.STATUS_ANSWERED) {\n        this._status = C.STATUS_CANCELED;\n\n        this._request.reply(487);\n\n        this._failed('remote', request, JsSIP_C.causes.CANCELED);\n      }\n    } else {\n      // Requests arriving here are in-dialog requests.\n      switch (request.method) {\n        case JsSIP_C.ACK:\n          if (this._status !== C.STATUS_WAITING_FOR_ACK) {\n            return;\n          } // Update signaling status.\n\n\n          this._status = C.STATUS_CONFIRMED;\n          clearTimeout(this._timers.ackTimer);\n          clearTimeout(this._timers.invite2xxTimer);\n\n          if (this._late_sdp) {\n            if (!request.body) {\n              this.terminate({\n                cause: JsSIP_C.causes.MISSING_SDP,\n                status_code: 400\n              });\n              break;\n            }\n\n            const e = {\n              originator: 'remote',\n              type: 'answer',\n              sdp: request.body\n            };\n            debug('emit \"sdp\"');\n            this.emit('sdp', e);\n            const answer = new RTCSessionDescription({\n              type: 'answer',\n              sdp: e.sdp\n            });\n            this._connectionPromiseQueue = this._connectionPromiseQueue.then(() => this._connection.setRemoteDescription(answer)).then(() => {\n              if (!this._is_confirmed) {\n                this._confirmed('remote', request);\n              }\n            }).catch(error => {\n              this.terminate({\n                cause: JsSIP_C.causes.BAD_MEDIA_DESCRIPTION,\n                status_code: 488\n              });\n              debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n              this.emit('peerconnection:setremotedescriptionfailed', error);\n            });\n          } else if (!this._is_confirmed) {\n            this._confirmed('remote', request);\n          }\n\n          break;\n\n        case JsSIP_C.BYE:\n          if (this._status === C.STATUS_CONFIRMED || this._status === C.STATUS_WAITING_FOR_ACK) {\n            request.reply(200);\n\n            this._ended('remote', request, JsSIP_C.causes.BYE);\n          } else if (this._status === C.STATUS_INVITE_RECEIVED) {\n            request.reply(200);\n\n            this._request.reply(487, 'BYE Received');\n\n            this._ended('remote', request, JsSIP_C.causes.BYE);\n          } else {\n            request.reply(403, 'Wrong Status');\n          }\n\n          break;\n\n        case JsSIP_C.INVITE:\n          if (this._status === C.STATUS_CONFIRMED) {\n            if (request.hasHeader('replaces')) {\n              this._receiveReplaces(request);\n            } else {\n              this._receiveReinvite(request);\n            }\n          } else {\n            request.reply(403, 'Wrong Status');\n          }\n\n          break;\n\n        case JsSIP_C.INFO:\n          if (this._status === C.STATUS_1XX_RECEIVED || this._status === C.STATUS_WAITING_FOR_ANSWER || this._status === C.STATUS_ANSWERED || this._status === C.STATUS_WAITING_FOR_ACK || this._status === C.STATUS_CONFIRMED) {\n            const contentType = request.getHeader('content-type');\n\n            if (contentType && contentType.match(/^application\\/dtmf-relay/i)) {\n              new RTCSession_DTMF(this).init_incoming(request);\n            } else if (contentType !== undefined) {\n              new RTCSession_Info(this).init_incoming(request);\n            } else {\n              request.reply(415);\n            }\n          } else {\n            request.reply(403, 'Wrong Status');\n          }\n\n          break;\n\n        case JsSIP_C.UPDATE:\n          if (this._status === C.STATUS_CONFIRMED) {\n            this._receiveUpdate(request);\n          } else {\n            request.reply(403, 'Wrong Status');\n          }\n\n          break;\n\n        case JsSIP_C.REFER:\n          if (this._status === C.STATUS_CONFIRMED) {\n            this._receiveRefer(request);\n          } else {\n            request.reply(403, 'Wrong Status');\n          }\n\n          break;\n\n        case JsSIP_C.NOTIFY:\n          if (this._status === C.STATUS_CONFIRMED) {\n            this._receiveNotify(request);\n          } else {\n            request.reply(403, 'Wrong Status');\n          }\n\n          break;\n\n        default:\n          request.reply(501);\n      }\n    }\n  }\n  /**\n   * Session Callbacks\n   */\n\n\n  onTransportError() {\n    debugerror('onTransportError()');\n\n    if (this._status !== C.STATUS_TERMINATED) {\n      this.terminate({\n        status_code: 500,\n        reason_phrase: JsSIP_C.causes.CONNECTION_ERROR,\n        cause: JsSIP_C.causes.CONNECTION_ERROR\n      });\n    }\n  }\n\n  onRequestTimeout() {\n    debugerror('onRequestTimeout()');\n\n    if (this._status !== C.STATUS_TERMINATED) {\n      this.terminate({\n        status_code: 408,\n        reason_phrase: JsSIP_C.causes.REQUEST_TIMEOUT,\n        cause: JsSIP_C.causes.REQUEST_TIMEOUT\n      });\n    }\n  }\n\n  onDialogError() {\n    debugerror('onDialogError()');\n\n    if (this._status !== C.STATUS_TERMINATED) {\n      this.terminate({\n        status_code: 500,\n        reason_phrase: JsSIP_C.causes.DIALOG_ERROR,\n        cause: JsSIP_C.causes.DIALOG_ERROR\n      });\n    }\n  } // Called from DTMF handler.\n\n\n  newDTMF(data) {\n    debug('newDTMF()');\n    this.emit('newDTMF', data);\n  } // Called from Info handler.\n\n\n  newInfo(data) {\n    debug('newInfo()');\n    this.emit('newInfo', data);\n  }\n  /**\n   * Check if RTCSession is ready for an outgoing re-INVITE or UPDATE with SDP.\n   */\n\n\n  _isReadyToReOffer() {\n    if (!this._rtcReady) {\n      debug('_isReadyToReOffer() | internal WebRTC status not ready');\n      return false;\n    } // No established yet.\n\n\n    if (!this._dialog) {\n      debug('_isReadyToReOffer() | session not established yet');\n      return false;\n    } // Another INVITE transaction is in progress.\n\n\n    if (this._dialog.uac_pending_reply === true || this._dialog.uas_pending_reply === true) {\n      debug('_isReadyToReOffer() | there is another INVITE/UPDATE transaction in progress');\n      return false;\n    }\n\n    return true;\n  }\n\n  _close() {\n    debug('close()');\n\n    if (this._status === C.STATUS_TERMINATED) {\n      return;\n    }\n\n    this._status = C.STATUS_TERMINATED; // Terminate RTC.\n\n    if (this._connection) {\n      try {\n        this._connection.close();\n      } catch (error) {\n        debugerror('close() | error closing the RTCPeerConnection: %o', error);\n      }\n    } // Close local MediaStream if it was not given by the user.\n\n\n    if (this._localMediaStream && this._localMediaStreamLocallyGenerated) {\n      debug('close() | closing local MediaStream');\n      Utils.closeMediaStream(this._localMediaStream);\n    } // Terminate signaling.\n    // Clear SIP timers.\n\n\n    for (const timer in this._timers) {\n      if (Object.prototype.hasOwnProperty.call(this._timers, timer)) {\n        clearTimeout(this._timers[timer]);\n      }\n    } // Clear Session Timers.\n\n\n    clearTimeout(this._sessionTimers.timer); // Terminate confirmed dialog.\n\n    if (this._dialog) {\n      this._dialog.terminate();\n\n      delete this._dialog;\n    } // Terminate early dialogs.\n\n\n    for (const dialog in this._earlyDialogs) {\n      if (Object.prototype.hasOwnProperty.call(this._earlyDialogs, dialog)) {\n        this._earlyDialogs[dialog].terminate();\n\n        delete this._earlyDialogs[dialog];\n      }\n    } // Terminate REFER subscribers.\n\n\n    for (const subscriber in this._referSubscribers) {\n      if (Object.prototype.hasOwnProperty.call(this._referSubscribers, subscriber)) {\n        delete this._referSubscribers[subscriber];\n      }\n    }\n\n    this._ua.destroyRTCSession(this);\n  }\n  /**\n   * Private API.\n   */\n\n  /**\n   * RFC3261 13.3.1.4\n   * Response retransmissions cannot be accomplished by transaction layer\n   *  since it is destroyed when receiving the first 2xx answer\n   */\n\n\n  _setInvite2xxTimer(request, body) {\n    let timeout = Timers.T1;\n\n    function invite2xxRetransmission() {\n      if (this._status !== C.STATUS_WAITING_FOR_ACK) {\n        return;\n      }\n\n      request.reply(200, null, [\"Contact: \".concat(this._contact)], body);\n\n      if (timeout < Timers.T2) {\n        timeout = timeout * 2;\n\n        if (timeout > Timers.T2) {\n          timeout = Timers.T2;\n        }\n      }\n\n      this._timers.invite2xxTimer = setTimeout(invite2xxRetransmission.bind(this), timeout);\n    }\n\n    this._timers.invite2xxTimer = setTimeout(invite2xxRetransmission.bind(this), timeout);\n  }\n  /**\n   * RFC3261 14.2\n   * If a UAS generates a 2xx response and never receives an ACK,\n   *  it SHOULD generate a BYE to terminate the dialog.\n   */\n\n\n  _setACKTimer() {\n    this._timers.ackTimer = setTimeout(() => {\n      if (this._status === C.STATUS_WAITING_FOR_ACK) {\n        debug('no ACK received, terminating the session');\n        clearTimeout(this._timers.invite2xxTimer);\n        this.sendRequest(JsSIP_C.BYE);\n\n        this._ended('remote', null, JsSIP_C.causes.NO_ACK);\n      }\n    }, Timers.TIMER_H);\n  }\n\n  _createRTCConnection(pcConfig, rtcConstraints) {\n    this._connection = new RTCPeerConnection(pcConfig, rtcConstraints);\n\n    this._connection.addEventListener('iceconnectionstatechange', () => {\n      const state = this._connection.iceConnectionState; // TODO: Do more with different states.\n\n      if (state === 'failed') {\n        this.terminate({\n          cause: JsSIP_C.causes.RTP_TIMEOUT,\n          status_code: 408,\n          reason_phrase: JsSIP_C.causes.RTP_TIMEOUT\n        });\n      }\n    });\n\n    debug('emit \"peerconnection\"');\n    this.emit('peerconnection', {\n      peerconnection: this._connection\n    });\n  }\n\n  _createLocalDescription(type, constraints) {\n    debug('createLocalDescription()');\n    if (type !== 'offer' && type !== 'answer') throw new Error(\"createLocalDescription() | invalid type \\\"\".concat(type, \"\\\"\"));\n    const connection = this._connection;\n    this._rtcReady = false;\n    return Promise.resolve() // Create Offer or Answer.\n    .then(() => {\n      if (type === 'offer') {\n        return connection.createOffer(constraints).catch(error => {\n          debugerror('emit \"peerconnection:createofferfailed\" [error:%o]', error);\n          this.emit('peerconnection:createofferfailed', error);\n          return Promise.reject(error);\n        });\n      } else {\n        return connection.createAnswer(constraints).catch(error => {\n          debugerror('emit \"peerconnection:createanswerfailed\" [error:%o]', error);\n          this.emit('peerconnection:createanswerfailed', error);\n          return Promise.reject(error);\n        });\n      }\n    }) // Set local description.\n    .then(desc => {\n      return connection.setLocalDescription(desc).catch(error => {\n        this._rtcReady = true;\n        debugerror('emit \"peerconnection:setlocaldescriptionfailed\" [error:%o]', error);\n        this.emit('peerconnection:setlocaldescriptionfailed', error);\n        return Promise.reject(error);\n      });\n    }).then(() => {\n      // Resolve right away if 'pc.iceGatheringState' is 'complete'.\n      if (connection.iceGatheringState === 'complete') {\n        this._rtcReady = true;\n        const e = {\n          originator: 'local',\n          type: type,\n          sdp: connection.localDescription.sdp\n        };\n        debug('emit \"sdp\"');\n        this.emit('sdp', e);\n        return Promise.resolve(e.sdp);\n      } // Add 'pc.onicencandidate' event handler to resolve on last candidate.\n\n\n      return new Promise(resolve => {\n        let finished = false;\n        let iceCandidateListener;\n        let iceGatheringStateListener;\n\n        const ready = () => {\n          connection.removeEventListener('icecandidate', iceCandidateListener);\n          connection.removeEventListener('icegatheringstatechange', iceGatheringStateListener);\n          finished = true;\n          this._rtcReady = true;\n          const e = {\n            originator: 'local',\n            type: type,\n            sdp: connection.localDescription.sdp\n          };\n          debug('emit \"sdp\"');\n          this.emit('sdp', e);\n          resolve(e.sdp);\n        };\n\n        connection.addEventListener('icecandidate', iceCandidateListener = event => {\n          const candidate = event.candidate;\n\n          if (candidate) {\n            this.emit('icecandidate', {\n              candidate,\n              ready\n            });\n          } else if (!finished) {\n            ready();\n          }\n        });\n        connection.addEventListener('icegatheringstatechange', iceGatheringStateListener = () => {\n          if (connection.iceGatheringState === 'complete' && !finished) {\n            ready();\n          }\n        });\n      });\n    });\n  }\n  /**\n   * Dialog Management\n   */\n\n\n  _createDialog(message, type, early) {\n    const local_tag = type === 'UAS' ? message.to_tag : message.from_tag;\n    const remote_tag = type === 'UAS' ? message.from_tag : message.to_tag;\n    const id = message.call_id + local_tag + remote_tag;\n    let early_dialog = this._earlyDialogs[id]; // Early Dialog.\n\n    if (early) {\n      if (early_dialog) {\n        return true;\n      } else {\n        early_dialog = new Dialog(this, message, type, Dialog.C.STATUS_EARLY); // Dialog has been successfully created.\n\n        if (early_dialog.error) {\n          debug(early_dialog.error);\n\n          this._failed('remote', message, JsSIP_C.causes.INTERNAL_ERROR);\n\n          return false;\n        } else {\n          this._earlyDialogs[id] = early_dialog;\n          return true;\n        }\n      }\n    } // Confirmed Dialog.\n    else {\n        this._from_tag = message.from_tag;\n        this._to_tag = message.to_tag; // In case the dialog is in _early_ state, update it.\n\n        if (early_dialog) {\n          early_dialog.update(message, type);\n          this._dialog = early_dialog;\n          delete this._earlyDialogs[id];\n          return true;\n        } // Otherwise, create a _confirmed_ dialog.\n\n\n        const dialog = new Dialog(this, message, type);\n\n        if (dialog.error) {\n          debug(dialog.error);\n\n          this._failed('remote', message, JsSIP_C.causes.INTERNAL_ERROR);\n\n          return false;\n        } else {\n          this._dialog = dialog;\n          return true;\n        }\n      }\n  }\n  /**\n   * In dialog INVITE Reception\n   */\n\n\n  _receiveReinvite(request) {\n    debug('receiveReinvite()');\n    const contentType = request.getHeader('Content-Type');\n    const data = {\n      request,\n      callback: undefined,\n      reject: reject.bind(this)\n    };\n    let rejected = false;\n\n    function reject(options = {}) {\n      rejected = true;\n      const status_code = options.status_code || 403;\n      const reason_phrase = options.reason_phrase || '';\n      const extraHeaders = Utils.cloneArray(options.extraHeaders);\n\n      if (this._status !== C.STATUS_CONFIRMED) {\n        return false;\n      }\n\n      if (status_code < 300 || status_code >= 700) {\n        throw new TypeError(\"Invalid status_code: \".concat(status_code));\n      }\n\n      request.reply(status_code, reason_phrase, extraHeaders);\n    } // Emit 'reinvite'.\n\n\n    this.emit('reinvite', data);\n\n    if (rejected) {\n      return;\n    }\n\n    this._late_sdp = false; // Request without SDP.\n\n    if (!request.body) {\n      this._late_sdp = true;\n      this._connectionPromiseQueue = this._connectionPromiseQueue.then(() => this._createLocalDescription('offer', this._rtcOfferConstraints)).then(sdp => {\n        sendAnswer.call(this, sdp);\n      }).catch(() => {\n        request.reply(500);\n      });\n      return;\n    } // Request with SDP.\n\n\n    if (contentType !== 'application/sdp') {\n      debug('invalid Content-Type');\n      request.reply(415);\n      return;\n    }\n\n    this._processInDialogSdpOffer(request) // Send answer.\n    .then(desc => {\n      if (this._status === C.STATUS_TERMINATED) {\n        return;\n      }\n\n      sendAnswer.call(this, desc);\n    }).catch(error => {\n      debugerror(error);\n    });\n\n    function sendAnswer(desc) {\n      const extraHeaders = [\"Contact: \".concat(this._contact)];\n\n      this._handleSessionTimersInIncomingRequest(request, extraHeaders);\n\n      if (this._late_sdp) {\n        desc = this._mangleOffer(desc);\n      }\n\n      request.reply(200, null, extraHeaders, desc, () => {\n        this._status = C.STATUS_WAITING_FOR_ACK;\n\n        this._setInvite2xxTimer(request, desc);\n\n        this._setACKTimer();\n      }); // If callback is given execute it.\n\n      if (typeof data.callback === 'function') {\n        data.callback();\n      }\n    }\n  }\n  /**\n   * In dialog UPDATE Reception\n   */\n\n\n  _receiveUpdate(request) {\n    debug('receiveUpdate()');\n    const contentType = request.getHeader('Content-Type');\n    const data = {\n      request,\n      callback: undefined,\n      reject: reject.bind(this)\n    };\n    let rejected = false;\n\n    function reject(options = {}) {\n      rejected = true;\n      const status_code = options.status_code || 403;\n      const reason_phrase = options.reason_phrase || '';\n      const extraHeaders = Utils.cloneArray(options.extraHeaders);\n\n      if (this._status !== C.STATUS_CONFIRMED) {\n        return false;\n      }\n\n      if (status_code < 300 || status_code >= 700) {\n        throw new TypeError(\"Invalid status_code: \".concat(status_code));\n      }\n\n      request.reply(status_code, reason_phrase, extraHeaders);\n    } // Emit 'update'.\n\n\n    this.emit('update', data);\n\n    if (rejected) {\n      return;\n    }\n\n    if (!request.body) {\n      sendAnswer.call(this, null);\n      return;\n    }\n\n    if (contentType !== 'application/sdp') {\n      debug('invalid Content-Type');\n      request.reply(415);\n      return;\n    }\n\n    this._processInDialogSdpOffer(request) // Send answer.\n    .then(desc => {\n      if (this._status === C.STATUS_TERMINATED) {\n        return;\n      }\n\n      sendAnswer.call(this, desc);\n    }).catch(error => {\n      debugerror(error);\n    });\n\n    function sendAnswer(desc) {\n      const extraHeaders = [\"Contact: \".concat(this._contact)];\n\n      this._handleSessionTimersInIncomingRequest(request, extraHeaders);\n\n      request.reply(200, null, extraHeaders, desc); // If callback is given execute it.\n\n      if (typeof data.callback === 'function') {\n        data.callback();\n      }\n    }\n  }\n\n  _processInDialogSdpOffer(request) {\n    debug('_processInDialogSdpOffer()');\n    const sdp = request.parseSDP();\n    let hold = false;\n\n    for (const m of sdp.media) {\n      if (holdMediaTypes.indexOf(m.type) === -1) {\n        continue;\n      }\n\n      const direction = m.direction || sdp.direction || 'sendrecv';\n\n      if (direction === 'sendonly' || direction === 'inactive') {\n        hold = true;\n      } // If at least one of the streams is active don't emit 'hold'.\n      else {\n          hold = false;\n          break;\n        }\n    }\n\n    const e = {\n      originator: 'remote',\n      type: 'offer',\n      sdp: request.body\n    };\n    debug('emit \"sdp\"');\n    this.emit('sdp', e);\n    const offer = new RTCSessionDescription({\n      type: 'offer',\n      sdp: e.sdp\n    });\n    this._connectionPromiseQueue = this._connectionPromiseQueue // Set remote description.\n    .then(() => {\n      if (this._status === C.STATUS_TERMINATED) {\n        throw new Error('terminated');\n      }\n\n      return this._connection.setRemoteDescription(offer).catch(error => {\n        request.reply(488);\n        debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n        this.emit('peerconnection:setremotedescriptionfailed', error);\n        throw new Error('peerconnection.setRemoteDescription() failed');\n      });\n    }).then(() => {\n      if (this._status === C.STATUS_TERMINATED) {\n        throw new Error('terminated');\n      }\n\n      if (this._remoteHold === true && hold === false) {\n        this._remoteHold = false;\n\n        this._onunhold('remote');\n      } else if (this._remoteHold === false && hold === true) {\n        this._remoteHold = true;\n\n        this._onhold('remote');\n      }\n    }) // Create local description.\n    .then(() => {\n      if (this._status === C.STATUS_TERMINATED) {\n        throw new Error('terminated');\n      }\n\n      return this._createLocalDescription('answer', this._rtcAnswerConstraints).catch(() => {\n        request.reply(500);\n        throw new Error('_createLocalDescription() failed');\n      });\n    });\n    return this._connectionPromiseQueue;\n  }\n  /**\n   * In dialog Refer Reception\n   */\n\n\n  _receiveRefer(request) {\n    debug('receiveRefer()');\n\n    if (!request.refer_to) {\n      debug('no Refer-To header field present in REFER');\n      request.reply(400);\n      return;\n    }\n\n    if (request.refer_to.uri.scheme !== JsSIP_C.SIP) {\n      debug('Refer-To header field points to a non-SIP URI scheme');\n      request.reply(416);\n      return;\n    } // Reply before the transaction timer expires.\n\n\n    request.reply(202);\n    const notifier = new RTCSession_ReferNotifier(this, request.cseq);\n    debug('emit \"refer\"'); // Emit 'refer'.\n\n    this.emit('refer', {\n      request,\n      accept: (initCallback, options) => {\n        accept.call(this, initCallback, options);\n      },\n      reject: () => {\n        reject.call(this);\n      }\n    });\n\n    function accept(initCallback, options = {}) {\n      initCallback = typeof initCallback === 'function' ? initCallback : null;\n\n      if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n        return false;\n      }\n\n      const session = new RTCSession(this._ua);\n      session.on('progress', ({\n        response\n      }) => {\n        notifier.notify(response.status_code, response.reason_phrase);\n      });\n      session.on('accepted', ({\n        response\n      }) => {\n        notifier.notify(response.status_code, response.reason_phrase);\n      });\n      session.on('_failed', ({\n        message,\n        cause\n      }) => {\n        if (message) {\n          notifier.notify(message.status_code, message.reason_phrase);\n        } else {\n          notifier.notify(487, cause);\n        }\n      }); // Consider the Replaces header present in the Refer-To URI.\n\n      if (request.refer_to.uri.hasHeader('replaces')) {\n        const replaces = decodeURIComponent(request.refer_to.uri.getHeader('replaces'));\n        options.extraHeaders = Utils.cloneArray(options.extraHeaders);\n        options.extraHeaders.push(\"Replaces: \".concat(replaces));\n      }\n\n      session.connect(request.refer_to.uri.toAor(), options, initCallback);\n    }\n\n    function reject() {\n      notifier.notify(603);\n    }\n  }\n  /**\n   * In dialog Notify Reception\n   */\n\n\n  _receiveNotify(request) {\n    debug('receiveNotify()');\n\n    if (!request.event) {\n      request.reply(400);\n    }\n\n    switch (request.event.event) {\n      case 'refer':\n        {\n          let id;\n          let referSubscriber;\n\n          if (request.event.params && request.event.params.id) {\n            id = request.event.params.id;\n            referSubscriber = this._referSubscribers[id];\n          } else if (Object.keys(this._referSubscribers).length === 1) {\n            referSubscriber = this._referSubscribers[Object.keys(this._referSubscribers)[0]];\n          } else {\n            request.reply(400, 'Missing event id parameter');\n            return;\n          }\n\n          if (!referSubscriber) {\n            request.reply(481, 'Subscription does not exist');\n            return;\n          }\n\n          referSubscriber.receiveNotify(request);\n          request.reply(200);\n          break;\n        }\n\n      default:\n        {\n          request.reply(489);\n        }\n    }\n  }\n  /**\n   * INVITE with Replaces Reception\n   */\n\n\n  _receiveReplaces(request) {\n    debug('receiveReplaces()');\n\n    function accept(initCallback) {\n      if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n        return false;\n      }\n\n      const session = new RTCSession(this._ua); // Terminate the current session when the new one is confirmed.\n\n      session.on('confirmed', () => {\n        this.terminate();\n      });\n      session.init_incoming(request, initCallback);\n    }\n\n    function reject() {\n      debug('Replaced INVITE rejected by the user');\n      request.reply(486);\n    } // Emit 'replace'.\n\n\n    this.emit('replaces', {\n      request,\n      accept: initCallback => {\n        accept.call(this, initCallback);\n      },\n      reject: () => {\n        reject.call(this);\n      }\n    });\n  }\n  /**\n   * Initial Request Sender\n   */\n\n\n  _sendInitialRequest(mediaConstraints, rtcOfferConstraints, mediaStream) {\n    const request_sender = new RequestSender(this._ua, this._request, {\n      onRequestTimeout: () => {\n        this.onRequestTimeout();\n      },\n      onTransportError: () => {\n        this.onTransportError();\n      },\n      // Update the request on authentication.\n      onAuthenticated: request => {\n        this._request = request;\n      },\n      onReceiveResponse: response => {\n        this._receiveInviteResponse(response);\n      }\n    }); // This Promise is resolved within the next iteration, so the app has now\n    // a chance to set events such as 'peerconnection' and 'connecting'.\n\n    Promise.resolve() // Get a stream if required.\n    .then(() => {\n      // A stream is given, let the app set events such as 'peerconnection' and 'connecting'.\n      if (mediaStream) {\n        return mediaStream;\n      } // Request for user media access.\n      else if (mediaConstraints.audio || mediaConstraints.video) {\n          this._localMediaStreamLocallyGenerated = true;\n          return navigator.mediaDevices.getUserMedia(mediaConstraints).catch(error => {\n            if (this._status === C.STATUS_TERMINATED) {\n              throw new Error('terminated');\n            }\n\n            this._failed('local', null, JsSIP_C.causes.USER_DENIED_MEDIA_ACCESS);\n\n            debugerror('emit \"getusermediafailed\" [error:%o]', error);\n            this.emit('getusermediafailed', error);\n            throw error;\n          });\n        }\n    }).then(stream => {\n      if (this._status === C.STATUS_TERMINATED) {\n        throw new Error('terminated');\n      }\n\n      this._localMediaStream = stream;\n\n      if (stream) {\n        stream.getTracks().forEach(track => {\n          this._connection.addTrack(track, stream);\n        });\n      } // TODO: should this be triggered here?\n\n\n      this._connecting(this._request);\n\n      return this._createLocalDescription('offer', rtcOfferConstraints).catch(error => {\n        this._failed('local', null, JsSIP_C.causes.WEBRTC_ERROR);\n\n        throw error;\n      });\n    }).then(desc => {\n      if (this._is_canceled || this._status === C.STATUS_TERMINATED) {\n        throw new Error('terminated');\n      }\n\n      this._request.body = desc;\n      this._status = C.STATUS_INVITE_SENT;\n      debug('emit \"sending\" [request:%o]', this._request); // Emit 'sending' so the app can mangle the body before the request is sent.\n\n      this.emit('sending', {\n        request: this._request\n      });\n      request_sender.send();\n    }).catch(error => {\n      if (this._status === C.STATUS_TERMINATED) {\n        return;\n      }\n\n      debugerror(error);\n    });\n  }\n  /**\n   * Reception of Response for Initial INVITE\n   */\n\n\n  _receiveInviteResponse(response) {\n    debug('receiveInviteResponse()'); // Handle 2XX retransmissions and responses from forked requests.\n\n    if (this._dialog && response.status_code >= 200 && response.status_code <= 299) {\n      /*\n       * If it is a retransmission from the endpoint that established\n       * the dialog, send an ACK\n       */\n      if (this._dialog.id.call_id === response.call_id && this._dialog.id.local_tag === response.from_tag && this._dialog.id.remote_tag === response.to_tag) {\n        this.sendRequest(JsSIP_C.ACK);\n        return;\n      } // If not, send an ACK  and terminate.\n      else {\n          const dialog = new Dialog(this, response, 'UAC');\n\n          if (dialog.error !== undefined) {\n            debug(dialog.error);\n            return;\n          }\n\n          this.sendRequest(JsSIP_C.ACK);\n          this.sendRequest(JsSIP_C.BYE);\n          return;\n        }\n    } // Proceed to cancellation if the user requested.\n\n\n    if (this._is_canceled) {\n      if (response.status_code >= 100 && response.status_code < 200) {\n        this._request.cancel(this._cancel_reason);\n      } else if (response.status_code >= 200 && response.status_code < 299) {\n        this._acceptAndTerminate(response);\n      }\n\n      return;\n    }\n\n    if (this._status !== C.STATUS_INVITE_SENT && this._status !== C.STATUS_1XX_RECEIVED) {\n      return;\n    }\n\n    switch (true) {\n      case /^100$/.test(response.status_code):\n        this._status = C.STATUS_1XX_RECEIVED;\n        break;\n\n      case /^1[0-9]{2}$/.test(response.status_code):\n        {\n          // Do nothing with 1xx responses without To tag.\n          if (!response.to_tag) {\n            debug('1xx response received without to tag');\n            break;\n          } // Create Early Dialog if 1XX comes with contact.\n\n\n          if (response.hasHeader('contact')) {\n            // An error on dialog creation will fire 'failed' event.\n            if (!this._createDialog(response, 'UAC', true)) {\n              break;\n            }\n          }\n\n          this._status = C.STATUS_1XX_RECEIVED;\n\n          this._progress('remote', response);\n\n          if (!response.body) {\n            break;\n          }\n\n          const e = {\n            originator: 'remote',\n            type: 'answer',\n            sdp: response.body\n          };\n          debug('emit \"sdp\"');\n          this.emit('sdp', e);\n          const answer = new RTCSessionDescription({\n            type: 'answer',\n            sdp: e.sdp\n          });\n          this._connectionPromiseQueue = this._connectionPromiseQueue.then(() => this._connection.setRemoteDescription(answer)).catch(error => {\n            debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n            this.emit('peerconnection:setremotedescriptionfailed', error);\n          });\n          break;\n        }\n\n      case /^2[0-9]{2}$/.test(response.status_code):\n        {\n          this._status = C.STATUS_CONFIRMED;\n\n          if (!response.body) {\n            this._acceptAndTerminate(response, 400, JsSIP_C.causes.MISSING_SDP);\n\n            this._failed('remote', response, JsSIP_C.causes.BAD_MEDIA_DESCRIPTION);\n\n            break;\n          } // An error on dialog creation will fire 'failed' event.\n\n\n          if (!this._createDialog(response, 'UAC')) {\n            break;\n          }\n\n          const e = {\n            originator: 'remote',\n            type: 'answer',\n            sdp: response.body\n          };\n          debug('emit \"sdp\"');\n          this.emit('sdp', e);\n          const answer = new RTCSessionDescription({\n            type: 'answer',\n            sdp: e.sdp\n          });\n          this._connectionPromiseQueue = this._connectionPromiseQueue.then(() => {\n            // Be ready for 200 with SDP after a 180/183 with SDP.\n            // We created a SDP 'answer' for it, so check the current signaling state.\n            if (this._connection.signalingState === 'stable') {\n              return this._connection.createOffer(this._rtcOfferConstraints).then(offer => this._connection.setLocalDescription(offer)).catch(error => {\n                this._acceptAndTerminate(response, 500, error.toString());\n\n                this._failed('local', response, JsSIP_C.causes.WEBRTC_ERROR);\n              });\n            }\n          }).then(() => {\n            this._connection.setRemoteDescription(answer).then(() => {\n              // Handle Session Timers.\n              this._handleSessionTimersInIncomingResponse(response);\n\n              this._accepted('remote', response);\n\n              this.sendRequest(JsSIP_C.ACK);\n\n              this._confirmed('local', null);\n            }).catch(error => {\n              this._acceptAndTerminate(response, 488, 'Not Acceptable Here');\n\n              this._failed('remote', response, JsSIP_C.causes.BAD_MEDIA_DESCRIPTION);\n\n              debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n              this.emit('peerconnection:setremotedescriptionfailed', error);\n            });\n          });\n          break;\n        }\n\n      default:\n        {\n          const cause = Utils.sipErrorCause(response.status_code);\n\n          this._failed('remote', response, cause);\n        }\n    }\n  }\n  /**\n   * Send Re-INVITE\n   */\n\n\n  _sendReinvite(options = {}) {\n    debug('sendReinvite()');\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const eventHandlers = options.eventHandlers || {};\n    const rtcOfferConstraints = options.rtcOfferConstraints || this._rtcOfferConstraints || null;\n    let succeeded = false;\n    extraHeaders.push(\"Contact: \".concat(this._contact));\n    extraHeaders.push('Content-Type: application/sdp'); // Session Timers.\n\n    if (this._sessionTimers.running) {\n      extraHeaders.push(\"Session-Expires: \".concat(this._sessionTimers.currentExpires, \";refresher=\").concat(this._sessionTimers.refresher ? 'uac' : 'uas'));\n    }\n\n    this._connectionPromiseQueue = this._connectionPromiseQueue.then(() => this._createLocalDescription('offer', rtcOfferConstraints)).then(sdp => {\n      sdp = this._mangleOffer(sdp);\n      const e = {\n        originator: 'local',\n        type: 'offer',\n        sdp\n      };\n      debug('emit \"sdp\"');\n      this.emit('sdp', e);\n      this.sendRequest(JsSIP_C.INVITE, {\n        extraHeaders,\n        body: sdp,\n        eventHandlers: {\n          onSuccessResponse: response => {\n            onSucceeded.call(this, response);\n            succeeded = true;\n          },\n          onErrorResponse: response => {\n            onFailed.call(this, response);\n          },\n          onTransportError: () => {\n            this.onTransportError(); // Do nothing because session ends.\n          },\n          onRequestTimeout: () => {\n            this.onRequestTimeout(); // Do nothing because session ends.\n          },\n          onDialogError: () => {\n            this.onDialogError(); // Do nothing because session ends.\n          }\n        }\n      });\n    }).catch(() => {\n      onFailed();\n    });\n\n    function onSucceeded(response) {\n      if (this._status === C.STATUS_TERMINATED) {\n        return;\n      }\n\n      this.sendRequest(JsSIP_C.ACK); // If it is a 2XX retransmission exit now.\n\n      if (succeeded) {\n        return;\n      } // Handle Session Timers.\n\n\n      this._handleSessionTimersInIncomingResponse(response); // Must have SDP answer.\n\n\n      if (!response.body) {\n        onFailed.call(this);\n        return;\n      } else if (response.getHeader('Content-Type') !== 'application/sdp') {\n        onFailed.call(this);\n        return;\n      }\n\n      const e = {\n        originator: 'remote',\n        type: 'answer',\n        sdp: response.body\n      };\n      debug('emit \"sdp\"');\n      this.emit('sdp', e);\n      const answer = new RTCSessionDescription({\n        type: 'answer',\n        sdp: e.sdp\n      });\n      this._connectionPromiseQueue = this._connectionPromiseQueue.then(() => this._connection.setRemoteDescription(answer)).then(() => {\n        if (eventHandlers.succeeded) {\n          eventHandlers.succeeded(response);\n        }\n      }).catch(error => {\n        onFailed.call(this);\n        debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n        this.emit('peerconnection:setremotedescriptionfailed', error);\n      });\n    }\n\n    function onFailed(response) {\n      if (eventHandlers.failed) {\n        eventHandlers.failed(response);\n      }\n    }\n  }\n  /**\n   * Send UPDATE\n   */\n\n\n  _sendUpdate(options = {}) {\n    debug('sendUpdate()');\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const eventHandlers = options.eventHandlers || {};\n    const rtcOfferConstraints = options.rtcOfferConstraints || this._rtcOfferConstraints || null;\n    const sdpOffer = options.sdpOffer || false;\n    let succeeded = false;\n    extraHeaders.push(\"Contact: \".concat(this._contact)); // Session Timers.\n\n    if (this._sessionTimers.running) {\n      extraHeaders.push(\"Session-Expires: \".concat(this._sessionTimers.currentExpires, \";refresher=\").concat(this._sessionTimers.refresher ? 'uac' : 'uas'));\n    }\n\n    if (sdpOffer) {\n      extraHeaders.push('Content-Type: application/sdp');\n      this._connectionPromiseQueue = this._connectionPromiseQueue.then(() => this._createLocalDescription('offer', rtcOfferConstraints)).then(sdp => {\n        sdp = this._mangleOffer(sdp);\n        const e = {\n          originator: 'local',\n          type: 'offer',\n          sdp\n        };\n        debug('emit \"sdp\"');\n        this.emit('sdp', e);\n        this.sendRequest(JsSIP_C.UPDATE, {\n          extraHeaders,\n          body: sdp,\n          eventHandlers: {\n            onSuccessResponse: response => {\n              onSucceeded.call(this, response);\n              succeeded = true;\n            },\n            onErrorResponse: response => {\n              onFailed.call(this, response);\n            },\n            onTransportError: () => {\n              this.onTransportError(); // Do nothing because session ends.\n            },\n            onRequestTimeout: () => {\n              this.onRequestTimeout(); // Do nothing because session ends.\n            },\n            onDialogError: () => {\n              this.onDialogError(); // Do nothing because session ends.\n            }\n          }\n        });\n      }).catch(() => {\n        onFailed.call(this);\n      });\n    } // No SDP.\n    else {\n        this.sendRequest(JsSIP_C.UPDATE, {\n          extraHeaders,\n          eventHandlers: {\n            onSuccessResponse: response => {\n              onSucceeded.call(this, response);\n            },\n            onErrorResponse: response => {\n              onFailed.call(this, response);\n            },\n            onTransportError: () => {\n              this.onTransportError(); // Do nothing because session ends.\n            },\n            onRequestTimeout: () => {\n              this.onRequestTimeout(); // Do nothing because session ends.\n            },\n            onDialogError: () => {\n              this.onDialogError(); // Do nothing because session ends.\n            }\n          }\n        });\n      }\n\n    function onSucceeded(response) {\n      if (this._status === C.STATUS_TERMINATED) {\n        return;\n      } // If it is a 2XX retransmission exit now.\n\n\n      if (succeeded) {\n        return;\n      } // Handle Session Timers.\n\n\n      this._handleSessionTimersInIncomingResponse(response); // Must have SDP answer.\n\n\n      if (sdpOffer) {\n        if (!response.body) {\n          onFailed.call(this);\n          return;\n        } else if (response.getHeader('Content-Type') !== 'application/sdp') {\n          onFailed.call(this);\n          return;\n        }\n\n        const e = {\n          originator: 'remote',\n          type: 'answer',\n          sdp: response.body\n        };\n        debug('emit \"sdp\"');\n        this.emit('sdp', e);\n        const answer = new RTCSessionDescription({\n          type: 'answer',\n          sdp: e.sdp\n        });\n        this._connectionPromiseQueue = this._connectionPromiseQueue.then(() => this._connection.setRemoteDescription(answer)).then(() => {\n          if (eventHandlers.succeeded) {\n            eventHandlers.succeeded(response);\n          }\n        }).catch(error => {\n          onFailed.call(this);\n          debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n          this.emit('peerconnection:setremotedescriptionfailed', error);\n        });\n      } // No SDP answer.\n      else if (eventHandlers.succeeded) {\n          eventHandlers.succeeded(response);\n        }\n    }\n\n    function onFailed(response) {\n      if (eventHandlers.failed) {\n        eventHandlers.failed(response);\n      }\n    }\n  }\n\n  _acceptAndTerminate(response, status_code, reason_phrase) {\n    debug('acceptAndTerminate()');\n    const extraHeaders = [];\n\n    if (status_code) {\n      reason_phrase = reason_phrase || JsSIP_C.REASON_PHRASE[status_code] || '';\n      extraHeaders.push(\"Reason: SIP ;cause=\".concat(status_code, \"; text=\\\"\").concat(reason_phrase, \"\\\"\"));\n    } // An error on dialog creation will fire 'failed' event.\n\n\n    if (this._dialog || this._createDialog(response, 'UAC')) {\n      this.sendRequest(JsSIP_C.ACK);\n      this.sendRequest(JsSIP_C.BYE, {\n        extraHeaders\n      });\n    } // Update session status.\n\n\n    this._status = C.STATUS_TERMINATED;\n  }\n  /**\n   * Correctly set the SDP direction attributes if the call is on local hold\n   */\n\n\n  _mangleOffer(sdp) {\n    if (!this._localHold && !this._remoteHold) {\n      return sdp;\n    }\n\n    sdp = sdp_transform.parse(sdp); // Local hold.\n\n    if (this._localHold && !this._remoteHold) {\n      debug('mangleOffer() | me on hold, mangling offer');\n\n      for (const m of sdp.media) {\n        if (holdMediaTypes.indexOf(m.type) === -1) {\n          continue;\n        }\n\n        if (!m.direction) {\n          m.direction = 'sendonly';\n        } else if (m.direction === 'sendrecv') {\n          m.direction = 'sendonly';\n        } else if (m.direction === 'recvonly') {\n          m.direction = 'inactive';\n        }\n      }\n    } // Local and remote hold.\n    else if (this._localHold && this._remoteHold) {\n        debug('mangleOffer() | both on hold, mangling offer');\n\n        for (const m of sdp.media) {\n          if (holdMediaTypes.indexOf(m.type) === -1) {\n            continue;\n          }\n\n          m.direction = 'inactive';\n        }\n      } // Remote hold.\n      else if (this._remoteHold) {\n          debug('mangleOffer() | remote on hold, mangling offer');\n\n          for (const m of sdp.media) {\n            if (holdMediaTypes.indexOf(m.type) === -1) {\n              continue;\n            }\n\n            if (!m.direction) {\n              m.direction = 'recvonly';\n            } else if (m.direction === 'sendrecv') {\n              m.direction = 'recvonly';\n            } else if (m.direction === 'recvonly') {\n              m.direction = 'inactive';\n            }\n          }\n        }\n\n    return sdp_transform.write(sdp);\n  }\n\n  _setLocalMediaStatus() {\n    let enableAudio = true,\n        enableVideo = true;\n\n    if (this._localHold || this._remoteHold) {\n      enableAudio = false;\n      enableVideo = false;\n    }\n\n    if (this._audioMuted) {\n      enableAudio = false;\n    }\n\n    if (this._videoMuted) {\n      enableVideo = false;\n    }\n\n    this._toggleMuteAudio(!enableAudio);\n\n    this._toggleMuteVideo(!enableVideo);\n  }\n  /**\n   * Handle SessionTimers for an incoming INVITE or UPDATE.\n   * @param  {IncomingRequest} request\n   * @param  {Array} responseExtraHeaders  Extra headers for the 200 response.\n   */\n\n\n  _handleSessionTimersInIncomingRequest(request, responseExtraHeaders) {\n    if (!this._sessionTimers.enabled) {\n      return;\n    }\n\n    let session_expires_refresher;\n\n    if (request.session_expires && request.session_expires >= JsSIP_C.MIN_SESSION_EXPIRES) {\n      this._sessionTimers.currentExpires = request.session_expires;\n      session_expires_refresher = request.session_expires_refresher || 'uas';\n    } else {\n      this._sessionTimers.currentExpires = this._sessionTimers.defaultExpires;\n      session_expires_refresher = 'uas';\n    }\n\n    responseExtraHeaders.push(\"Session-Expires: \".concat(this._sessionTimers.currentExpires, \";refresher=\").concat(session_expires_refresher));\n    this._sessionTimers.refresher = session_expires_refresher === 'uas';\n\n    this._runSessionTimer();\n  }\n  /**\n   * Handle SessionTimers for an incoming response to INVITE or UPDATE.\n   * @param  {IncomingResponse} response\n   */\n\n\n  _handleSessionTimersInIncomingResponse(response) {\n    if (!this._sessionTimers.enabled) {\n      return;\n    }\n\n    let session_expires_refresher;\n\n    if (response.session_expires && response.session_expires >= JsSIP_C.MIN_SESSION_EXPIRES) {\n      this._sessionTimers.currentExpires = response.session_expires;\n      session_expires_refresher = response.session_expires_refresher || 'uac';\n    } else {\n      this._sessionTimers.currentExpires = this._sessionTimers.defaultExpires;\n      session_expires_refresher = 'uac';\n    }\n\n    this._sessionTimers.refresher = session_expires_refresher === 'uac';\n\n    this._runSessionTimer();\n  }\n\n  _runSessionTimer() {\n    const expires = this._sessionTimers.currentExpires;\n    this._sessionTimers.running = true;\n    clearTimeout(this._sessionTimers.timer); // I'm the refresher.\n\n    if (this._sessionTimers.refresher) {\n      this._sessionTimers.timer = setTimeout(() => {\n        if (this._status === C.STATUS_TERMINATED) {\n          return;\n        }\n\n        debug('runSessionTimer() | sending session refresh request');\n\n        if (this._sessionTimers.refreshMethod === JsSIP_C.UPDATE) {\n          this._sendUpdate();\n        } else {\n          this._sendReinvite();\n        }\n      }, expires * 500); // Half the given interval (as the RFC states).\n    } // I'm not the refresher.\n    else {\n        this._sessionTimers.timer = setTimeout(() => {\n          if (this._status === C.STATUS_TERMINATED) {\n            return;\n          }\n\n          debugerror('runSessionTimer() | timer expired, terminating the session');\n          this.terminate({\n            cause: JsSIP_C.causes.REQUEST_TIMEOUT,\n            status_code: 408,\n            reason_phrase: 'Session Timer Expired'\n          });\n        }, expires * 1100);\n      }\n  }\n\n  _toggleMuteAudio(mute) {\n    const senders = this._connection.getSenders().filter(sender => {\n      return sender.track && sender.track.kind === 'audio';\n    });\n\n    for (const sender of senders) {\n      sender.track.enabled = !mute;\n    }\n  }\n\n  _toggleMuteVideo(mute) {\n    const senders = this._connection.getSenders().filter(sender => {\n      return sender.track && sender.track.kind === 'video';\n    });\n\n    for (const sender of senders) {\n      sender.track.enabled = !mute;\n    }\n  }\n\n  _newRTCSession(originator, request) {\n    debug('newRTCSession()');\n\n    this._ua.newRTCSession(this, {\n      originator,\n      session: this,\n      request\n    });\n  }\n\n  _connecting(request) {\n    debug('session connecting');\n    debug('emit \"connecting\"');\n    this.emit('connecting', {\n      request\n    });\n  }\n\n  _progress(originator, response) {\n    debug('session progress');\n    debug('emit \"progress\"');\n    this.emit('progress', {\n      originator,\n      response: response || null\n    });\n  }\n\n  _accepted(originator, message) {\n    debug('session accepted');\n    this._start_time = new Date();\n    debug('emit \"accepted\"');\n    this.emit('accepted', {\n      originator,\n      response: message || null\n    });\n  }\n\n  _confirmed(originator, ack) {\n    debug('session confirmed');\n    this._is_confirmed = true;\n    debug('emit \"confirmed\"');\n    this.emit('confirmed', {\n      originator,\n      ack: ack || null\n    });\n  }\n\n  _ended(originator, message, cause) {\n    debug('session ended');\n    this._end_time = new Date();\n\n    this._close();\n\n    debug('emit \"ended\"');\n    this.emit('ended', {\n      originator,\n      message: message || null,\n      cause\n    });\n  }\n\n  _failed(originator, message, cause) {\n    debug('session failed'); // Emit private '_failed' event first.\n\n    debug('emit \"_failed\"');\n    this.emit('_failed', {\n      originator,\n      message: message || null,\n      cause\n    });\n\n    this._close();\n\n    debug('emit \"failed\"');\n    this.emit('failed', {\n      originator,\n      message: message || null,\n      cause\n    });\n  }\n\n  _onhold(originator) {\n    debug('session onhold');\n\n    this._setLocalMediaStatus();\n\n    debug('emit \"hold\"');\n    this.emit('hold', {\n      originator\n    });\n  }\n\n  _onunhold(originator) {\n    debug('session onunhold');\n\n    this._setLocalMediaStatus();\n\n    debug('emit \"unhold\"');\n    this.emit('unhold', {\n      originator\n    });\n  }\n\n  _onmute({\n    audio,\n    video\n  }) {\n    debug('session onmute');\n\n    this._setLocalMediaStatus();\n\n    debug('emit \"muted\"');\n    this.emit('muted', {\n      audio,\n      video\n    });\n  }\n\n  _onunmute({\n    audio,\n    video\n  }) {\n    debug('session onunmute');\n\n    this._setLocalMediaStatus();\n\n    debug('emit \"unmuted\"');\n    this.emit('unmuted', {\n      audio,\n      video\n    });\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}