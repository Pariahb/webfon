{"ast":null,"code":"const JsSIP_C = require('./Constants');\n\nconst URI = require('./URI');\n\nconst Grammar = require('./Grammar');\n\nexports.str_utf8_length = string => unescape(encodeURIComponent(string)).length; // Used by 'hasMethods'.\n\n\nconst isFunction = exports.isFunction = fn => {\n  if (fn !== undefined) {\n    return Object.prototype.toString.call(fn) === '[object Function]' ? true : false;\n  } else {\n    return false;\n  }\n};\n\nexports.isString = str => {\n  if (str !== undefined) {\n    return Object.prototype.toString.call(str) === '[object String]' ? true : false;\n  } else {\n    return false;\n  }\n};\n\nexports.isDecimal = num => !isNaN(num) && parseFloat(num) === parseInt(num, 10);\n\nexports.isEmpty = value => {\n  return value === null || value === '' || value === undefined || Array.isArray(value) && value.length === 0 || typeof value === 'number' && isNaN(value);\n};\n\nexports.hasMethods = function (obj, ...methodNames) {\n  for (const methodName of methodNames) {\n    if (isFunction(obj[methodName])) {\n      return false;\n    }\n  }\n\n  return true;\n}; // Used by 'newTag'.\n\n\nconst createRandomToken = exports.createRandomToken = (size, base = 32) => {\n  let i,\n      r,\n      token = '';\n\n  for (i = 0; i < size; i++) {\n    r = Math.random() * base | 0;\n    token += r.toString(base);\n  }\n\n  return token;\n};\n\nexports.newTag = () => createRandomToken(10); // https://stackoverflow.com/users/109538/broofa.\n\n\nexports.newUUID = () => {\n  const UUID = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = Math.random() * 16 | 0,\n          v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n  return UUID;\n};\n\nexports.hostType = host => {\n  if (!host) {\n    return;\n  } else {\n    host = Grammar.parse(host, 'host');\n\n    if (host !== -1) {\n      return host.host_type;\n    }\n  }\n};\n/**\n* Hex-escape a SIP URI user.\n* Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F\"), '/' (%2F).\n*\n* Used by 'normalizeTarget'.\n*/\n\n\nconst escapeUser = exports.escapeUser = user => encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');\n/**\n* Normalize SIP URI.\n* NOTE: It does not allow a SIP URI without username.\n* Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.\n* Detects the domain part (if given) and properly hex-escapes the user portion.\n* If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.\n*/\n\n\nexports.normalizeTarget = (target, domain) => {\n  // If no target is given then raise an error.\n  if (!target) {\n    return; // If a URI instance is given then return it.\n  } else if (target instanceof URI) {\n    return target; // If a string is given split it by '@':\n    // - Last fragment is the desired domain.\n    // - Otherwise append the given domain argument.\n  } else if (typeof target === 'string') {\n    const target_array = target.split('@');\n    let target_user;\n    let target_domain;\n\n    switch (target_array.length) {\n      case 1:\n        if (!domain) {\n          return;\n        }\n\n        target_user = target;\n        target_domain = domain;\n        break;\n\n      case 2:\n        target_user = target_array[0];\n        target_domain = target_array[1];\n        break;\n\n      default:\n        target_user = target_array.slice(0, target_array.length - 1).join('@');\n        target_domain = target_array[target_array.length - 1];\n    } // Remove the URI scheme (if present).\n\n\n    target_user = target_user.replace(/^(sips?|tel):/i, ''); // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.\n\n    if (/^[-.()]*\\+?[0-9\\-.()]+$/.test(target_user)) {\n      target_user = target_user.replace(/[-.()]/g, '');\n    } // Build the complete SIP URI.\n\n\n    target = \"\".concat(JsSIP_C.SIP, \":\").concat(escapeUser(target_user), \"@\").concat(target_domain); // Finally parse the resulting URI.\n\n    let uri;\n\n    if (uri = URI.parse(target)) {\n      return uri;\n    } else {\n      return;\n    }\n  } else {\n    return;\n  }\n};\n\nexports.headerize = string => {\n  const exceptions = {\n    'Call-Id': 'Call-ID',\n    'Cseq': 'CSeq',\n    'Www-Authenticate': 'WWW-Authenticate'\n  };\n  const name = string.toLowerCase().replace(/_/g, '-').split('-');\n  let hname = '';\n  const parts = name.length;\n  let part;\n\n  for (part = 0; part < parts; part++) {\n    if (part !== 0) {\n      hname += '-';\n    }\n\n    hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);\n  }\n\n  if (exceptions[hname]) {\n    hname = exceptions[hname];\n  }\n\n  return hname;\n};\n\nexports.sipErrorCause = status_code => {\n  for (const cause in JsSIP_C.SIP_ERROR_CAUSES) {\n    if (JsSIP_C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {\n      return JsSIP_C.causes[cause];\n    }\n  }\n\n  return JsSIP_C.causes.SIP_FAILURE_CODE;\n};\n/**\n* Generate a random Test-Net IP (https://tools.ietf.org/html/rfc5735)\n*/\n\n\nexports.getRandomTestNetIP = () => {\n  function getOctet(from, to) {\n    return Math.floor(Math.random() * (to - from + 1) + from);\n  }\n\n  return \"192.0.2.\".concat(getOctet(1, 254));\n}; // MD5 (Message-Digest Algorithm) https://www.webtoolkit.info.\n\n\nexports.calculateMD5 = string => {\n  function rotateLeft(lValue, iShiftBits) {\n    return lValue << iShiftBits | lValue >>> 32 - iShiftBits;\n  }\n\n  function addUnsigned(lX, lY) {\n    const lX8 = lX & 0x80000000;\n    const lY8 = lY & 0x80000000;\n    const lX4 = lX & 0x40000000;\n    const lY4 = lY & 0x40000000;\n    const lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);\n\n    if (lX4 & lY4) {\n      return lResult ^ 0x80000000 ^ lX8 ^ lY8;\n    }\n\n    if (lX4 | lY4) {\n      if (lResult & 0x40000000) {\n        return lResult ^ 0xC0000000 ^ lX8 ^ lY8;\n      } else {\n        return lResult ^ 0x40000000 ^ lX8 ^ lY8;\n      }\n    } else {\n      return lResult ^ lX8 ^ lY8;\n    }\n  }\n\n  function doF(x, y, z) {\n    return x & y | ~x & z;\n  }\n\n  function doG(x, y, z) {\n    return x & z | y & ~z;\n  }\n\n  function doH(x, y, z) {\n    return x ^ y ^ z;\n  }\n\n  function doI(x, y, z) {\n    return y ^ (x | ~z);\n  }\n\n  function doFF(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(doF(b, c, d), x), ac));\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function doGG(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(doG(b, c, d), x), ac));\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function doHH(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(doH(b, c, d), x), ac));\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function doII(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(doI(b, c, d), x), ac));\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function convertToWordArray(str) {\n    let lWordCount;\n    const lMessageLength = str.length;\n    const lNumberOfWords_temp1 = lMessageLength + 8;\n    const lNumberOfWords_temp2 = (lNumberOfWords_temp1 - lNumberOfWords_temp1 % 64) / 64;\n    const lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;\n    const lWordArray = new Array(lNumberOfWords - 1);\n    let lBytePosition = 0;\n    let lByteCount = 0;\n\n    while (lByteCount < lMessageLength) {\n      lWordCount = (lByteCount - lByteCount % 4) / 4;\n      lBytePosition = lByteCount % 4 * 8;\n      lWordArray[lWordCount] = lWordArray[lWordCount] | str.charCodeAt(lByteCount) << lBytePosition;\n      lByteCount++;\n    }\n\n    lWordCount = (lByteCount - lByteCount % 4) / 4;\n    lBytePosition = lByteCount % 4 * 8;\n    lWordArray[lWordCount] = lWordArray[lWordCount] | 0x80 << lBytePosition;\n    lWordArray[lNumberOfWords - 2] = lMessageLength << 3;\n    lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;\n    return lWordArray;\n  }\n\n  function wordToHex(lValue) {\n    let wordToHexValue = '',\n        wordToHexValue_temp = '',\n        lByte,\n        lCount;\n\n    for (lCount = 0; lCount <= 3; lCount++) {\n      lByte = lValue >>> lCount * 8 & 255;\n      wordToHexValue_temp = \"0\".concat(lByte.toString(16));\n      wordToHexValue = wordToHexValue + wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);\n    }\n\n    return wordToHexValue;\n  }\n\n  function utf8Encode(str) {\n    str = str.replace(/\\r\\n/g, '\\n');\n    let utftext = '';\n\n    for (let n = 0; n < str.length; n++) {\n      const c = str.charCodeAt(n);\n\n      if (c < 128) {\n        utftext += String.fromCharCode(c);\n      } else if (c > 127 && c < 2048) {\n        utftext += String.fromCharCode(c >> 6 | 192);\n        utftext += String.fromCharCode(c & 63 | 128);\n      } else {\n        utftext += String.fromCharCode(c >> 12 | 224);\n        utftext += String.fromCharCode(c >> 6 & 63 | 128);\n        utftext += String.fromCharCode(c & 63 | 128);\n      }\n    }\n\n    return utftext;\n  }\n\n  let x = [];\n  let k, AA, BB, CC, DD, a, b, c, d;\n  const S11 = 7,\n        S12 = 12,\n        S13 = 17,\n        S14 = 22;\n  const S21 = 5,\n        S22 = 9,\n        S23 = 14,\n        S24 = 20;\n  const S31 = 4,\n        S32 = 11,\n        S33 = 16,\n        S34 = 23;\n  const S41 = 6,\n        S42 = 10,\n        S43 = 15,\n        S44 = 21;\n  string = utf8Encode(string);\n  x = convertToWordArray(string);\n  a = 0x67452301;\n  b = 0xEFCDAB89;\n  c = 0x98BADCFE;\n  d = 0x10325476;\n\n  for (k = 0; k < x.length; k += 16) {\n    AA = a;\n    BB = b;\n    CC = c;\n    DD = d;\n    a = doFF(a, b, c, d, x[k + 0], S11, 0xD76AA478);\n    d = doFF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);\n    c = doFF(c, d, a, b, x[k + 2], S13, 0x242070DB);\n    b = doFF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);\n    a = doFF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);\n    d = doFF(d, a, b, c, x[k + 5], S12, 0x4787C62A);\n    c = doFF(c, d, a, b, x[k + 6], S13, 0xA8304613);\n    b = doFF(b, c, d, a, x[k + 7], S14, 0xFD469501);\n    a = doFF(a, b, c, d, x[k + 8], S11, 0x698098D8);\n    d = doFF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);\n    c = doFF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);\n    b = doFF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);\n    a = doFF(a, b, c, d, x[k + 12], S11, 0x6B901122);\n    d = doFF(d, a, b, c, x[k + 13], S12, 0xFD987193);\n    c = doFF(c, d, a, b, x[k + 14], S13, 0xA679438E);\n    b = doFF(b, c, d, a, x[k + 15], S14, 0x49B40821);\n    a = doGG(a, b, c, d, x[k + 1], S21, 0xF61E2562);\n    d = doGG(d, a, b, c, x[k + 6], S22, 0xC040B340);\n    c = doGG(c, d, a, b, x[k + 11], S23, 0x265E5A51);\n    b = doGG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);\n    a = doGG(a, b, c, d, x[k + 5], S21, 0xD62F105D);\n    d = doGG(d, a, b, c, x[k + 10], S22, 0x2441453);\n    c = doGG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);\n    b = doGG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);\n    a = doGG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);\n    d = doGG(d, a, b, c, x[k + 14], S22, 0xC33707D6);\n    c = doGG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);\n    b = doGG(b, c, d, a, x[k + 8], S24, 0x455A14ED);\n    a = doGG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);\n    d = doGG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);\n    c = doGG(c, d, a, b, x[k + 7], S23, 0x676F02D9);\n    b = doGG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);\n    a = doHH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);\n    d = doHH(d, a, b, c, x[k + 8], S32, 0x8771F681);\n    c = doHH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);\n    b = doHH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);\n    a = doHH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);\n    d = doHH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);\n    c = doHH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);\n    b = doHH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);\n    a = doHH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);\n    d = doHH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);\n    c = doHH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);\n    b = doHH(b, c, d, a, x[k + 6], S34, 0x4881D05);\n    a = doHH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);\n    d = doHH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);\n    c = doHH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);\n    b = doHH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);\n    a = doII(a, b, c, d, x[k + 0], S41, 0xF4292244);\n    d = doII(d, a, b, c, x[k + 7], S42, 0x432AFF97);\n    c = doII(c, d, a, b, x[k + 14], S43, 0xAB9423A7);\n    b = doII(b, c, d, a, x[k + 5], S44, 0xFC93A039);\n    a = doII(a, b, c, d, x[k + 12], S41, 0x655B59C3);\n    d = doII(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);\n    c = doII(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);\n    b = doII(b, c, d, a, x[k + 1], S44, 0x85845DD1);\n    a = doII(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);\n    d = doII(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);\n    c = doII(c, d, a, b, x[k + 6], S43, 0xA3014314);\n    b = doII(b, c, d, a, x[k + 13], S44, 0x4E0811A1);\n    a = doII(a, b, c, d, x[k + 4], S41, 0xF7537E82);\n    d = doII(d, a, b, c, x[k + 11], S42, 0xBD3AF235);\n    c = doII(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);\n    b = doII(b, c, d, a, x[k + 9], S44, 0xEB86D391);\n    a = addUnsigned(a, AA);\n    b = addUnsigned(b, BB);\n    c = addUnsigned(c, CC);\n    d = addUnsigned(d, DD);\n  }\n\n  const temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);\n  return temp.toLowerCase();\n};\n\nexports.closeMediaStream = stream => {\n  if (!stream) {\n    return;\n  } // Latest spec states that MediaStream has no stop() method and instead must\n  // call stop() on every MediaStreamTrack.\n\n\n  try {\n    let tracks;\n\n    if (stream.getTracks) {\n      tracks = stream.getTracks();\n\n      for (const track of tracks) {\n        track.stop();\n      }\n    } else {\n      tracks = stream.getAudioTracks();\n\n      for (const track of tracks) {\n        track.stop();\n      }\n\n      tracks = stream.getVideoTracks();\n\n      for (const track of tracks) {\n        track.stop();\n      }\n    }\n  } catch (error) {\n    // Deprecated by the spec, but still in use.\n    // NOTE: In Temasys IE plugin stream.stop is a callable 'object'.\n    if (typeof stream.stop === 'function' || typeof stream.stop === 'object') {\n      stream.stop();\n    }\n  }\n};\n\nexports.cloneArray = array => {\n  return array && array.slice() || [];\n};","map":null,"metadata":{},"sourceType":"script"}