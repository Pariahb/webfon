{"ast":null,"code":"const sdp_transform = require('sdp-transform');\n\nconst JsSIP_C = require('./Constants');\n\nconst Utils = require('./Utils');\n\nconst NameAddrHeader = require('./NameAddrHeader');\n\nconst Grammar = require('./Grammar');\n\nconst debug = require('debug')('JsSIP:SIPMessage');\n/**\n * -param {String} method request method\n * -param {String} ruri request uri\n * -param {UA} ua\n * -param {Object} params parameters that will have priority over ua.configuration parameters:\n * <br>\n *  - cseq, call_id, from_tag, from_uri, from_display_name, to_uri, to_tag, route_set\n * -param {Object} [headers] extra headers\n * -param {String} [body]\n */\n\n\nclass OutgoingRequest {\n  constructor(method, ruri, ua, params, extraHeaders, body) {\n    // Mandatory parameters check.\n    if (!method || !ruri || !ua) {\n      return null;\n    }\n\n    params = params || {};\n    this.ua = ua;\n    this.headers = {};\n    this.method = method;\n    this.ruri = ruri;\n    this.body = body;\n    this.extraHeaders = Utils.cloneArray(extraHeaders); // Fill the Common SIP Request Headers.\n    // Route.\n\n    if (params.route_set) {\n      this.setHeader('route', params.route_set);\n    } else if (ua.configuration.use_preloaded_route) {\n      this.setHeader('route', \"<\".concat(ua.transport.sip_uri, \";lr>\"));\n    } // Via.\n    // Empty Via header. Will be filled by the client transaction.\n\n\n    this.setHeader('via', ''); // Max-Forwards.\n\n    this.setHeader('max-forwards', JsSIP_C.MAX_FORWARDS); // To\n\n    const to_uri = params.to_uri || ruri;\n    const to_params = params.to_tag ? {\n      tag: params.to_tag\n    } : null;\n    const to_display_name = typeof params.to_display_name !== 'undefined' ? params.to_display_name : null;\n    this.to = new NameAddrHeader(to_uri, to_display_name, to_params);\n    this.setHeader('to', this.to.toString()); // From.\n\n    const from_uri = params.from_uri || ua.configuration.uri;\n    const from_params = {\n      tag: params.from_tag || Utils.newTag()\n    };\n    let display_name;\n\n    if (typeof params.from_display_name !== 'undefined') {\n      display_name = params.from_display_name;\n    } else if (ua.configuration.display_name) {\n      display_name = ua.configuration.display_name;\n    } else {\n      display_name = null;\n    }\n\n    this.from = new NameAddrHeader(from_uri, display_name, from_params);\n    this.setHeader('from', this.from.toString()); // Call-ID.\n\n    const call_id = params.call_id || ua.configuration.jssip_id + Utils.createRandomToken(15);\n    this.call_id = call_id;\n    this.setHeader('call-id', call_id); // CSeq.\n\n    const cseq = params.cseq || Math.floor(Math.random() * 10000);\n    this.cseq = cseq;\n    this.setHeader('cseq', \"\".concat(cseq, \" \").concat(method));\n  }\n  /**\n   * Replace the the given header by the given value.\n   * -param {String} name header name\n   * -param {String | Array} value header value\n   */\n\n\n  setHeader(name, value) {\n    // Remove the header from extraHeaders if present.\n    const regexp = new RegExp(\"^\\\\s*\".concat(name, \"\\\\s*:\"), 'i');\n\n    for (let idx = 0; idx < this.extraHeaders.length; idx++) {\n      if (regexp.test(this.extraHeaders[idx])) {\n        this.extraHeaders.splice(idx, 1);\n      }\n    }\n\n    this.headers[Utils.headerize(name)] = Array.isArray(value) ? value : [value];\n  }\n  /**\n   * Get the value of the given header name at the given position.\n   * -param {String} name header name\n   * -returns {String|undefined} Returns the specified header, null if header doesn't exist.\n   */\n\n\n  getHeader(name) {\n    const headers = this.headers[Utils.headerize(name)];\n\n    if (headers) {\n      if (headers[0]) {\n        return headers[0];\n      }\n    } else {\n      const regexp = new RegExp(\"^\\\\s*\".concat(name, \"\\\\s*:\"), 'i');\n\n      for (const header of this.extraHeaders) {\n        if (regexp.test(header)) {\n          return header.substring(header.indexOf(':') + 1).trim();\n        }\n      }\n    }\n\n    return;\n  }\n  /**\n   * Get the header/s of the given name.\n   * -param {String} name header name\n   * -returns {Array} Array with all the headers of the specified name.\n   */\n\n\n  getHeaders(name) {\n    const headers = this.headers[Utils.headerize(name)];\n    const result = [];\n\n    if (headers) {\n      for (const header of headers) {\n        result.push(header);\n      }\n\n      return result;\n    } else {\n      const regexp = new RegExp(\"^\\\\s*\".concat(name, \"\\\\s*:\"), 'i');\n\n      for (const header of this.extraHeaders) {\n        if (regexp.test(header)) {\n          result.push(header.substring(header.indexOf(':') + 1).trim());\n        }\n      }\n\n      return result;\n    }\n  }\n  /**\n   * Verify the existence of the given header.\n   * -param {String} name header name\n   * -returns {boolean} true if header with given name exists, false otherwise\n   */\n\n\n  hasHeader(name) {\n    if (this.headers[Utils.headerize(name)]) {\n      return true;\n    } else {\n      const regexp = new RegExp(\"^\\\\s*\".concat(name, \"\\\\s*:\"), 'i');\n\n      for (const header of this.extraHeaders) {\n        if (regexp.test(header)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Parse the current body as a SDP and store the resulting object\n   * into this.sdp.\n   * -param {Boolean} force: Parse even if this.sdp already exists.\n   *\n   * Returns this.sdp.\n   */\n\n\n  parseSDP(force) {\n    if (!force && this.sdp) {\n      return this.sdp;\n    } else {\n      this.sdp = sdp_transform.parse(this.body || '');\n      return this.sdp;\n    }\n  }\n\n  toString() {\n    let msg = \"\".concat(this.method, \" \").concat(this.ruri, \" SIP/2.0\\r\\n\");\n\n    for (const headerName in this.headers) {\n      if (Object.prototype.hasOwnProperty.call(this.headers, headerName)) {\n        for (const headerValue of this.headers[headerName]) {\n          msg += \"\".concat(headerName, \": \").concat(headerValue, \"\\r\\n\");\n        }\n      }\n    }\n\n    for (const header of this.extraHeaders) {\n      msg += \"\".concat(header.trim(), \"\\r\\n\");\n    } // Supported.\n\n\n    const supported = [];\n\n    switch (this.method) {\n      case JsSIP_C.REGISTER:\n        supported.push('path', 'gruu');\n        break;\n\n      case JsSIP_C.INVITE:\n        if (this.ua.configuration.session_timers) {\n          supported.push('timer');\n        }\n\n        if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu) {\n          supported.push('gruu');\n        }\n\n        supported.push('ice', 'replaces');\n        break;\n\n      case JsSIP_C.UPDATE:\n        if (this.ua.configuration.session_timers) {\n          supported.push('timer');\n        }\n\n        supported.push('ice');\n        break;\n    }\n\n    supported.push('outbound');\n    const userAgent = this.ua.configuration.user_agent || JsSIP_C.USER_AGENT; // Allow.\n\n    msg += \"Allow: \".concat(JsSIP_C.ALLOWED_METHODS, \"\\r\\n\");\n    msg += \"Supported: \".concat(supported, \"\\r\\n\");\n    msg += \"User-Agent: \".concat(userAgent, \"\\r\\n\");\n\n    if (this.body) {\n      const length = Utils.str_utf8_length(this.body);\n      msg += \"Content-Length: \".concat(length, \"\\r\\n\\r\\n\");\n      msg += this.body;\n    } else {\n      msg += 'Content-Length: 0\\r\\n\\r\\n';\n    }\n\n    return msg;\n  }\n\n  clone() {\n    const request = new OutgoingRequest(this.method, this.ruri, this.ua);\n    Object.keys(this.headers).forEach(function (name) {\n      request.headers[name] = this.headers[name].slice();\n    }, this);\n    request.body = this.body;\n    request.extraHeaders = Utils.cloneArray(this.extraHeaders);\n    request.to = this.to;\n    request.from = this.from;\n    request.call_id = this.call_id;\n    request.cseq = this.cseq;\n    return request;\n  }\n\n}\n\nclass InitialOutgoingInviteRequest extends OutgoingRequest {\n  constructor(ruri, ua, params, extraHeaders, body) {\n    super(JsSIP_C.INVITE, ruri, ua, params, extraHeaders, body);\n    this.transaction = null;\n  }\n\n  cancel(reason) {\n    this.transaction.cancel(reason);\n  }\n\n  clone() {\n    const request = new InitialOutgoingInviteRequest(this.ruri, this.ua);\n    Object.keys(this.headers).forEach(function (name) {\n      request.headers[name] = this.headers[name].slice();\n    }, this);\n    request.body = this.body;\n    request.extraHeaders = Utils.cloneArray(this.extraHeaders);\n    request.to = this.to;\n    request.from = this.from;\n    request.call_id = this.call_id;\n    request.cseq = this.cseq;\n    request.transaction = this.transaction;\n    return request;\n  }\n\n}\n\nclass IncomingMessage {\n  constructor() {\n    this.data = null;\n    this.headers = null;\n    this.method = null;\n    this.via = null;\n    this.via_branch = null;\n    this.call_id = null;\n    this.cseq = null;\n    this.from = null;\n    this.from_tag = null;\n    this.to = null;\n    this.to_tag = null;\n    this.body = null;\n    this.sdp = null;\n  }\n  /**\n  * Insert a header of the given name and value into the last position of the\n  * header array.\n  */\n\n\n  addHeader(name, value) {\n    const header = {\n      raw: value\n    };\n    name = Utils.headerize(name);\n\n    if (this.headers[name]) {\n      this.headers[name].push(header);\n    } else {\n      this.headers[name] = [header];\n    }\n  }\n  /**\n   * Get the value of the given header name at the given position.\n   */\n\n\n  getHeader(name) {\n    const header = this.headers[Utils.headerize(name)];\n\n    if (header) {\n      if (header[0]) {\n        return header[0].raw;\n      }\n    } else {\n      return;\n    }\n  }\n  /**\n   * Get the header/s of the given name.\n   */\n\n\n  getHeaders(name) {\n    const headers = this.headers[Utils.headerize(name)];\n    const result = [];\n\n    if (!headers) {\n      return [];\n    }\n\n    for (const header of headers) {\n      result.push(header.raw);\n    }\n\n    return result;\n  }\n  /**\n   * Verify the existence of the given header.\n   */\n\n\n  hasHeader(name) {\n    return this.headers[Utils.headerize(name)] ? true : false;\n  }\n  /**\n  * Parse the given header on the given index.\n  * -param {String} name header name\n  * -param {Number} [idx=0] header index\n  * -returns {Object|undefined} Parsed header object, undefined if the header\n  *  is not present or in case of a parsing error.\n  */\n\n\n  parseHeader(name, idx = 0) {\n    name = Utils.headerize(name);\n\n    if (!this.headers[name]) {\n      debug(\"header \\\"\".concat(name, \"\\\" not present\"));\n      return;\n    } else if (idx >= this.headers[name].length) {\n      debug(\"not so many \\\"\".concat(name, \"\\\" headers present\"));\n      return;\n    }\n\n    const header = this.headers[name][idx];\n    const value = header.raw;\n\n    if (header.parsed) {\n      return header.parsed;\n    } // Substitute '-' by '_' for grammar rule matching.\n\n\n    const parsed = Grammar.parse(value, name.replace(/-/g, '_'));\n\n    if (parsed === -1) {\n      this.headers[name].splice(idx, 1); // delete from headers\n\n      debug(\"error parsing \\\"\".concat(name, \"\\\" header field with value \\\"\").concat(value, \"\\\"\"));\n      return;\n    } else {\n      header.parsed = parsed;\n      return parsed;\n    }\n  }\n  /**\n   * Message Header attribute selector. Alias of parseHeader.\n   * -param {String} name header name\n   * -param {Number} [idx=0] header index\n   * -returns {Object|undefined} Parsed header object, undefined if the header\n   *  is not present or in case of a parsing error.\n   *\n   * -example\n   * message.s('via',3).port\n   */\n\n\n  s(name, idx) {\n    return this.parseHeader(name, idx);\n  }\n  /**\n  * Replace the value of the given header by the value.\n  * -param {String} name header name\n  * -param {String} value header value\n  */\n\n\n  setHeader(name, value) {\n    const header = {\n      raw: value\n    };\n    this.headers[Utils.headerize(name)] = [header];\n  }\n  /**\n   * Parse the current body as a SDP and store the resulting object\n   * into this.sdp.\n   * -param {Boolean} force: Parse even if this.sdp already exists.\n   *\n   * Returns this.sdp.\n   */\n\n\n  parseSDP(force) {\n    if (!force && this.sdp) {\n      return this.sdp;\n    } else {\n      this.sdp = sdp_transform.parse(this.body || '');\n      return this.sdp;\n    }\n  }\n\n  toString() {\n    return this.data;\n  }\n\n}\n\nclass IncomingRequest extends IncomingMessage {\n  constructor(ua) {\n    super();\n    this.ua = ua;\n    this.headers = {};\n    this.ruri = null;\n    this.transport = null;\n    this.server_transaction = null;\n  }\n  /**\n  * Stateful reply.\n  * -param {Number} code status code\n  * -param {String} reason reason phrase\n  * -param {Object} headers extra headers\n  * -param {String} body body\n  * -param {Function} [onSuccess] onSuccess callback\n  * -param {Function} [onFailure] onFailure callback\n  */\n\n\n  reply(code, reason, extraHeaders, body, onSuccess, onFailure) {\n    const supported = [];\n    let to = this.getHeader('To');\n    code = code || null;\n    reason = reason || null; // Validate code and reason values.\n\n    if (!code || code < 100 || code > 699) {\n      throw new TypeError(\"Invalid status_code: \".concat(code));\n    } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n      throw new TypeError(\"Invalid reason_phrase: \".concat(reason));\n    }\n\n    reason = reason || JsSIP_C.REASON_PHRASE[code] || '';\n    extraHeaders = Utils.cloneArray(extraHeaders);\n    let response = \"SIP/2.0 \".concat(code, \" \").concat(reason, \"\\r\\n\");\n\n    if (this.method === JsSIP_C.INVITE && code > 100 && code <= 200) {\n      const headers = this.getHeaders('record-route');\n\n      for (const header of headers) {\n        response += \"Record-Route: \".concat(header, \"\\r\\n\");\n      }\n    }\n\n    const vias = this.getHeaders('via');\n\n    for (const via of vias) {\n      response += \"Via: \".concat(via, \"\\r\\n\");\n    }\n\n    if (!this.to_tag && code > 100) {\n      to += \";tag=\".concat(Utils.newTag());\n    } else if (this.to_tag && !this.s('to').hasParam('tag')) {\n      to += \";tag=\".concat(this.to_tag);\n    }\n\n    response += \"To: \".concat(to, \"\\r\\n\");\n    response += \"From: \".concat(this.getHeader('From'), \"\\r\\n\");\n    response += \"Call-ID: \".concat(this.call_id, \"\\r\\n\");\n    response += \"CSeq: \".concat(this.cseq, \" \").concat(this.method, \"\\r\\n\");\n\n    for (const header of extraHeaders) {\n      response += \"\".concat(header.trim(), \"\\r\\n\");\n    } // Supported.\n\n\n    switch (this.method) {\n      case JsSIP_C.INVITE:\n        if (this.ua.configuration.session_timers) {\n          supported.push('timer');\n        }\n\n        if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu) {\n          supported.push('gruu');\n        }\n\n        supported.push('ice', 'replaces');\n        break;\n\n      case JsSIP_C.UPDATE:\n        if (this.ua.configuration.session_timers) {\n          supported.push('timer');\n        }\n\n        if (body) {\n          supported.push('ice');\n        }\n\n        supported.push('replaces');\n    }\n\n    supported.push('outbound'); // Allow and Accept.\n\n    if (this.method === JsSIP_C.OPTIONS) {\n      response += \"Allow: \".concat(JsSIP_C.ALLOWED_METHODS, \"\\r\\n\");\n      response += \"Accept: \".concat(JsSIP_C.ACCEPTED_BODY_TYPES, \"\\r\\n\");\n    } else if (code === 405) {\n      response += \"Allow: \".concat(JsSIP_C.ALLOWED_METHODS, \"\\r\\n\");\n    } else if (code === 415) {\n      response += \"Accept: \".concat(JsSIP_C.ACCEPTED_BODY_TYPES, \"\\r\\n\");\n    }\n\n    response += \"Supported: \".concat(supported, \"\\r\\n\");\n\n    if (body) {\n      const length = Utils.str_utf8_length(body);\n      response += 'Content-Type: application/sdp\\r\\n';\n      response += \"Content-Length: \".concat(length, \"\\r\\n\\r\\n\");\n      response += body;\n    } else {\n      response += \"Content-Length: \".concat(0, \"\\r\\n\\r\\n\");\n    }\n\n    this.server_transaction.receiveResponse(code, response, onSuccess, onFailure);\n  }\n  /**\n  * Stateless reply.\n  * -param {Number} code status code\n  * -param {String} reason reason phrase\n  */\n\n\n  reply_sl(code = null, reason = null) {\n    const vias = this.getHeaders('via'); // Validate code and reason values.\n\n    if (!code || code < 100 || code > 699) {\n      throw new TypeError(\"Invalid status_code: \".concat(code));\n    } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n      throw new TypeError(\"Invalid reason_phrase: \".concat(reason));\n    }\n\n    reason = reason || JsSIP_C.REASON_PHRASE[code] || '';\n    let response = \"SIP/2.0 \".concat(code, \" \").concat(reason, \"\\r\\n\");\n\n    for (const via of vias) {\n      response += \"Via: \".concat(via, \"\\r\\n\");\n    }\n\n    let to = this.getHeader('To');\n\n    if (!this.to_tag && code > 100) {\n      to += \";tag=\".concat(Utils.newTag());\n    } else if (this.to_tag && !this.s('to').hasParam('tag')) {\n      to += \";tag=\".concat(this.to_tag);\n    }\n\n    response += \"To: \".concat(to, \"\\r\\n\");\n    response += \"From: \".concat(this.getHeader('From'), \"\\r\\n\");\n    response += \"Call-ID: \".concat(this.call_id, \"\\r\\n\");\n    response += \"CSeq: \".concat(this.cseq, \" \").concat(this.method, \"\\r\\n\");\n    response += \"Content-Length: \".concat(0, \"\\r\\n\\r\\n\");\n    this.transport.send(response);\n  }\n\n}\n\nclass IncomingResponse extends IncomingMessage {\n  constructor() {\n    super();\n    this.headers = {};\n    this.status_code = null;\n    this.reason_phrase = null;\n  }\n\n}\n\nmodule.exports = {\n  OutgoingRequest,\n  InitialOutgoingInviteRequest,\n  IncomingRequest,\n  IncomingResponse\n};","map":null,"metadata":{},"sourceType":"script"}