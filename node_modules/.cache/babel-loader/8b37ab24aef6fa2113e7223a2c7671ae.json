{"ast":null,"code":"const EventEmitter = require('events').EventEmitter;\n\nconst JsSIP_C = require('./Constants');\n\nconst SIPMessage = require('./SIPMessage');\n\nconst Timers = require('./Timers');\n\nconst debugnict = require('debug')('JsSIP:NonInviteClientTransaction');\n\nconst debugict = require('debug')('JsSIP:InviteClientTransaction');\n\nconst debugact = require('debug')('JsSIP:AckClientTransaction');\n\nconst debugnist = require('debug')('JsSIP:NonInviteServerTransaction');\n\nconst debugist = require('debug')('JsSIP:InviteServerTransaction');\n\nconst C = {\n  // Transaction states.\n  STATUS_TRYING: 1,\n  STATUS_PROCEEDING: 2,\n  STATUS_CALLING: 3,\n  STATUS_ACCEPTED: 4,\n  STATUS_COMPLETED: 5,\n  STATUS_TERMINATED: 6,\n  STATUS_CONFIRMED: 7,\n  // Transaction types.\n  NON_INVITE_CLIENT: 'nict',\n  NON_INVITE_SERVER: 'nist',\n  INVITE_CLIENT: 'ict',\n  INVITE_SERVER: 'ist'\n};\n\nclass NonInviteClientTransaction extends EventEmitter {\n  constructor(ua, transport, request, eventHandlers) {\n    super();\n    this.type = C.NON_INVITE_CLIENT;\n    this.id = \"z9hG4bK\".concat(Math.floor(Math.random() * 10000000));\n    this.ua = ua;\n    this.transport = transport;\n    this.request = request;\n    this.eventHandlers = eventHandlers;\n    let via = \"SIP/2.0/\".concat(transport.via_transport);\n    via += \" \".concat(ua.configuration.via_host, \";branch=\").concat(this.id);\n    this.request.setHeader('via', via);\n    this.ua.newTransaction(this);\n  }\n\n  get C() {\n    return C;\n  }\n\n  stateChanged(state) {\n    this.state = state;\n    this.emit('stateChanged');\n  }\n\n  send() {\n    this.stateChanged(C.STATUS_TRYING);\n    this.F = setTimeout(() => {\n      this.timer_F();\n    }, Timers.TIMER_F);\n\n    if (!this.transport.send(this.request)) {\n      this.onTransportError();\n    }\n  }\n\n  onTransportError() {\n    debugnict(\"transport error occurred, deleting transaction \".concat(this.id));\n    clearTimeout(this.F);\n    clearTimeout(this.K);\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n    this.eventHandlers.onTransportError();\n  }\n\n  timer_F() {\n    debugnict(\"Timer F expired for transaction \".concat(this.id));\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n    this.eventHandlers.onRequestTimeout();\n  }\n\n  timer_K() {\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  }\n\n  receiveResponse(response) {\n    const status_code = response.status_code;\n\n    if (status_code < 200) {\n      switch (this.state) {\n        case C.STATUS_TRYING:\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_PROCEEDING);\n          this.eventHandlers.onReceiveResponse(response);\n          break;\n      }\n    } else {\n      switch (this.state) {\n        case C.STATUS_TRYING:\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_COMPLETED);\n          clearTimeout(this.F);\n\n          if (status_code === 408) {\n            this.eventHandlers.onRequestTimeout();\n          } else {\n            this.eventHandlers.onReceiveResponse(response);\n          }\n\n          this.K = setTimeout(() => {\n            this.timer_K();\n          }, Timers.TIMER_K);\n          break;\n\n        case C.STATUS_COMPLETED:\n          break;\n      }\n    }\n  }\n\n}\n\nclass InviteClientTransaction extends EventEmitter {\n  constructor(ua, transport, request, eventHandlers) {\n    super();\n    this.type = C.INVITE_CLIENT;\n    this.id = \"z9hG4bK\".concat(Math.floor(Math.random() * 10000000));\n    this.ua = ua;\n    this.transport = transport;\n    this.request = request;\n    this.eventHandlers = eventHandlers;\n    request.transaction = this;\n    let via = \"SIP/2.0/\".concat(transport.via_transport);\n    via += \" \".concat(ua.configuration.via_host, \";branch=\").concat(this.id);\n    this.request.setHeader('via', via);\n    this.ua.newTransaction(this);\n  }\n\n  get C() {\n    return C;\n  }\n\n  stateChanged(state) {\n    this.state = state;\n    this.emit('stateChanged');\n  }\n\n  send() {\n    this.stateChanged(C.STATUS_CALLING);\n    this.B = setTimeout(() => {\n      this.timer_B();\n    }, Timers.TIMER_B);\n\n    if (!this.transport.send(this.request)) {\n      this.onTransportError();\n    }\n  }\n\n  onTransportError() {\n    clearTimeout(this.B);\n    clearTimeout(this.D);\n    clearTimeout(this.M);\n\n    if (this.state !== C.STATUS_ACCEPTED) {\n      debugict(\"transport error occurred, deleting transaction \".concat(this.id));\n      this.eventHandlers.onTransportError();\n    }\n\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  } // RFC 6026 7.2.\n\n\n  timer_M() {\n    debugict(\"Timer M expired for transaction \".concat(this.id));\n\n    if (this.state === C.STATUS_ACCEPTED) {\n      clearTimeout(this.B);\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  } // RFC 3261 17.1.1.\n\n\n  timer_B() {\n    debugict(\"Timer B expired for transaction \".concat(this.id));\n\n    if (this.state === C.STATUS_CALLING) {\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n      this.eventHandlers.onRequestTimeout();\n    }\n  }\n\n  timer_D() {\n    debugict(\"Timer D expired for transaction \".concat(this.id));\n    clearTimeout(this.B);\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  }\n\n  sendACK(response) {\n    const ack = new SIPMessage.OutgoingRequest(JsSIP_C.ACK, this.request.ruri, this.ua, {\n      'route_set': this.request.getHeaders('route'),\n      'call_id': this.request.getHeader('call-id'),\n      'cseq': this.request.cseq\n    });\n    ack.setHeader('from', this.request.getHeader('from'));\n    ack.setHeader('via', this.request.getHeader('via'));\n    ack.setHeader('to', response.getHeader('to'));\n    this.D = setTimeout(() => {\n      this.timer_D();\n    }, Timers.TIMER_D);\n    this.transport.send(ack);\n  }\n\n  cancel(reason) {\n    // Send only if a provisional response (>100) has been received.\n    if (this.state !== C.STATUS_PROCEEDING) {\n      return;\n    }\n\n    const cancel = new SIPMessage.OutgoingRequest(JsSIP_C.CANCEL, this.request.ruri, this.ua, {\n      'route_set': this.request.getHeaders('route'),\n      'call_id': this.request.getHeader('call-id'),\n      'cseq': this.request.cseq\n    });\n    cancel.setHeader('from', this.request.getHeader('from'));\n    cancel.setHeader('via', this.request.getHeader('via'));\n    cancel.setHeader('to', this.request.getHeader('to'));\n\n    if (reason) {\n      cancel.setHeader('reason', reason);\n    }\n\n    this.transport.send(cancel);\n  }\n\n  receiveResponse(response) {\n    const status_code = response.status_code;\n\n    if (status_code >= 100 && status_code <= 199) {\n      switch (this.state) {\n        case C.STATUS_CALLING:\n          this.stateChanged(C.STATUS_PROCEEDING);\n          this.eventHandlers.onReceiveResponse(response);\n          break;\n\n        case C.STATUS_PROCEEDING:\n          this.eventHandlers.onReceiveResponse(response);\n          break;\n      }\n    } else if (status_code >= 200 && status_code <= 299) {\n      switch (this.state) {\n        case C.STATUS_CALLING:\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_ACCEPTED);\n          this.M = setTimeout(() => {\n            this.timer_M();\n          }, Timers.TIMER_M);\n          this.eventHandlers.onReceiveResponse(response);\n          break;\n\n        case C.STATUS_ACCEPTED:\n          this.eventHandlers.onReceiveResponse(response);\n          break;\n      }\n    } else if (status_code >= 300 && status_code <= 699) {\n      switch (this.state) {\n        case C.STATUS_CALLING:\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_COMPLETED);\n          this.sendACK(response);\n          this.eventHandlers.onReceiveResponse(response);\n          break;\n\n        case C.STATUS_COMPLETED:\n          this.sendACK(response);\n          break;\n      }\n    }\n  }\n\n}\n\nclass AckClientTransaction extends EventEmitter {\n  constructor(ua, transport, request, eventHandlers) {\n    super();\n    this.id = \"z9hG4bK\".concat(Math.floor(Math.random() * 10000000));\n    this.transport = transport;\n    this.request = request;\n    this.eventHandlers = eventHandlers;\n    let via = \"SIP/2.0/\".concat(transport.via_transport);\n    via += \" \".concat(ua.configuration.via_host, \";branch=\").concat(this.id);\n    this.request.setHeader('via', via);\n  }\n\n  get C() {\n    return C;\n  }\n\n  send() {\n    if (!this.transport.send(this.request)) {\n      this.onTransportError();\n    }\n  }\n\n  onTransportError() {\n    debugact(\"transport error occurred for transaction \".concat(this.id));\n    this.eventHandlers.onTransportError();\n  }\n\n}\n\nclass NonInviteServerTransaction extends EventEmitter {\n  constructor(ua, transport, request) {\n    super();\n    this.type = C.NON_INVITE_SERVER;\n    this.id = request.via_branch;\n    this.ua = ua;\n    this.transport = transport;\n    this.request = request;\n    this.last_response = '';\n    request.server_transaction = this;\n    this.state = C.STATUS_TRYING;\n    ua.newTransaction(this);\n  }\n\n  get C() {\n    return C;\n  }\n\n  stateChanged(state) {\n    this.state = state;\n    this.emit('stateChanged');\n  }\n\n  timer_J() {\n    debugnist(\"Timer J expired for transaction \".concat(this.id));\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  }\n\n  onTransportError() {\n    if (!this.transportError) {\n      this.transportError = true;\n      debugnist(\"transport error occurred, deleting transaction \".concat(this.id));\n      clearTimeout(this.J);\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  }\n\n  receiveResponse(status_code, response, onSuccess, onFailure) {\n    if (status_code === 100) {\n      /* RFC 4320 4.1\n       * 'A SIP element MUST NOT\n       * send any provisional response with a\n       * Status-Code other than 100 to a non-INVITE request.'\n       */\n      switch (this.state) {\n        case C.STATUS_TRYING:\n          this.stateChanged(C.STATUS_PROCEEDING);\n\n          if (!this.transport.send(response)) {\n            this.onTransportError();\n          }\n\n          break;\n\n        case C.STATUS_PROCEEDING:\n          this.last_response = response;\n\n          if (!this.transport.send(response)) {\n            this.onTransportError();\n\n            if (onFailure) {\n              onFailure();\n            }\n          } else if (onSuccess) {\n            onSuccess();\n          }\n\n          break;\n      }\n    } else if (status_code >= 200 && status_code <= 699) {\n      switch (this.state) {\n        case C.STATUS_TRYING:\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_COMPLETED);\n          this.last_response = response;\n          this.J = setTimeout(() => {\n            this.timer_J();\n          }, Timers.TIMER_J);\n\n          if (!this.transport.send(response)) {\n            this.onTransportError();\n\n            if (onFailure) {\n              onFailure();\n            }\n          } else if (onSuccess) {\n            onSuccess();\n          }\n\n          break;\n\n        case C.STATUS_COMPLETED:\n          break;\n      }\n    }\n  }\n\n}\n\nclass InviteServerTransaction extends EventEmitter {\n  constructor(ua, transport, request) {\n    super();\n    this.type = C.INVITE_SERVER;\n    this.id = request.via_branch;\n    this.ua = ua;\n    this.transport = transport;\n    this.request = request;\n    this.last_response = '';\n    request.server_transaction = this;\n    this.state = C.STATUS_PROCEEDING;\n    ua.newTransaction(this);\n    this.resendProvisionalTimer = null;\n    request.reply(100);\n  }\n\n  get C() {\n    return C;\n  }\n\n  stateChanged(state) {\n    this.state = state;\n    this.emit('stateChanged');\n  }\n\n  timer_H() {\n    debugist(\"Timer H expired for transaction \".concat(this.id));\n\n    if (this.state === C.STATUS_COMPLETED) {\n      debugist('ACK not received, dialog will be terminated');\n    }\n\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  }\n\n  timer_I() {\n    this.stateChanged(C.STATUS_TERMINATED);\n  } // RFC 6026 7.1.\n\n\n  timer_L() {\n    debugist(\"Timer L expired for transaction \".concat(this.id));\n\n    if (this.state === C.STATUS_ACCEPTED) {\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  }\n\n  onTransportError() {\n    if (!this.transportError) {\n      this.transportError = true;\n      debugist(\"transport error occurred, deleting transaction \".concat(this.id));\n\n      if (this.resendProvisionalTimer !== null) {\n        clearInterval(this.resendProvisionalTimer);\n        this.resendProvisionalTimer = null;\n      }\n\n      clearTimeout(this.L);\n      clearTimeout(this.H);\n      clearTimeout(this.I);\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  }\n\n  resend_provisional() {\n    if (!this.transport.send(this.last_response)) {\n      this.onTransportError();\n    }\n  } // INVITE Server Transaction RFC 3261 17.2.1.\n\n\n  receiveResponse(status_code, response, onSuccess, onFailure) {\n    if (status_code >= 100 && status_code <= 199) {\n      switch (this.state) {\n        case C.STATUS_PROCEEDING:\n          if (!this.transport.send(response)) {\n            this.onTransportError();\n          }\n\n          this.last_response = response;\n          break;\n      }\n    }\n\n    if (status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {\n      // Trigger the resendProvisionalTimer only for the first non 100 provisional response.\n      if (this.resendProvisionalTimer === null) {\n        this.resendProvisionalTimer = setInterval(() => {\n          this.resend_provisional();\n        }, Timers.PROVISIONAL_RESPONSE_INTERVAL);\n      }\n    } else if (status_code >= 200 && status_code <= 299) {\n      switch (this.state) {\n        case C.STATUS_PROCEEDING:\n          this.stateChanged(C.STATUS_ACCEPTED);\n          this.last_response = response;\n          this.L = setTimeout(() => {\n            this.timer_L();\n          }, Timers.TIMER_L);\n\n          if (this.resendProvisionalTimer !== null) {\n            clearInterval(this.resendProvisionalTimer);\n            this.resendProvisionalTimer = null;\n          }\n\n        /* falls through */\n\n        case C.STATUS_ACCEPTED:\n          // Note that this point will be reached for proceeding this.state also.\n          if (!this.transport.send(response)) {\n            this.onTransportError();\n\n            if (onFailure) {\n              onFailure();\n            }\n          } else if (onSuccess) {\n            onSuccess();\n          }\n\n          break;\n      }\n    } else if (status_code >= 300 && status_code <= 699) {\n      switch (this.state) {\n        case C.STATUS_PROCEEDING:\n          if (this.resendProvisionalTimer !== null) {\n            clearInterval(this.resendProvisionalTimer);\n            this.resendProvisionalTimer = null;\n          }\n\n          if (!this.transport.send(response)) {\n            this.onTransportError();\n\n            if (onFailure) {\n              onFailure();\n            }\n          } else {\n            this.stateChanged(C.STATUS_COMPLETED);\n            this.H = setTimeout(() => {\n              this.timer_H();\n            }, Timers.TIMER_H);\n\n            if (onSuccess) {\n              onSuccess();\n            }\n          }\n\n          break;\n      }\n    }\n  }\n\n}\n/**\n * INVITE:\n *  _true_ if retransmission\n *  _false_ new request\n *\n * ACK:\n *  _true_  ACK to non2xx response\n *  _false_ ACK must be passed to TU (accepted state)\n *          ACK to 2xx response\n *\n * CANCEL:\n *  _true_  no matching invite transaction\n *  _false_ matching invite transaction and no final response sent\n *\n * OTHER:\n *  _true_  retransmission\n *  _false_ new request\n */\n\n\nfunction checkTransaction({\n  _transactions\n}, request) {\n  let tr;\n\n  switch (request.method) {\n    case JsSIP_C.INVITE:\n      tr = _transactions.ist[request.via_branch];\n\n      if (tr) {\n        switch (tr.state) {\n          case C.STATUS_PROCEEDING:\n            tr.transport.send(tr.last_response);\n            break;\n          // RFC 6026 7.1 Invite retransmission.\n          // Received while in C.STATUS_ACCEPTED state. Absorb it.\n\n          case C.STATUS_ACCEPTED:\n            break;\n        }\n\n        return true;\n      }\n\n      break;\n\n    case JsSIP_C.ACK:\n      tr = _transactions.ist[request.via_branch]; // RFC 6026 7.1.\n\n      if (tr) {\n        if (tr.state === C.STATUS_ACCEPTED) {\n          return false;\n        } else if (tr.state === C.STATUS_COMPLETED) {\n          tr.state = C.STATUS_CONFIRMED;\n          tr.I = setTimeout(() => {\n            tr.timer_I();\n          }, Timers.TIMER_I);\n          return true;\n        }\n      } // ACK to 2XX Response.\n      else {\n          return false;\n        }\n\n      break;\n\n    case JsSIP_C.CANCEL:\n      tr = _transactions.ist[request.via_branch];\n\n      if (tr) {\n        request.reply_sl(200);\n\n        if (tr.state === C.STATUS_PROCEEDING) {\n          return false;\n        } else {\n          return true;\n        }\n      } else {\n        request.reply_sl(481);\n        return true;\n      }\n\n    default:\n      // Non-INVITE Server Transaction RFC 3261 17.2.2.\n      tr = _transactions.nist[request.via_branch];\n\n      if (tr) {\n        switch (tr.state) {\n          case C.STATUS_TRYING:\n            break;\n\n          case C.STATUS_PROCEEDING:\n          case C.STATUS_COMPLETED:\n            tr.transport.send(tr.last_response);\n            break;\n        }\n\n        return true;\n      }\n\n      break;\n  }\n}\n\nmodule.exports = {\n  C,\n  NonInviteClientTransaction,\n  InviteClientTransaction,\n  AckClientTransaction,\n  NonInviteServerTransaction,\n  InviteServerTransaction,\n  checkTransaction\n};","map":null,"metadata":{},"sourceType":"script"}