{"ast":null,"code":"const Grammar = require('./Grammar');\n\nconst debug = require('debug')('JsSIP:WebSocketInterface');\n\nconst debugerror = require('debug')('JsSIP:ERROR:WebSocketInterface');\n\ndebugerror.log = console.warn.bind(console);\nmodule.exports = class WebSocketInterface {\n  constructor(url) {\n    debug('new() [url:\"%s\"]', url);\n    this._url = url;\n    this._sip_uri = null;\n    this._via_transport = null;\n    this._ws = null;\n    const parsed_url = Grammar.parse(url, 'absoluteURI');\n\n    if (parsed_url === -1) {\n      debugerror(\"invalid WebSocket URI: \".concat(url));\n      throw new TypeError(\"Invalid argument: \".concat(url));\n    } else if (parsed_url.scheme !== 'wss' && parsed_url.scheme !== 'ws') {\n      debugerror(\"invalid WebSocket URI scheme: \".concat(parsed_url.scheme));\n      throw new TypeError(\"Invalid argument: \".concat(url));\n    } else {\n      this._sip_uri = \"sip:\".concat(parsed_url.host).concat(parsed_url.port ? \":\".concat(parsed_url.port) : '', \";transport=ws\");\n      this._via_transport = parsed_url.scheme.toUpperCase();\n    }\n  }\n\n  get via_transport() {\n    return this._via_transport;\n  }\n\n  set via_transport(value) {\n    this._via_transport = value.toUpperCase();\n  }\n\n  get sip_uri() {\n    return this._sip_uri;\n  }\n\n  get url() {\n    return this._url;\n  }\n\n  connect() {\n    debug('connect()');\n\n    if (this.isConnected()) {\n      debug(\"WebSocket \".concat(this._url, \" is already connected\"));\n      return;\n    } else if (this.isConnecting()) {\n      debug(\"WebSocket \".concat(this._url, \" is connecting\"));\n      return;\n    }\n\n    if (this._ws) {\n      this.disconnect();\n    }\n\n    debug(\"connecting to WebSocket \".concat(this._url));\n\n    try {\n      this._ws = new WebSocket(this._url, 'sip');\n      this._ws.binaryType = 'arraybuffer';\n      this._ws.onopen = this._onOpen.bind(this);\n      this._ws.onclose = this._onClose.bind(this);\n      this._ws.onmessage = this._onMessage.bind(this);\n      this._ws.onerror = this._onError.bind(this);\n    } catch (e) {\n      this._onError(e);\n    }\n  }\n\n  disconnect() {\n    debug('disconnect()');\n\n    if (this._ws) {\n      // Unbind websocket event callbacks.\n      this._ws.onopen = () => {};\n\n      this._ws.onclose = () => {};\n\n      this._ws.onmessage = () => {};\n\n      this._ws.onerror = () => {};\n\n      this._ws.close();\n\n      this._ws = null;\n    }\n  }\n\n  send(message) {\n    debug('send()');\n\n    if (this.isConnected()) {\n      this._ws.send(message);\n\n      return true;\n    } else {\n      debugerror('unable to send message, WebSocket is not open');\n      return false;\n    }\n  }\n\n  isConnected() {\n    return this._ws && this._ws.readyState === this._ws.OPEN;\n  }\n\n  isConnecting() {\n    return this._ws && this._ws.readyState === this._ws.CONNECTING;\n  }\n  /**\n   * WebSocket Event Handlers\n   */\n\n\n  _onOpen() {\n    debug(\"WebSocket \".concat(this._url, \" connected\"));\n    this.onconnect();\n  }\n\n  _onClose({\n    wasClean,\n    code,\n    reason\n  }) {\n    debug(\"WebSocket \".concat(this._url, \" closed\"));\n\n    if (wasClean === false) {\n      debug('WebSocket abrupt disconnection');\n    }\n\n    const data = {\n      socket: this,\n      error: !wasClean,\n      code,\n      reason\n    };\n    this.ondisconnect(data);\n  }\n\n  _onMessage({\n    data\n  }) {\n    debug('received WebSocket message');\n    this.ondata(data);\n  }\n\n  _onError(e) {\n    debugerror(\"WebSocket \".concat(this._url, \" error: \").concat(e));\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}