{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if (typeof exports === 'object') exports[\"strophe\"] = factory();else root[\"strophe\"] = factory();\n})(window, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // define __esModule on exports\n\n      /******/\n\n\n      __webpack_require__.r = function (exports) {\n        /******/\n        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/\n          Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n\n\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n\n      /******/\n      // create a fake namespace object\n\n      /******/\n      // mode & 1: value is a module id, require it\n\n      /******/\n      // mode & 2: merge all properties of value into the ns\n\n      /******/\n      // mode & 4: return value when already ns object\n\n      /******/\n      // mode & 8|1: behave like require\n\n      /******/\n\n\n      __webpack_require__.t = function (value, mode) {\n        /******/\n        if (mode & 1) value = __webpack_require__(value);\n        /******/\n\n        if (mode & 8) return value;\n        /******/\n\n        if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n        /******/\n\n        var ns = Object.create(null);\n        /******/\n\n        __webpack_require__.r(ns);\n        /******/\n\n\n        Object.defineProperty(ns, 'default', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n\n        if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {\n          return value[key];\n        }.bind(null, key));\n        /******/\n\n        return ns;\n        /******/\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = \"./src/strophe.js\");\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    {\n      /***/\n      \"./node_modules/webpack/buildin/global.js\":\n      /*!***********************************!*\\\n        !*** (webpack)/buildin/global.js ***!\n        \\***********************************/\n\n      /*! no static exports found */\n\n      /***/\n      function (module, exports) {\n        var g; // This works in non-strict mode\n\n        g = function () {\n          return this;\n        }();\n\n        try {\n          // This works if eval is allowed (see CSP)\n          g = g || Function(\"return this\")() || (1, eval)(\"this\");\n        } catch (e) {\n          // This works if the window reference is available\n          if (typeof window === \"object\") g = window;\n        } // g can still be undefined, but nothing to do about it...\n        // We return undefined, instead of nothing here, so it's\n        // easier to handle this case. if(!global) { ...}\n\n\n        module.exports = g;\n        /***/\n      },\n\n      /***/\n      \"./src/bosh.js\":\n      /*!*********************!*\\\n        !*** ./src/bosh.js ***!\n        \\*********************/\n\n      /*! no exports provided */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        \"use strict\";\n\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony import */\n\n\n        var core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n        /*! core */\n        \"./src/core.js\");\n        /*\n            This program is distributed under the terms of the MIT license.\n            Please see the LICENSE file for details.\n        \n            Copyright 2006-2008, OGG, LLC\n        */\n\n        /* global window, setTimeout, clearTimeout, XMLHttpRequest, ActiveXObject */\n\n\n        var Strophe = core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Strophe;\n        var $build = core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].$build;\n        /** PrivateClass: Strophe.Request\n         *  _Private_ helper class that provides a cross implementation abstraction\n         *  for a BOSH related XMLHttpRequest.\n         *\n         *  The Strophe.Request class is used internally to encapsulate BOSH request\n         *  information.  It is not meant to be used from user's code.\n         */\n\n        /** PrivateConstructor: Strophe.Request\n         *  Create and initialize a new Strophe.Request object.\n         *\n         *  Parameters:\n         *    (XMLElement) elem - The XML data to be sent in the request.\n         *    (Function) func - The function that will be called when the\n         *      XMLHttpRequest readyState changes.\n         *    (Integer) rid - The BOSH rid attribute associated with this request.\n         *    (Integer) sends - The number of times this same request has been sent.\n         */\n\n        Strophe.Request = function (elem, func, rid, sends) {\n          this.id = ++Strophe._requestId;\n          this.xmlData = elem;\n          this.data = Strophe.serialize(elem); // save original function in case we need to make a new request\n          // from this one.\n\n          this.origFunc = func;\n          this.func = func;\n          this.rid = rid;\n          this.date = NaN;\n          this.sends = sends || 0;\n          this.abort = false;\n          this.dead = null;\n\n          this.age = function () {\n            if (!this.date) {\n              return 0;\n            }\n\n            var now = new Date();\n            return (now - this.date) / 1000;\n          };\n\n          this.timeDead = function () {\n            if (!this.dead) {\n              return 0;\n            }\n\n            var now = new Date();\n            return (now - this.dead) / 1000;\n          };\n\n          this.xhr = this._newXHR();\n        };\n\n        Strophe.Request.prototype = {\n          /** PrivateFunction: getResponse\n           *  Get a response from the underlying XMLHttpRequest.\n           *\n           *  This function attempts to get a response from the request and checks\n           *  for errors.\n           *\n           *  Throws:\n           *    \"parsererror\" - A parser error occured.\n           *    \"bad-format\" - The entity has sent XML that cannot be processed.\n           *\n           *  Returns:\n           *    The DOM element tree of the response.\n           */\n          getResponse: function getResponse() {\n            var node = null;\n\n            if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {\n              node = this.xhr.responseXML.documentElement;\n\n              if (node.tagName === \"parsererror\") {\n                Strophe.error(\"invalid response received\");\n                Strophe.error(\"responseText: \" + this.xhr.responseText);\n                Strophe.error(\"responseXML: \" + Strophe.serialize(this.xhr.responseXML));\n                throw new Error(\"parsererror\");\n              }\n            } else if (this.xhr.responseText) {\n              // In React Native, we may get responseText but no responseXML.  We can try to parse it manually.\n              Strophe.debug(\"Got responseText but no responseXML; attempting to parse it with DOMParser...\");\n              node = new DOMParser().parseFromString(this.xhr.responseText, 'application/xml').documentElement;\n\n              if (!node) {\n                throw new Error('Parsing produced null node');\n              } else if (node.querySelector('parsererror')) {\n                Strophe.error(\"invalid response received: \" + node.querySelector('parsererror').textContent);\n                Strophe.error(\"responseText: \" + this.xhr.responseText);\n                var error = new Error();\n                error.name = Strophe.ErrorCondition.BAD_FORMAT;\n                throw error;\n              }\n            }\n\n            return node;\n          },\n\n          /** PrivateFunction: _newXHR\n           *  _Private_ helper function to create XMLHttpRequests.\n           *\n           *  This function creates XMLHttpRequests across all implementations.\n           *\n           *  Returns:\n           *    A new XMLHttpRequest.\n           */\n          _newXHR: function _newXHR() {\n            var xhr = null;\n\n            if (window.XMLHttpRequest) {\n              xhr = new XMLHttpRequest();\n\n              if (xhr.overrideMimeType) {\n                xhr.overrideMimeType(\"text/xml; charset=utf-8\");\n              }\n            } else if (window.ActiveXObject) {\n              xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n            } // use Function.bind() to prepend ourselves as an argument\n\n\n            xhr.onreadystatechange = this.func.bind(null, this);\n            return xhr;\n          }\n        };\n        /** Class: Strophe.Bosh\n         *  _Private_ helper class that handles BOSH Connections\n         *\n         *  The Strophe.Bosh class is used internally by Strophe.Connection\n         *  to encapsulate BOSH sessions. It is not meant to be used from user's code.\n         */\n\n        /** File: bosh.js\n         *  A JavaScript library to enable BOSH in Strophejs.\n         *\n         *  this library uses Bidirectional-streams Over Synchronous HTTP (BOSH)\n         *  to emulate a persistent, stateful, two-way connection to an XMPP server.\n         *  More information on BOSH can be found in XEP 124.\n         */\n\n        /** PrivateConstructor: Strophe.Bosh\n         *  Create and initialize a Strophe.Bosh object.\n         *\n         *  Parameters:\n         *    (Strophe.Connection) connection - The Strophe.Connection that will use BOSH.\n         *\n         *  Returns:\n         *    A new Strophe.Bosh object.\n         */\n\n        Strophe.Bosh = function (connection) {\n          this._conn = connection;\n          /* request id for body tags */\n\n          this.rid = Math.floor(Math.random() * 4294967295);\n          /* The current session ID. */\n\n          this.sid = null; // default BOSH values\n\n          this.hold = 1;\n          this.wait = 60;\n          this.window = 5;\n          this.errors = 0;\n          this.inactivity = null;\n          this.lastResponseHeaders = null;\n          this._requests = [];\n        };\n\n        Strophe.Bosh.prototype = {\n          /** Variable: strip\n           *\n           *  BOSH-Connections will have all stanzas wrapped in a <body> tag when\n           *  passed to <Strophe.Connection.xmlInput> or <Strophe.Connection.xmlOutput>.\n           *  To strip this tag, User code can set <Strophe.Bosh.strip> to \"body\":\n           *\n           *  > Strophe.Bosh.prototype.strip = \"body\";\n           *\n           *  This will enable stripping of the body tag in both\n           *  <Strophe.Connection.xmlInput> and <Strophe.Connection.xmlOutput>.\n           */\n          strip: null,\n\n          /** PrivateFunction: _buildBody\n           *  _Private_ helper function to generate the <body/> wrapper for BOSH.\n           *\n           *  Returns:\n           *    A Strophe.Builder with a <body/> element.\n           */\n          _buildBody: function _buildBody() {\n            var bodyWrap = $build('body', {\n              'rid': this.rid++,\n              'xmlns': Strophe.NS.HTTPBIND\n            });\n\n            if (this.sid !== null) {\n              bodyWrap.attrs({\n                'sid': this.sid\n              });\n            }\n\n            if (this._conn.options.keepalive && this._conn._sessionCachingSupported()) {\n              this._cacheSession();\n            }\n\n            return bodyWrap;\n          },\n\n          /** PrivateFunction: _reset\n           *  Reset the connection.\n           *\n           *  This function is called by the reset function of the Strophe Connection\n           */\n          _reset: function _reset() {\n            this.rid = Math.floor(Math.random() * 4294967295);\n            this.sid = null;\n            this.errors = 0;\n\n            if (this._conn._sessionCachingSupported()) {\n              window.sessionStorage.removeItem('strophe-bosh-session');\n            }\n\n            this._conn.nextValidRid(this.rid);\n          },\n\n          /** PrivateFunction: _connect\n           *  _Private_ function that initializes the BOSH connection.\n           *\n           *  Creates and sends the Request that initializes the BOSH connection.\n           */\n          _connect: function _connect(wait, hold, route) {\n            this.wait = wait || this.wait;\n            this.hold = hold || this.hold;\n            this.errors = 0;\n\n            var body = this._buildBody().attrs({\n              \"to\": this._conn.domain,\n              \"xml:lang\": \"en\",\n              \"wait\": this.wait,\n              \"hold\": this.hold,\n              \"content\": \"text/xml; charset=utf-8\",\n              \"ver\": \"1.6\",\n              \"xmpp:version\": \"1.0\",\n              \"xmlns:xmpp\": Strophe.NS.BOSH\n            });\n\n            if (route) {\n              body.attrs({\n                'route': route\n              });\n            }\n\n            var _connect_cb = this._conn._connect_cb;\n\n            this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, _connect_cb.bind(this._conn)), body.tree().getAttribute(\"rid\")));\n\n            this._throttledRequestHandler();\n          },\n\n          /** PrivateFunction: _attach\n           *  Attach to an already created and authenticated BOSH session.\n           *\n           *  This function is provided to allow Strophe to attach to BOSH\n           *  sessions which have been created externally, perhaps by a Web\n           *  application.  This is often used to support auto-login type features\n           *  without putting user credentials into the page.\n           *\n           *  Parameters:\n           *    (String) jid - The full JID that is bound by the session.\n           *    (String) sid - The SID of the BOSH session.\n           *    (String) rid - The current RID of the BOSH session.  This RID\n           *      will be used by the next request.\n           *    (Function) callback The connect callback function.\n           *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n           *      time the server will wait before returning an empty result for\n           *      a request.  The default setting of 60 seconds is recommended.\n           *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n           *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n           *      number of connections the server will hold at one time.  This\n           *      should almost always be set to 1 (the default).\n           *    (Integer) wind - The optional HTTBIND window value.  This is the\n           *      allowed range of request ids that are valid.  The default is 5.\n           */\n          _attach: function _attach(jid, sid, rid, callback, wait, hold, wind) {\n            this._conn.jid = jid;\n            this.sid = sid;\n            this.rid = rid;\n            this._conn.connect_callback = callback;\n            this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);\n            this._conn.authenticated = true;\n            this._conn.connected = true;\n            this.wait = wait || this.wait;\n            this.hold = hold || this.hold;\n            this.window = wind || this.window;\n\n            this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null);\n          },\n\n          /** PrivateFunction: _restore\n           *  Attempt to restore a cached BOSH session\n           *\n           *  Parameters:\n           *    (String) jid - The full JID that is bound by the session.\n           *      This parameter is optional but recommended, specifically in cases\n           *      where prebinded BOSH sessions are used where it's important to know\n           *      that the right session is being restored.\n           *    (Function) callback The connect callback function.\n           *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n           *      time the server will wait before returning an empty result for\n           *      a request.  The default setting of 60 seconds is recommended.\n           *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n           *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n           *      number of connections the server will hold at one time.  This\n           *      should almost always be set to 1 (the default).\n           *    (Integer) wind - The optional HTTBIND window value.  This is the\n           *      allowed range of request ids that are valid.  The default is 5.\n           */\n          _restore: function _restore(jid, callback, wait, hold, wind) {\n            var session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));\n\n            if (typeof session !== \"undefined\" && session !== null && session.rid && session.sid && session.jid && (typeof jid === \"undefined\" || jid === null || Strophe.getBareJidFromJid(session.jid) === Strophe.getBareJidFromJid(jid) || // If authcid is null, then it's an anonymous login, so\n            // we compare only the domains:\n            Strophe.getNodeFromJid(jid) === null && Strophe.getDomainFromJid(session.jid) === jid)) {\n              this._conn.restored = true;\n\n              this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);\n            } else {\n              var error = new Error(\"_restore: no restoreable session.\");\n              error.name = \"StropheSessionError\";\n              throw error;\n            }\n          },\n\n          /** PrivateFunction: _cacheSession\n           *  _Private_ handler for the beforeunload event.\n           *\n           *  This handler is used to process the Bosh-part of the initial request.\n           *  Parameters:\n           *    (Strophe.Request) bodyWrap - The received stanza.\n           */\n          _cacheSession: function _cacheSession() {\n            if (this._conn.authenticated) {\n              if (this._conn.jid && this.rid && this.sid) {\n                window.sessionStorage.setItem('strophe-bosh-session', JSON.stringify({\n                  'jid': this._conn.jid,\n                  'rid': this.rid,\n                  'sid': this.sid\n                }));\n              }\n            } else {\n              window.sessionStorage.removeItem('strophe-bosh-session');\n            }\n          },\n\n          /** PrivateFunction: _connect_cb\n           *  _Private_ handler for initial connection request.\n           *\n           *  This handler is used to process the Bosh-part of the initial request.\n           *  Parameters:\n           *    (Strophe.Request) bodyWrap - The received stanza.\n           */\n          _connect_cb: function _connect_cb(bodyWrap) {\n            var typ = bodyWrap.getAttribute(\"type\");\n\n            if (typ !== null && typ === \"terminate\") {\n              // an error occurred\n              var cond = bodyWrap.getAttribute(\"condition\");\n              Strophe.error(\"BOSH-Connection failed: \" + cond);\n              var conflict = bodyWrap.getElementsByTagName(\"conflict\");\n\n              if (cond !== null) {\n                if (cond === \"remote-stream-error\" && conflict.length > 0) {\n                  cond = \"conflict\";\n                }\n\n                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond);\n              } else {\n                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"unknown\");\n              }\n\n              this._conn._doDisconnect(cond);\n\n              return Strophe.Status.CONNFAIL;\n            } // check to make sure we don't overwrite these if _connect_cb is\n            // called multiple times in the case of missing stream:features\n\n\n            if (!this.sid) {\n              this.sid = bodyWrap.getAttribute(\"sid\");\n            }\n\n            var wind = bodyWrap.getAttribute('requests');\n\n            if (wind) {\n              this.window = parseInt(wind, 10);\n            }\n\n            var hold = bodyWrap.getAttribute('hold');\n\n            if (hold) {\n              this.hold = parseInt(hold, 10);\n            }\n\n            var wait = bodyWrap.getAttribute('wait');\n\n            if (wait) {\n              this.wait = parseInt(wait, 10);\n            }\n\n            var inactivity = bodyWrap.getAttribute('inactivity');\n\n            if (inactivity) {\n              this.inactivity = parseInt(inactivity, 10);\n            }\n          },\n\n          /** PrivateFunction: _disconnect\n           *  _Private_ part of Connection.disconnect for Bosh\n           *\n           *  Parameters:\n           *    (Request) pres - This stanza will be sent before disconnecting.\n           */\n          _disconnect: function _disconnect(pres) {\n            this._sendTerminate(pres);\n          },\n\n          /** PrivateFunction: _doDisconnect\n           *  _Private_ function to disconnect.\n           *\n           *  Resets the SID and RID.\n           */\n          _doDisconnect: function _doDisconnect() {\n            this.sid = null;\n            this.rid = Math.floor(Math.random() * 4294967295);\n\n            if (this._conn._sessionCachingSupported()) {\n              window.sessionStorage.removeItem('strophe-bosh-session');\n            }\n\n            this._conn.nextValidRid(this.rid);\n          },\n\n          /** PrivateFunction: _emptyQueue\n           * _Private_ function to check if the Request queue is empty.\n           *\n           *  Returns:\n           *    True, if there are no Requests queued, False otherwise.\n           */\n          _emptyQueue: function _emptyQueue() {\n            return this._requests.length === 0;\n          },\n\n          /** PrivateFunction: _callProtocolErrorHandlers\n           *  _Private_ function to call error handlers registered for HTTP errors.\n           *\n           *  Parameters:\n           *    (Strophe.Request) req - The request that is changing readyState.\n           */\n          _callProtocolErrorHandlers: function _callProtocolErrorHandlers(req) {\n            var reqStatus = this._getRequestStatus(req);\n\n            var err_callback = this._conn.protocolErrorHandlers.HTTP[reqStatus];\n\n            if (err_callback) {\n              err_callback.call(this, reqStatus);\n            }\n          },\n\n          /** PrivateFunction: _hitError\n           *  _Private_ function to handle the error count.\n           *\n           *  Requests are resent automatically until their error count reaches\n           *  5.  Each time an error is encountered, this function is called to\n           *  increment the count and disconnect if the count is too high.\n           *\n           *  Parameters:\n           *    (Integer) reqStatus - The request status.\n           */\n          _hitError: function _hitError(reqStatus) {\n            this.errors++;\n            Strophe.warn(\"request errored, status: \" + reqStatus + \", number of errors: \" + this.errors);\n\n            if (this.errors > 4) {\n              this._conn._onDisconnectTimeout();\n            }\n          },\n\n          /** PrivateFunction: _no_auth_received\n           *\n           * Called on stream start/restart when no stream:features\n           * has been received and sends a blank poll request.\n           */\n          _no_auth_received: function _no_auth_received(callback) {\n            Strophe.warn(\"Server did not yet offer a supported authentication \" + \"mechanism. Sending a blank poll request.\");\n\n            if (callback) {\n              callback = callback.bind(this._conn);\n            } else {\n              callback = this._conn._connect_cb.bind(this._conn);\n            }\n\n            var body = this._buildBody();\n\n            this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, callback), body.tree().getAttribute(\"rid\")));\n\n            this._throttledRequestHandler();\n          },\n\n          /** PrivateFunction: _onDisconnectTimeout\n           *  _Private_ timeout handler for handling non-graceful disconnection.\n           *\n           *  Cancels all remaining Requests and clears the queue.\n           */\n          _onDisconnectTimeout: function _onDisconnectTimeout() {\n            this._abortAllRequests();\n          },\n\n          /** PrivateFunction: _abortAllRequests\n           *  _Private_ helper function that makes sure all pending requests are aborted.\n           */\n          _abortAllRequests: function _abortAllRequests() {\n            while (this._requests.length > 0) {\n              var req = this._requests.pop();\n\n              req.abort = true;\n              req.xhr.abort(); // jslint complains, but this is fine. setting to empty func\n              // is necessary for IE6\n\n              req.xhr.onreadystatechange = function () {}; // jshint ignore:line\n\n            }\n          },\n\n          /** PrivateFunction: _onIdle\n           *  _Private_ handler called by Strophe.Connection._onIdle\n           *\n           *  Sends all queued Requests or polls with empty Request if there are none.\n           */\n          _onIdle: function _onIdle() {\n            var data = this._conn._data; // if no requests are in progress, poll\n\n            if (this._conn.authenticated && this._requests.length === 0 && data.length === 0 && !this._conn.disconnecting) {\n              Strophe.debug(\"no requests during idle cycle, sending blank request\");\n              data.push(null);\n            }\n\n            if (this._conn.paused) {\n              return;\n            }\n\n            if (this._requests.length < 2 && data.length > 0) {\n              var body = this._buildBody();\n\n              for (var i = 0; i < data.length; i++) {\n                if (data[i] !== null) {\n                  if (data[i] === \"restart\") {\n                    body.attrs({\n                      \"to\": this._conn.domain,\n                      \"xml:lang\": \"en\",\n                      \"xmpp:restart\": \"true\",\n                      \"xmlns:xmpp\": Strophe.NS.BOSH\n                    });\n                  } else {\n                    body.cnode(data[i]).up();\n                  }\n                }\n              }\n\n              delete this._conn._data;\n              this._conn._data = [];\n\n              this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), body.tree().getAttribute(\"rid\")));\n\n              this._throttledRequestHandler();\n            }\n\n            if (this._requests.length > 0) {\n              var time_elapsed = this._requests[0].age();\n\n              if (this._requests[0].dead !== null) {\n                if (this._requests[0].timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {\n                  this._throttledRequestHandler();\n                }\n              }\n\n              if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {\n                Strophe.warn(\"Request \" + this._requests[0].id + \" timed out, over \" + Math.floor(Strophe.TIMEOUT * this.wait) + \" seconds since last activity\");\n\n                this._throttledRequestHandler();\n              }\n            }\n          },\n\n          /** PrivateFunction: _getRequestStatus\n           *\n           *  Returns the HTTP status code from a Strophe.Request\n           *\n           *  Parameters:\n           *    (Strophe.Request) req - The Strophe.Request instance.\n           *    (Integer) def - The default value that should be returned if no\n           *          status value was found.\n           */\n          _getRequestStatus: function _getRequestStatus(req, def) {\n            var reqStatus;\n\n            if (req.xhr.readyState === 4) {\n              try {\n                reqStatus = req.xhr.status;\n              } catch (e) {\n                // ignore errors from undefined status attribute. Works\n                // around a browser bug\n                Strophe.error(\"Caught an error while retrieving a request's status, \" + \"reqStatus: \" + reqStatus);\n              }\n            }\n\n            if (typeof reqStatus === \"undefined\") {\n              reqStatus = typeof def === 'number' ? def : 0;\n            }\n\n            return reqStatus;\n          },\n\n          /** PrivateFunction: _onRequestStateChange\n           *  _Private_ handler for Strophe.Request state changes.\n           *\n           *  This function is called when the XMLHttpRequest readyState changes.\n           *  It contains a lot of error handling logic for the many ways that\n           *  requests can fail, and calls the request callback when requests\n           *  succeed.\n           *\n           *  Parameters:\n           *    (Function) func - The handler for the request.\n           *    (Strophe.Request) req - The request that is changing readyState.\n           */\n          _onRequestStateChange: function _onRequestStateChange(func, req) {\n            Strophe.debug(\"request id \" + req.id + \".\" + req.sends + \" state changed to \" + req.xhr.readyState);\n\n            if (req.abort) {\n              req.abort = false;\n              return;\n            }\n\n            if (req.xhr.readyState !== 4) {\n              // The request is not yet complete\n              return;\n            }\n\n            var reqStatus = this._getRequestStatus(req);\n\n            this.lastResponseHeaders = req.xhr.getAllResponseHeaders();\n\n            if (this.disconnecting && reqStatus >= 400) {\n              this._hitError(reqStatus);\n\n              this._callProtocolErrorHandlers(req);\n\n              return;\n            }\n\n            var valid_request = reqStatus > 0 && reqStatus < 500;\n            var too_many_retries = req.sends > this._conn.maxRetries;\n\n            if (valid_request || too_many_retries) {\n              // remove from internal queue\n              this._removeRequest(req);\n\n              Strophe.debug(\"request id \" + req.id + \" should now be removed\");\n            }\n\n            if (reqStatus === 200) {\n              // request succeeded\n              var reqIs0 = this._requests[0] === req;\n              var reqIs1 = this._requests[1] === req; // if request 1 finished, or request 0 finished and request\n              // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to\n              // restart the other - both will be in the first spot, as the\n              // completed request has been removed from the queue already\n\n              if (reqIs1 || reqIs0 && this._requests.length > 0 && this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {\n                this._restartRequest(0);\n              }\n\n              this._conn.nextValidRid(Number(req.rid) + 1);\n\n              Strophe.debug(\"request id \" + req.id + \".\" + req.sends + \" got 200\");\n              func(req); // call handler\n\n              this.errors = 0;\n            } else if (reqStatus === 0 || reqStatus >= 400 && reqStatus < 600 || reqStatus >= 12000) {\n              // request failed\n              Strophe.error(\"request id \" + req.id + \".\" + req.sends + \" error \" + reqStatus + \" happened\");\n\n              this._hitError(reqStatus);\n\n              this._callProtocolErrorHandlers(req);\n\n              if (reqStatus >= 400 && reqStatus < 500) {\n                this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING, null);\n\n                this._conn._doDisconnect();\n              }\n            } else {\n              Strophe.error(\"request id \" + req.id + \".\" + req.sends + \" error \" + reqStatus + \" happened\");\n            }\n\n            if (!valid_request && !too_many_retries) {\n              this._throttledRequestHandler();\n            } else if (too_many_retries && !this._conn.connected) {\n              this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"giving-up\");\n            }\n          },\n\n          /** PrivateFunction: _processRequest\n           *  _Private_ function to process a request in the queue.\n           *\n           *  This function takes requests off the queue and sends them and\n           *  restarts dead requests.\n           *\n           *  Parameters:\n           *    (Integer) i - The index of the request in the queue.\n           */\n          _processRequest: function _processRequest(i) {\n            var _this = this;\n\n            var req = this._requests[i];\n\n            var reqStatus = this._getRequestStatus(req, -1); // make sure we limit the number of retries\n\n\n            if (req.sends > this._conn.maxRetries) {\n              this._conn._onDisconnectTimeout();\n\n              return;\n            }\n\n            var time_elapsed = req.age();\n            var primary_timeout = !isNaN(time_elapsed) && time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait);\n            var secondary_timeout = req.dead !== null && req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait);\n            var server_error = req.xhr.readyState === 4 && (reqStatus < 1 || reqStatus >= 500);\n\n            if (primary_timeout || secondary_timeout || server_error) {\n              if (secondary_timeout) {\n                Strophe.error(\"Request \".concat(this._requests[i].id, \" timed out (secondary), restarting\"));\n              }\n\n              req.abort = true;\n              req.xhr.abort(); // setting to null fails on IE6, so set to empty function\n\n              req.xhr.onreadystatechange = function () {};\n\n              this._requests[i] = new Strophe.Request(req.xmlData, req.origFunc, req.rid, req.sends);\n              req = this._requests[i];\n            }\n\n            if (req.xhr.readyState === 0) {\n              Strophe.debug(\"request id \" + req.id + \".\" + req.sends + \" posting\");\n\n              try {\n                var content_type = this._conn.options.contentType || \"text/xml; charset=utf-8\";\n                req.xhr.open(\"POST\", this._conn.service, this._conn.options.sync ? false : true);\n\n                if (typeof req.xhr.setRequestHeader !== 'undefined') {\n                  // IE9 doesn't have setRequestHeader\n                  req.xhr.setRequestHeader(\"Content-Type\", content_type);\n                }\n\n                if (this._conn.options.withCredentials) {\n                  req.xhr.withCredentials = true;\n                }\n              } catch (e2) {\n                Strophe.error(\"XHR open failed: \" + e2.toString());\n\n                if (!this._conn.connected) {\n                  this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"bad-service\");\n                }\n\n                this._conn.disconnect();\n\n                return;\n              } // Fires the XHR request -- may be invoked immediately\n              // or on a gradually expanding retry window for reconnects\n\n\n              var sendFunc = function sendFunc() {\n                req.date = new Date();\n\n                if (_this._conn.options.customHeaders) {\n                  var headers = _this._conn.options.customHeaders;\n\n                  for (var header in headers) {\n                    if (Object.prototype.hasOwnProperty.call(headers, header)) {\n                      req.xhr.setRequestHeader(header, headers[header]);\n                    }\n                  }\n                }\n\n                req.xhr.send(req.data);\n              }; // Implement progressive backoff for reconnects --\n              // First retry (send === 1) should also be instantaneous\n\n\n              if (req.sends > 1) {\n                // Using a cube of the retry number creates a nicely\n                // expanding retry window\n                var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait), Math.pow(req.sends, 3)) * 1000;\n                setTimeout(function () {\n                  // XXX: setTimeout should be called only with function expressions (23974bc1)\n                  sendFunc();\n                }, backoff);\n              } else {\n                sendFunc();\n              }\n\n              req.sends++;\n\n              if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {\n                if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {\n                  this._conn.xmlOutput(req.xmlData.childNodes[0]);\n                } else {\n                  this._conn.xmlOutput(req.xmlData);\n                }\n              }\n\n              if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {\n                this._conn.rawOutput(req.data);\n              }\n            } else {\n              Strophe.debug(\"_processRequest: \" + (i === 0 ? \"first\" : \"second\") + \" request has readyState of \" + req.xhr.readyState);\n            }\n          },\n\n          /** PrivateFunction: _removeRequest\n           *  _Private_ function to remove a request from the queue.\n           *\n           *  Parameters:\n           *    (Strophe.Request) req - The request to remove.\n           */\n          _removeRequest: function _removeRequest(req) {\n            Strophe.debug(\"removing request\");\n\n            for (var i = this._requests.length - 1; i >= 0; i--) {\n              if (req === this._requests[i]) {\n                this._requests.splice(i, 1);\n              }\n            } // IE6 fails on setting to null, so set to empty function\n\n\n            req.xhr.onreadystatechange = function () {};\n\n            this._throttledRequestHandler();\n          },\n\n          /** PrivateFunction: _restartRequest\n           *  _Private_ function to restart a request that is presumed dead.\n           *\n           *  Parameters:\n           *    (Integer) i - The index of the request in the queue.\n           */\n          _restartRequest: function _restartRequest(i) {\n            var req = this._requests[i];\n\n            if (req.dead === null) {\n              req.dead = new Date();\n            }\n\n            this._processRequest(i);\n          },\n\n          /** PrivateFunction: _reqToData\n           * _Private_ function to get a stanza out of a request.\n           *\n           * Tries to extract a stanza out of a Request Object.\n           * When this fails the current connection will be disconnected.\n           *\n           *  Parameters:\n           *    (Object) req - The Request.\n           *\n           *  Returns:\n           *    The stanza that was passed.\n           */\n          _reqToData: function _reqToData(req) {\n            try {\n              return req.getResponse();\n            } catch (e) {\n              if (e.message !== \"parsererror\") {\n                throw e;\n              }\n\n              this._conn.disconnect(\"strophe-parsererror\");\n            }\n          },\n\n          /** PrivateFunction: _sendTerminate\n           *  _Private_ function to send initial disconnect sequence.\n           *\n           *  This is the first step in a graceful disconnect.  It sends\n           *  the BOSH server a terminate body and includes an unavailable\n           *  presence if authentication has completed.\n           */\n          _sendTerminate: function _sendTerminate(pres) {\n            Strophe.debug(\"_sendTerminate was called\");\n\n            var body = this._buildBody().attrs({\n              type: \"terminate\"\n            });\n\n            if (pres) {\n              body.cnode(pres.tree());\n            }\n\n            var req = new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), body.tree().getAttribute(\"rid\"));\n\n            this._requests.push(req);\n\n            this._throttledRequestHandler();\n          },\n\n          /** PrivateFunction: _send\n           *  _Private_ part of the Connection.send function for BOSH\n           *\n           * Just triggers the RequestHandler to send the messages that are in the queue\n           */\n          _send: function _send() {\n            var _this2 = this;\n\n            clearTimeout(this._conn._idleTimeout);\n\n            this._throttledRequestHandler();\n\n            this._conn._idleTimeout = setTimeout(function () {\n              return _this2._conn._onIdle();\n            }, 100);\n          },\n\n          /** PrivateFunction: _sendRestart\n           *\n           *  Send an xmpp:restart stanza.\n           */\n          _sendRestart: function _sendRestart() {\n            this._throttledRequestHandler();\n\n            clearTimeout(this._conn._idleTimeout);\n          },\n\n          /** PrivateFunction: _throttledRequestHandler\n           *  _Private_ function to throttle requests to the connection window.\n           *\n           *  This function makes sure we don't send requests so fast that the\n           *  request ids overflow the connection window in the case that one\n           *  request died.\n           */\n          _throttledRequestHandler: function _throttledRequestHandler() {\n            if (!this._requests) {\n              Strophe.debug(\"_throttledRequestHandler called with \" + \"undefined requests\");\n            } else {\n              Strophe.debug(\"_throttledRequestHandler called with \" + this._requests.length + \" requests\");\n            }\n\n            if (!this._requests || this._requests.length === 0) {\n              return;\n            }\n\n            if (this._requests.length > 0) {\n              this._processRequest(0);\n            }\n\n            if (this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window) {\n              this._processRequest(1);\n            }\n          }\n        };\n        /***/\n      },\n\n      /***/\n      \"./src/core.js\":\n      /*!*********************!*\\\n        !*** ./src/core.js ***!\n        \\*********************/\n\n      /*! exports provided: Strophe, $build, $iq, $msg, $pres, SHA1, MD5, default */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        \"use strict\";\n\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"Strophe\", function () {\n          return Strophe;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"$build\", function () {\n          return $build;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"$iq\", function () {\n          return $iq;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"$msg\", function () {\n          return $msg;\n        });\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"$pres\", function () {\n          return $pres;\n        });\n        /* harmony import */\n\n\n        var md5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n        /*! md5 */\n        \"./src/md5.js\");\n        /* harmony reexport (safe) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"MD5\", function () {\n          return md5__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n        });\n        /* harmony import */\n\n\n        var sha1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n        /*! sha1 */\n        \"./src/sha1.js\");\n        /* harmony reexport (safe) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"SHA1\", function () {\n          return sha1__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n        });\n        /* harmony import */\n\n\n        var utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\n        /*! utils */\n        \"./src/utils.js\");\n\n        function _toConsumableArray(arr) {\n          return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n        }\n\n        function _nonIterableSpread() {\n          throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n        }\n\n        function _iterableToArray(iter) {\n          if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n        }\n\n        function _arrayWithoutHoles(arr) {\n          if (Array.isArray(arr)) {\n            for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n              arr2[i] = arr[i];\n            }\n\n            return arr2;\n          }\n        }\n\n        function _typeof(obj) {\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n        /*\n            This program is distributed under the terms of the MIT license.\n            Please see the LICENSE file for details.\n        \n            Copyright 2006-2018, OGG, LLC\n        */\n\n        /*global define, document, sessionStorage, setTimeout, clearTimeout, ActiveXObject, DOMParser, btoa, atob, module */\n\n        /** Function: $build\n         *  Create a Strophe.Builder.\n         *  This is an alias for 'new Strophe.Builder(name, attrs)'.\n         *\n         *  Parameters:\n         *    (String) name - The root element name.\n         *    (Object) attrs - The attributes for the root element in object notation.\n         *\n         *  Returns:\n         *    A new Strophe.Builder object.\n         */\n\n\n        function $build(name, attrs) {\n          return new Strophe.Builder(name, attrs);\n        }\n        /** Function: $msg\n         *  Create a Strophe.Builder with a <message/> element as the root.\n         *\n         *  Parameters:\n         *    (Object) attrs - The <message/> element attributes in object notation.\n         *\n         *  Returns:\n         *    A new Strophe.Builder object.\n         */\n\n\n        function $msg(attrs) {\n          return new Strophe.Builder(\"message\", attrs);\n        }\n        /** Function: $iq\n         *  Create a Strophe.Builder with an <iq/> element as the root.\n         *\n         *  Parameters:\n         *    (Object) attrs - The <iq/> element attributes in object notation.\n         *\n         *  Returns:\n         *    A new Strophe.Builder object.\n         */\n\n\n        function $iq(attrs) {\n          return new Strophe.Builder(\"iq\", attrs);\n        }\n        /** Function: $pres\n         *  Create a Strophe.Builder with a <presence/> element as the root.\n         *\n         *  Parameters:\n         *    (Object) attrs - The <presence/> element attributes in object notation.\n         *\n         *  Returns:\n         *    A new Strophe.Builder object.\n         */\n\n\n        function $pres(attrs) {\n          return new Strophe.Builder(\"presence\", attrs);\n        }\n        /** Class: Strophe\n         *  An object container for all Strophe library functions.\n         *\n         *  This class is just a container for all the objects and constants\n         *  used in the library.  It is not meant to be instantiated, but to\n         *  provide a namespace for library objects, constants, and functions.\n         */\n\n\n        var Strophe = {\n          /** Constant: VERSION */\n          VERSION: \"@VERSION@\",\n\n          /** Constants: XMPP Namespace Constants\n           *  Common namespace constants from the XMPP RFCs and XEPs.\n           *\n           *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.\n           *  NS.BOSH - BOSH namespace from XEP 206.\n           *  NS.CLIENT - Main XMPP client namespace.\n           *  NS.AUTH - Legacy authentication namespace.\n           *  NS.ROSTER - Roster operations namespace.\n           *  NS.PROFILE - Profile namespace.\n           *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.\n           *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.\n           *  NS.MUC - Multi-User Chat namespace from XEP 45.\n           *  NS.SASL - XMPP SASL namespace from RFC 3920.\n           *  NS.STREAM - XMPP Streams namespace from RFC 3920.\n           *  NS.BIND - XMPP Binding namespace from RFC 3920.\n           *  NS.SESSION - XMPP Session namespace from RFC 3920.\n           *  NS.XHTML_IM - XHTML-IM namespace from XEP 71.\n           *  NS.XHTML - XHTML body namespace from XEP 71.\n           */\n          NS: {\n            HTTPBIND: \"http://jabber.org/protocol/httpbind\",\n            BOSH: \"urn:xmpp:xbosh\",\n            CLIENT: \"jabber:client\",\n            AUTH: \"jabber:iq:auth\",\n            ROSTER: \"jabber:iq:roster\",\n            PROFILE: \"jabber:iq:profile\",\n            DISCO_INFO: \"http://jabber.org/protocol/disco#info\",\n            DISCO_ITEMS: \"http://jabber.org/protocol/disco#items\",\n            MUC: \"http://jabber.org/protocol/muc\",\n            SASL: \"urn:ietf:params:xml:ns:xmpp-sasl\",\n            STREAM: \"http://etherx.jabber.org/streams\",\n            FRAMING: \"urn:ietf:params:xml:ns:xmpp-framing\",\n            BIND: \"urn:ietf:params:xml:ns:xmpp-bind\",\n            SESSION: \"urn:ietf:params:xml:ns:xmpp-session\",\n            VERSION: \"jabber:iq:version\",\n            STANZAS: \"urn:ietf:params:xml:ns:xmpp-stanzas\",\n            XHTML_IM: \"http://jabber.org/protocol/xhtml-im\",\n            XHTML: \"http://www.w3.org/1999/xhtml\"\n          },\n\n          /** Constants: XHTML_IM Namespace\n           *  contains allowed tags, tag attributes, and css properties.\n           *  Used in the createHtml function to filter incoming html into the allowed XHTML-IM subset.\n           *  See http://xmpp.org/extensions/xep-0071.html#profile-summary for the list of recommended\n           *  allowed tags and their attributes.\n           */\n          XHTML: {\n            tags: ['a', 'blockquote', 'br', 'cite', 'em', 'img', 'li', 'ol', 'p', 'span', 'strong', 'ul', 'body'],\n            attributes: {\n              'a': ['href'],\n              'blockquote': ['style'],\n              'br': [],\n              'cite': ['style'],\n              'em': [],\n              'img': ['src', 'alt', 'style', 'height', 'width'],\n              'li': ['style'],\n              'ol': ['style'],\n              'p': ['style'],\n              'span': ['style'],\n              'strong': [],\n              'ul': ['style'],\n              'body': []\n            },\n            css: ['background-color', 'color', 'font-family', 'font-size', 'font-style', 'font-weight', 'margin-left', 'margin-right', 'text-align', 'text-decoration'],\n\n            /** Function: XHTML.validTag\n             *\n             * Utility method to determine whether a tag is allowed\n             * in the XHTML_IM namespace.\n             *\n             * XHTML tag names are case sensitive and must be lower case.\n             */\n            validTag: function validTag(tag) {\n              for (var i = 0; i < Strophe.XHTML.tags.length; i++) {\n                if (tag === Strophe.XHTML.tags[i]) {\n                  return true;\n                }\n              }\n\n              return false;\n            },\n\n            /** Function: XHTML.validAttribute\n             *\n             * Utility method to determine whether an attribute is allowed\n             * as recommended per XEP-0071\n             *\n             * XHTML attribute names are case sensitive and must be lower case.\n             */\n            validAttribute: function validAttribute(tag, attribute) {\n              if (typeof Strophe.XHTML.attributes[tag] !== 'undefined' && Strophe.XHTML.attributes[tag].length > 0) {\n                for (var i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {\n                  if (attribute === Strophe.XHTML.attributes[tag][i]) {\n                    return true;\n                  }\n                }\n              }\n\n              return false;\n            },\n            validCSS: function validCSS(style) {\n              for (var i = 0; i < Strophe.XHTML.css.length; i++) {\n                if (style === Strophe.XHTML.css[i]) {\n                  return true;\n                }\n              }\n\n              return false;\n            }\n          },\n\n          /** Constants: Connection Status Constants\n           *  Connection status constants for use by the connection handler\n           *  callback.\n           *\n           *  Status.ERROR - An error has occurred\n           *  Status.CONNECTING - The connection is currently being made\n           *  Status.CONNFAIL - The connection attempt failed\n           *  Status.AUTHENTICATING - The connection is authenticating\n           *  Status.AUTHFAIL - The authentication attempt failed\n           *  Status.CONNECTED - The connection has succeeded\n           *  Status.DISCONNECTED - The connection has been terminated\n           *  Status.DISCONNECTING - The connection is currently being terminated\n           *  Status.ATTACHED - The connection has been attached\n           *  Status.REDIRECT - The connection has been redirected\n           *  Status.CONNTIMEOUT - The connection has timed out\n           */\n          Status: {\n            ERROR: 0,\n            CONNECTING: 1,\n            CONNFAIL: 2,\n            AUTHENTICATING: 3,\n            AUTHFAIL: 4,\n            CONNECTED: 5,\n            DISCONNECTED: 6,\n            DISCONNECTING: 7,\n            ATTACHED: 8,\n            REDIRECT: 9,\n            CONNTIMEOUT: 10\n          },\n          ErrorCondition: {\n            BAD_FORMAT: \"bad-format\",\n            CONFLICT: \"conflict\",\n            MISSING_JID_NODE: \"x-strophe-bad-non-anon-jid\",\n            NO_AUTH_MECH: \"no-auth-mech\",\n            UNKNOWN_REASON: \"unknown\"\n          },\n\n          /** Constants: Log Level Constants\n           *  Logging level indicators.\n           *\n           *  LogLevel.DEBUG - Debug output\n           *  LogLevel.INFO - Informational output\n           *  LogLevel.WARN - Warnings\n           *  LogLevel.ERROR - Errors\n           *  LogLevel.FATAL - Fatal errors\n           */\n          LogLevel: {\n            DEBUG: 0,\n            INFO: 1,\n            WARN: 2,\n            ERROR: 3,\n            FATAL: 4\n          },\n\n          /** PrivateConstants: DOM Element Type Constants\n           *  DOM element types.\n           *\n           *  ElementType.NORMAL - Normal element.\n           *  ElementType.TEXT - Text data element.\n           *  ElementType.FRAGMENT - XHTML fragment element.\n           */\n          ElementType: {\n            NORMAL: 1,\n            TEXT: 3,\n            CDATA: 4,\n            FRAGMENT: 11\n          },\n\n          /** PrivateConstants: Timeout Values\n           *  Timeout values for error states.  These values are in seconds.\n           *  These should not be changed unless you know exactly what you are\n           *  doing.\n           *\n           *  TIMEOUT - Timeout multiplier. A waiting request will be considered\n           *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.\n           *      This defaults to 1.1, and with default wait, 66 seconds.\n           *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where\n           *      Strophe can detect early failure, it will consider the request\n           *      failed if it doesn't return after\n           *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.\n           *      This defaults to 0.1, and with default wait, 6 seconds.\n           */\n          TIMEOUT: 1.1,\n          SECONDARY_TIMEOUT: 0.1,\n\n          /** Function: addNamespace\n           *  This function is used to extend the current namespaces in\n           *  Strophe.NS.  It takes a key and a value with the key being the\n           *  name of the new namespace, with its actual value.\n           *  For example:\n           *  Strophe.addNamespace('PUBSUB', \"http://jabber.org/protocol/pubsub\");\n           *\n           *  Parameters:\n           *    (String) name - The name under which the namespace will be\n           *      referenced under Strophe.NS\n           *    (String) value - The actual namespace.\n           */\n          addNamespace: function addNamespace(name, value) {\n            Strophe.NS[name] = value;\n          },\n\n          /** Function: forEachChild\n           *  Map a function over some or all child elements of a given element.\n           *\n           *  This is a small convenience function for mapping a function over\n           *  some or all of the children of an element.  If elemName is null, all\n           *  children will be passed to the function, otherwise only children\n           *  whose tag names match elemName will be passed.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - The element to operate on.\n           *    (String) elemName - The child element tag name filter.\n           *    (Function) func - The function to apply to each child.  This\n           *      function should take a single argument, a DOM element.\n           */\n          forEachChild: function forEachChild(elem, elemName, func) {\n            for (var i = 0; i < elem.childNodes.length; i++) {\n              var childNode = elem.childNodes[i];\n\n              if (childNode.nodeType === Strophe.ElementType.NORMAL && (!elemName || this.isTagEqual(childNode, elemName))) {\n                func(childNode);\n              }\n            }\n          },\n\n          /** Function: isTagEqual\n           *  Compare an element's tag name with a string.\n           *\n           *  This function is case sensitive.\n           *\n           *  Parameters:\n           *    (XMLElement) el - A DOM element.\n           *    (String) name - The element name.\n           *\n           *  Returns:\n           *    true if the element's tag name matches _el_, and false\n           *    otherwise.\n           */\n          isTagEqual: function isTagEqual(el, name) {\n            return el.tagName === name;\n          },\n\n          /** PrivateVariable: _xmlGenerator\n           *  _Private_ variable that caches a DOM document to\n           *  generate elements.\n           */\n          _xmlGenerator: null,\n\n          /** PrivateFunction: _makeGenerator\n           *  _Private_ function that creates a dummy XML DOM document to serve as\n           *  an element and text node generator.\n           */\n          _makeGenerator: function _makeGenerator() {\n            var doc; // IE9 does implement createDocument(); however, using it will cause the browser to leak memory on page unload.\n            // Here, we test for presence of createDocument() plus IE's proprietary documentMode attribute, which would be\n            // less than 10 in the case of IE9 and below.\n\n            if (document.implementation.createDocument === undefined || document.implementation.createDocument && document.documentMode && document.documentMode < 10) {\n              doc = this._getIEXmlDom();\n              doc.appendChild(doc.createElement('strophe'));\n            } else {\n              doc = document.implementation.createDocument('jabber:client', 'strophe', null);\n            }\n\n            return doc;\n          },\n\n          /** Function: xmlGenerator\n           *  Get the DOM document to generate elements.\n           *\n           *  Returns:\n           *    The currently used DOM document.\n           */\n          xmlGenerator: function xmlGenerator() {\n            if (!Strophe._xmlGenerator) {\n              Strophe._xmlGenerator = Strophe._makeGenerator();\n            }\n\n            return Strophe._xmlGenerator;\n          },\n\n          /** PrivateFunction: _getIEXmlDom\n           *  Gets IE xml doc object\n           *\n           *  Returns:\n           *    A Microsoft XML DOM Object\n           *  See Also:\n           *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx\n           */\n          _getIEXmlDom: function _getIEXmlDom() {\n            var doc = null;\n            var docStrings = [\"Msxml2.DOMDocument.6.0\", \"Msxml2.DOMDocument.5.0\", \"Msxml2.DOMDocument.4.0\", \"MSXML2.DOMDocument.3.0\", \"MSXML2.DOMDocument\", \"MSXML.DOMDocument\", \"Microsoft.XMLDOM\"];\n\n            for (var d = 0; d < docStrings.length; d++) {\n              if (doc === null) {\n                try {\n                  doc = new ActiveXObject(docStrings[d]);\n                } catch (e) {\n                  doc = null;\n                }\n              } else {\n                break;\n              }\n            }\n\n            return doc;\n          },\n\n          /** Function: xmlElement\n           *  Create an XML DOM element.\n           *\n           *  This function creates an XML DOM element correctly across all\n           *  implementations. Note that these are not HTML DOM elements, which\n           *  aren't appropriate for XMPP stanzas.\n           *\n           *  Parameters:\n           *    (String) name - The name for the element.\n           *    (Array|Object) attrs - An optional array or object containing\n           *      key/value pairs to use as element attributes. The object should\n           *      be in the format {'key': 'value'} or {key: 'value'}. The array\n           *      should have the format [['key1', 'value1'], ['key2', 'value2']].\n           *    (String) text - The text child data for the element.\n           *\n           *  Returns:\n           *    A new XML DOM element.\n           */\n          xmlElement: function xmlElement(name) {\n            if (!name) {\n              return null;\n            }\n\n            var node = Strophe.xmlGenerator().createElement(name); // FIXME: this should throw errors if args are the wrong type or\n            // there are more than two optional args\n\n            for (var a = 1; a < arguments.length; a++) {\n              var arg = arguments[a];\n\n              if (!arg) {\n                continue;\n              }\n\n              if (typeof arg === \"string\" || typeof arg === \"number\") {\n                node.appendChild(Strophe.xmlTextNode(arg));\n              } else if (_typeof(arg) === \"object\" && typeof arg.sort === \"function\") {\n                for (var i = 0; i < arg.length; i++) {\n                  var attr = arg[i];\n\n                  if (_typeof(attr) === \"object\" && typeof attr.sort === \"function\" && attr[1] !== undefined && attr[1] !== null) {\n                    node.setAttribute(attr[0], attr[1]);\n                  }\n                }\n              } else if (_typeof(arg) === \"object\") {\n                for (var k in arg) {\n                  if (Object.prototype.hasOwnProperty.call(arg, k) && arg[k] !== undefined && arg[k] !== null) {\n                    node.setAttribute(k, arg[k]);\n                  }\n                }\n              }\n            }\n\n            return node;\n          },\n\n          /*  Function: xmlescape\n           *  Excapes invalid xml characters.\n           *\n           *  Parameters:\n           *     (String) text - text to escape.\n           *\n           *  Returns:\n           *      Escaped text.\n           */\n          xmlescape: function xmlescape(text) {\n            text = text.replace(/\\&/g, \"&amp;\");\n            text = text.replace(/</g, \"&lt;\");\n            text = text.replace(/>/g, \"&gt;\");\n            text = text.replace(/'/g, \"&apos;\");\n            text = text.replace(/\"/g, \"&quot;\");\n            return text;\n          },\n\n          /*  Function: xmlunescape\n          *  Unexcapes invalid xml characters.\n          *\n          *  Parameters:\n          *     (String) text - text to unescape.\n          *\n          *  Returns:\n          *      Unescaped text.\n          */\n          xmlunescape: function xmlunescape(text) {\n            text = text.replace(/\\&amp;/g, \"&\");\n            text = text.replace(/&lt;/g, \"<\");\n            text = text.replace(/&gt;/g, \">\");\n            text = text.replace(/&apos;/g, \"'\");\n            text = text.replace(/&quot;/g, \"\\\"\");\n            return text;\n          },\n\n          /** Function: xmlTextNode\n           *  Creates an XML DOM text node.\n           *\n           *  Provides a cross implementation version of document.createTextNode.\n           *\n           *  Parameters:\n           *    (String) text - The content of the text node.\n           *\n           *  Returns:\n           *    A new XML DOM text node.\n           */\n          xmlTextNode: function xmlTextNode(text) {\n            return Strophe.xmlGenerator().createTextNode(text);\n          },\n\n          /** Function: xmlHtmlNode\n           *  Creates an XML DOM html node.\n           *\n           *  Parameters:\n           *    (String) html - The content of the html node.\n           *\n           *  Returns:\n           *    A new XML DOM text node.\n           */\n          xmlHtmlNode: function xmlHtmlNode(html) {\n            var node; //ensure text is escaped\n\n            if (DOMParser) {\n              var parser = new DOMParser();\n              node = parser.parseFromString(html, \"text/xml\");\n            } else {\n              node = new ActiveXObject(\"Microsoft.XMLDOM\");\n              node.async = \"false\";\n              node.loadXML(html);\n            }\n\n            return node;\n          },\n\n          /** Function: getText\n           *  Get the concatenation of all text children of an element.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - A DOM element.\n           *\n           *  Returns:\n           *    A String with the concatenated text of all text element children.\n           */\n          getText: function getText(elem) {\n            if (!elem) {\n              return null;\n            }\n\n            var str = \"\";\n\n            if (elem.childNodes.length === 0 && elem.nodeType === Strophe.ElementType.TEXT) {\n              str += elem.nodeValue;\n            }\n\n            for (var i = 0; i < elem.childNodes.length; i++) {\n              if (elem.childNodes[i].nodeType === Strophe.ElementType.TEXT) {\n                str += elem.childNodes[i].nodeValue;\n              }\n            }\n\n            return Strophe.xmlescape(str);\n          },\n\n          /** Function: copyElement\n           *  Copy an XML DOM element.\n           *\n           *  This function copies a DOM element and all its descendants and returns\n           *  the new copy.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - A DOM element.\n           *\n           *  Returns:\n           *    A new, copied DOM element tree.\n           */\n          copyElement: function copyElement(elem) {\n            var el;\n\n            if (elem.nodeType === Strophe.ElementType.NORMAL) {\n              el = Strophe.xmlElement(elem.tagName);\n\n              for (var i = 0; i < elem.attributes.length; i++) {\n                el.setAttribute(elem.attributes[i].nodeName, elem.attributes[i].value);\n              }\n\n              for (var _i = 0; _i < elem.childNodes.length; _i++) {\n                el.appendChild(Strophe.copyElement(elem.childNodes[_i]));\n              }\n            } else if (elem.nodeType === Strophe.ElementType.TEXT) {\n              el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);\n            }\n\n            return el;\n          },\n\n          /** Function: createHtml\n           *  Copy an HTML DOM element into an XML DOM.\n           *\n           *  This function copies a DOM element and all its descendants and returns\n           *  the new copy.\n           *\n           *  Parameters:\n           *    (HTMLElement) elem - A DOM element.\n           *\n           *  Returns:\n           *    A new, copied DOM element tree.\n           */\n          createHtml: function createHtml(elem) {\n            var el;\n\n            if (elem.nodeType === Strophe.ElementType.NORMAL) {\n              var tag = elem.nodeName.toLowerCase(); // XHTML tags must be lower case.\n\n              if (Strophe.XHTML.validTag(tag)) {\n                try {\n                  el = Strophe.xmlElement(tag);\n\n                  for (var i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {\n                    var attribute = Strophe.XHTML.attributes[tag][i];\n                    var value = elem.getAttribute(attribute);\n\n                    if (typeof value === 'undefined' || value === null || value === '' || value === false || value === 0) {\n                      continue;\n                    }\n\n                    if (attribute === 'style' && _typeof(value) === 'object' && typeof value.cssText !== 'undefined') {\n                      value = value.cssText; // we're dealing with IE, need to get CSS out\n                    } // filter out invalid css styles\n\n\n                    if (attribute === 'style') {\n                      var css = [];\n                      var cssAttrs = value.split(';');\n\n                      for (var j = 0; j < cssAttrs.length; j++) {\n                        var attr = cssAttrs[j].split(':');\n                        var cssName = attr[0].replace(/^\\s*/, \"\").replace(/\\s*$/, \"\").toLowerCase();\n\n                        if (Strophe.XHTML.validCSS(cssName)) {\n                          var cssValue = attr[1].replace(/^\\s*/, \"\").replace(/\\s*$/, \"\");\n                          css.push(cssName + ': ' + cssValue);\n                        }\n                      }\n\n                      if (css.length > 0) {\n                        value = css.join('; ');\n                        el.setAttribute(attribute, value);\n                      }\n                    } else {\n                      el.setAttribute(attribute, value);\n                    }\n                  }\n\n                  for (var _i2 = 0; _i2 < elem.childNodes.length; _i2++) {\n                    el.appendChild(Strophe.createHtml(elem.childNodes[_i2]));\n                  }\n                } catch (e) {\n                  // invalid elements\n                  el = Strophe.xmlTextNode('');\n                }\n              } else {\n                el = Strophe.xmlGenerator().createDocumentFragment();\n\n                for (var _i3 = 0; _i3 < elem.childNodes.length; _i3++) {\n                  el.appendChild(Strophe.createHtml(elem.childNodes[_i3]));\n                }\n              }\n            } else if (elem.nodeType === Strophe.ElementType.FRAGMENT) {\n              el = Strophe.xmlGenerator().createDocumentFragment();\n\n              for (var _i4 = 0; _i4 < elem.childNodes.length; _i4++) {\n                el.appendChild(Strophe.createHtml(elem.childNodes[_i4]));\n              }\n            } else if (elem.nodeType === Strophe.ElementType.TEXT) {\n              el = Strophe.xmlTextNode(elem.nodeValue);\n            }\n\n            return el;\n          },\n\n          /** Function: escapeNode\n           *  Escape the node part (also called local part) of a JID.\n           *\n           *  Parameters:\n           *    (String) node - A node (or local part).\n           *\n           *  Returns:\n           *    An escaped node (or local part).\n           */\n          escapeNode: function escapeNode(node) {\n            if (typeof node !== \"string\") {\n              return node;\n            }\n\n            return node.replace(/^\\s+|\\s+$/g, '').replace(/\\\\/g, \"\\\\5c\").replace(/ /g, \"\\\\20\").replace(/\\\"/g, \"\\\\22\").replace(/\\&/g, \"\\\\26\").replace(/\\'/g, \"\\\\27\").replace(/\\//g, \"\\\\2f\").replace(/:/g, \"\\\\3a\").replace(/</g, \"\\\\3c\").replace(/>/g, \"\\\\3e\").replace(/@/g, \"\\\\40\");\n          },\n\n          /** Function: unescapeNode\n           *  Unescape a node part (also called local part) of a JID.\n           *\n           *  Parameters:\n           *    (String) node - A node (or local part).\n           *\n           *  Returns:\n           *    An unescaped node (or local part).\n           */\n          unescapeNode: function unescapeNode(node) {\n            if (typeof node !== \"string\") {\n              return node;\n            }\n\n            return node.replace(/\\\\20/g, \" \").replace(/\\\\22/g, '\"').replace(/\\\\26/g, \"&\").replace(/\\\\27/g, \"'\").replace(/\\\\2f/g, \"/\").replace(/\\\\3a/g, \":\").replace(/\\\\3c/g, \"<\").replace(/\\\\3e/g, \">\").replace(/\\\\40/g, \"@\").replace(/\\\\5c/g, \"\\\\\");\n          },\n\n          /** Function: getNodeFromJid\n           *  Get the node portion of a JID String.\n           *\n           *  Parameters:\n           *    (String) jid - A JID.\n           *\n           *  Returns:\n           *    A String containing the node.\n           */\n          getNodeFromJid: function getNodeFromJid(jid) {\n            if (jid.indexOf(\"@\") < 0) {\n              return null;\n            }\n\n            return jid.split(\"@\")[0];\n          },\n\n          /** Function: getDomainFromJid\n           *  Get the domain portion of a JID String.\n           *\n           *  Parameters:\n           *    (String) jid - A JID.\n           *\n           *  Returns:\n           *    A String containing the domain.\n           */\n          getDomainFromJid: function getDomainFromJid(jid) {\n            var bare = Strophe.getBareJidFromJid(jid);\n\n            if (bare.indexOf(\"@\") < 0) {\n              return bare;\n            } else {\n              var parts = bare.split(\"@\");\n              parts.splice(0, 1);\n              return parts.join('@');\n            }\n          },\n\n          /** Function: getResourceFromJid\n           *  Get the resource portion of a JID String.\n           *\n           *  Parameters:\n           *    (String) jid - A JID.\n           *\n           *  Returns:\n           *    A String containing the resource.\n           */\n          getResourceFromJid: function getResourceFromJid(jid) {\n            if (!jid) {\n              return null;\n            }\n\n            var s = jid.split(\"/\");\n\n            if (s.length < 2) {\n              return null;\n            }\n\n            s.splice(0, 1);\n            return s.join('/');\n          },\n\n          /** Function: getBareJidFromJid\n           *  Get the bare JID from a JID String.\n           *\n           *  Parameters:\n           *    (String) jid - A JID.\n           *\n           *  Returns:\n           *    A String containing the bare JID.\n           */\n          getBareJidFromJid: function getBareJidFromJid(jid) {\n            return jid ? jid.split(\"/\")[0] : null;\n          },\n\n          /** PrivateFunction: _handleError\n           *  _Private_ function that properly logs an error to the console\n           */\n          _handleError: function _handleError(e) {\n            if (typeof e.stack !== \"undefined\") {\n              Strophe.fatal(e.stack);\n            }\n\n            if (e.sourceURL) {\n              Strophe.fatal(\"error: \" + this.handler + \" \" + e.sourceURL + \":\" + e.line + \" - \" + e.name + \": \" + e.message);\n            } else if (e.fileName) {\n              Strophe.fatal(\"error: \" + this.handler + \" \" + e.fileName + \":\" + e.lineNumber + \" - \" + e.name + \": \" + e.message);\n            } else {\n              Strophe.fatal(\"error: \" + e.message);\n            }\n          },\n\n          /** Function: log\n           *  User overrideable logging function.\n           *\n           *  This function is called whenever the Strophe library calls any\n           *  of the logging functions.  The default implementation of this\n           *  function logs only fatal errors.  If client code wishes to handle the logging\n           *  messages, it should override this with\n           *  > Strophe.log = function (level, msg) {\n           *  >   (user code here)\n           *  > };\n           *\n           *  Please note that data sent and received over the wire is logged\n           *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().\n           *\n           *  The different levels and their meanings are\n           *\n           *    DEBUG - Messages useful for debugging purposes.\n           *    INFO - Informational messages.  This is mostly information like\n           *      'disconnect was called' or 'SASL auth succeeded'.\n           *    WARN - Warnings about potential problems.  This is mostly used\n           *      to report transient connection errors like request timeouts.\n           *    ERROR - Some error occurred.\n           *    FATAL - A non-recoverable fatal error occurred.\n           *\n           *  Parameters:\n           *    (Integer) level - The log level of the log message.  This will\n           *      be one of the values in Strophe.LogLevel.\n           *    (String) msg - The log message.\n           */\n          log: function log(level, msg) {\n            if (level === this.LogLevel.FATAL && _typeof(window.console) === 'object' && typeof window.console.error === 'function') {\n              window.console.error(msg);\n            }\n          },\n\n          /** Function: debug\n           *  Log a message at the Strophe.LogLevel.DEBUG level.\n           *\n           *  Parameters:\n           *    (String) msg - The log message.\n           */\n          debug: function debug(msg) {\n            this.log(this.LogLevel.DEBUG, msg);\n          },\n\n          /** Function: info\n           *  Log a message at the Strophe.LogLevel.INFO level.\n           *\n           *  Parameters:\n           *    (String) msg - The log message.\n           */\n          info: function info(msg) {\n            this.log(this.LogLevel.INFO, msg);\n          },\n\n          /** Function: warn\n           *  Log a message at the Strophe.LogLevel.WARN level.\n           *\n           *  Parameters:\n           *    (String) msg - The log message.\n           */\n          warn: function warn(msg) {\n            this.log(this.LogLevel.WARN, msg);\n          },\n\n          /** Function: error\n           *  Log a message at the Strophe.LogLevel.ERROR level.\n           *\n           *  Parameters:\n           *    (String) msg - The log message.\n           */\n          error: function error(msg) {\n            this.log(this.LogLevel.ERROR, msg);\n          },\n\n          /** Function: fatal\n           *  Log a message at the Strophe.LogLevel.FATAL level.\n           *\n           *  Parameters:\n           *    (String) msg - The log message.\n           */\n          fatal: function fatal(msg) {\n            this.log(this.LogLevel.FATAL, msg);\n          },\n\n          /** Function: serialize\n           *  Render a DOM element and all descendants to a String.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - A DOM element.\n           *\n           *  Returns:\n           *    The serialized element tree as a String.\n           */\n          serialize: function serialize(elem) {\n            if (!elem) {\n              return null;\n            }\n\n            if (typeof elem.tree === \"function\") {\n              elem = elem.tree();\n            }\n\n            var names = _toConsumableArray(Array(elem.attributes.length).keys()).map(function (i) {\n              return elem.attributes[i].nodeName;\n            });\n\n            names.sort();\n            var result = names.reduce(function (a, n) {\n              return \"\".concat(a, \" \").concat(n, \"=\\\"\").concat(Strophe.xmlescape(elem.attributes.getNamedItem(n).value), \"\\\"\");\n            }, \"<\".concat(elem.nodeName));\n\n            if (elem.childNodes.length > 0) {\n              result += \">\";\n\n              for (var i = 0; i < elem.childNodes.length; i++) {\n                var child = elem.childNodes[i];\n\n                switch (child.nodeType) {\n                  case Strophe.ElementType.NORMAL:\n                    // normal element, so recurse\n                    result += Strophe.serialize(child);\n                    break;\n\n                  case Strophe.ElementType.TEXT:\n                    // text element to escape values\n                    result += Strophe.xmlescape(child.nodeValue);\n                    break;\n\n                  case Strophe.ElementType.CDATA:\n                    // cdata section so don't escape values\n                    result += \"<![CDATA[\" + child.nodeValue + \"]]>\";\n                }\n              }\n\n              result += \"</\" + elem.nodeName + \">\";\n            } else {\n              result += \"/>\";\n            }\n\n            return result;\n          },\n\n          /** PrivateVariable: _requestId\n           *  _Private_ variable that keeps track of the request ids for\n           *  connections.\n           */\n          _requestId: 0,\n\n          /** PrivateVariable: Strophe.connectionPlugins\n           *  _Private_ variable Used to store plugin names that need\n           *  initialization on Strophe.Connection construction.\n           */\n          _connectionPlugins: {},\n\n          /** Function: addConnectionPlugin\n           *  Extends the Strophe.Connection object with the given plugin.\n           *\n           *  Parameters:\n           *    (String) name - The name of the extension.\n           *    (Object) ptype - The plugin's prototype.\n           */\n          addConnectionPlugin: function addConnectionPlugin(name, ptype) {\n            Strophe._connectionPlugins[name] = ptype;\n          }\n        };\n        /** Class: Strophe.Builder\n         *  XML DOM builder.\n         *\n         *  This object provides an interface similar to JQuery but for building\n         *  DOM elements easily and rapidly.  All the functions except for toString()\n         *  and tree() return the object, so calls can be chained.  Here's an\n         *  example using the $iq() builder helper.\n         *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})\n         *  >     .c('query', {xmlns: 'strophe:example'})\n         *  >     .c('example')\n         *  >     .toString()\n         *\n         *  The above generates this XML fragment\n         *  > <iq to='you' from='me' type='get' id='1'>\n         *  >   <query xmlns='strophe:example'>\n         *  >     <example/>\n         *  >   </query>\n         *  > </iq>\n         *  The corresponding DOM manipulations to get a similar fragment would be\n         *  a lot more tedious and probably involve several helper variables.\n         *\n         *  Since adding children makes new operations operate on the child, up()\n         *  is provided to traverse up the tree.  To add two children, do\n         *  > builder.c('child1', ...).up().c('child2', ...)\n         *  The next operation on the Builder will be relative to the second child.\n         */\n\n        /** Constructor: Strophe.Builder\n         *  Create a Strophe.Builder object.\n         *\n         *  The attributes should be passed in object notation.  For example\n         *  > let b = new Builder('message', {to: 'you', from: 'me'});\n         *  or\n         *  > let b = new Builder('messsage', {'xml:lang': 'en'});\n         *\n         *  Parameters:\n         *    (String) name - The name of the root element.\n         *    (Object) attrs - The attributes for the root element in object notation.\n         *\n         *  Returns:\n         *    A new Strophe.Builder.\n         */\n\n        Strophe.Builder = function (name, attrs) {\n          // Set correct namespace for jabber:client elements\n          if (name === \"presence\" || name === \"message\" || name === \"iq\") {\n            if (attrs && !attrs.xmlns) {\n              attrs.xmlns = Strophe.NS.CLIENT;\n            } else if (!attrs) {\n              attrs = {\n                xmlns: Strophe.NS.CLIENT\n              };\n            }\n          } // Holds the tree being built.\n\n\n          this.nodeTree = Strophe.xmlElement(name, attrs); // Points to the current operation node.\n\n          this.node = this.nodeTree;\n        };\n\n        Strophe.Builder.prototype = {\n          /** Function: tree\n           *  Return the DOM tree.\n           *\n           *  This function returns the current DOM tree as an element object.  This\n           *  is suitable for passing to functions like Strophe.Connection.send().\n           *\n           *  Returns:\n           *    The DOM tree as a element object.\n           */\n          tree: function tree() {\n            return this.nodeTree;\n          },\n\n          /** Function: toString\n           *  Serialize the DOM tree to a String.\n           *\n           *  This function returns a string serialization of the current DOM\n           *  tree.  It is often used internally to pass data to a\n           *  Strophe.Request object.\n           *\n           *  Returns:\n           *    The serialized DOM tree in a String.\n           */\n          toString: function toString() {\n            return Strophe.serialize(this.nodeTree);\n          },\n\n          /** Function: up\n           *  Make the current parent element the new current element.\n           *\n           *  This function is often used after c() to traverse back up the tree.\n           *  For example, to add two children to the same element\n           *  > builder.c('child1', {}).up().c('child2', {});\n           *\n           *  Returns:\n           *    The Stophe.Builder object.\n           */\n          up: function up() {\n            this.node = this.node.parentNode;\n            return this;\n          },\n\n          /** Function: root\n           *  Make the root element the new current element.\n           *\n           *  When at a deeply nested element in the tree, this function can be used\n           *  to jump back to the root of the tree, instead of having to repeatedly\n           *  call up().\n           *\n           *  Returns:\n           *    The Stophe.Builder object.\n           */\n          root: function root() {\n            this.node = this.nodeTree;\n            return this;\n          },\n\n          /** Function: attrs\n           *  Add or modify attributes of the current element.\n           *\n           *  The attributes should be passed in object notation.  This function\n           *  does not move the current element pointer.\n           *\n           *  Parameters:\n           *    (Object) moreattrs - The attributes to add/modify in object notation.\n           *\n           *  Returns:\n           *    The Strophe.Builder object.\n           */\n          attrs: function attrs(moreattrs) {\n            for (var k in moreattrs) {\n              if (Object.prototype.hasOwnProperty.call(moreattrs, k)) {\n                if (moreattrs[k] === undefined) {\n                  this.node.removeAttribute(k);\n                } else {\n                  this.node.setAttribute(k, moreattrs[k]);\n                }\n              }\n            }\n\n            return this;\n          },\n\n          /** Function: c\n           *  Add a child to the current element and make it the new current\n           *  element.\n           *\n           *  This function moves the current element pointer to the child,\n           *  unless text is provided.  If you need to add another child, it\n           *  is necessary to use up() to go back to the parent in the tree.\n           *\n           *  Parameters:\n           *    (String) name - The name of the child.\n           *    (Object) attrs - The attributes of the child in object notation.\n           *    (String) text - The text to add to the child.\n           *\n           *  Returns:\n           *    The Strophe.Builder object.\n           */\n          c: function c(name, attrs, text) {\n            var child = Strophe.xmlElement(name, attrs, text);\n            this.node.appendChild(child);\n\n            if (typeof text !== \"string\" && typeof text !== \"number\") {\n              this.node = child;\n            }\n\n            return this;\n          },\n\n          /** Function: cnode\n           *  Add a child to the current element and make it the new current\n           *  element.\n           *\n           *  This function is the same as c() except that instead of using a\n           *  name and an attributes object to create the child it uses an\n           *  existing DOM element object.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - A DOM element.\n           *\n           *  Returns:\n           *    The Strophe.Builder object.\n           */\n          cnode: function cnode(elem) {\n            var impNode;\n            var xmlGen = Strophe.xmlGenerator();\n\n            try {\n              impNode = xmlGen.importNode !== undefined;\n            } catch (e) {\n              impNode = false;\n            }\n\n            var newElem = impNode ? xmlGen.importNode(elem, true) : Strophe.copyElement(elem);\n            this.node.appendChild(newElem);\n            this.node = newElem;\n            return this;\n          },\n\n          /** Function: t\n           *  Add a child text element.\n           *\n           *  This *does not* make the child the new current element since there\n           *  are no children of text elements.\n           *\n           *  Parameters:\n           *    (String) text - The text data to append to the current element.\n           *\n           *  Returns:\n           *    The Strophe.Builder object.\n           */\n          t: function t(text) {\n            var child = Strophe.xmlTextNode(text);\n            this.node.appendChild(child);\n            return this;\n          },\n\n          /** Function: h\n           *  Replace current element contents with the HTML passed in.\n           *\n           *  This *does not* make the child the new current element\n           *\n           *  Parameters:\n           *    (String) html - The html to insert as contents of current element.\n           *\n           *  Returns:\n           *    The Strophe.Builder object.\n           */\n          h: function h(html) {\n            var fragment = document.createElement('body'); // force the browser to try and fix any invalid HTML tags\n\n            fragment.innerHTML = html; // copy cleaned html into an xml dom\n\n            var xhtml = Strophe.createHtml(fragment);\n\n            while (xhtml.childNodes.length > 0) {\n              this.node.appendChild(xhtml.childNodes[0]);\n            }\n\n            return this;\n          }\n        };\n        /** PrivateClass: Strophe.Handler\n         *  _Private_ helper class for managing stanza handlers.\n         *\n         *  A Strophe.Handler encapsulates a user provided callback function to be\n         *  executed when matching stanzas are received by the connection.\n         *  Handlers can be either one-off or persistant depending on their\n         *  return value. Returning true will cause a Handler to remain active, and\n         *  returning false will remove the Handler.\n         *\n         *  Users will not use Strophe.Handler objects directly, but instead they\n         *  will use Strophe.Connection.addHandler() and\n         *  Strophe.Connection.deleteHandler().\n         */\n\n        /** PrivateConstructor: Strophe.Handler\n         *  Create and initialize a new Strophe.Handler.\n         *\n         *  Parameters:\n         *    (Function) handler - A function to be executed when the handler is run.\n         *    (String) ns - The namespace to match.\n         *    (String) name - The element name to match.\n         *    (String) type - The element type to match.\n         *    (String) id - The element id attribute to match.\n         *    (String) from - The element from attribute to match.\n         *    (Object) options - Handler options\n         *\n         *  Returns:\n         *    A new Strophe.Handler object.\n         */\n\n        Strophe.Handler = function (handler, ns, name, type, id, from, options) {\n          this.handler = handler;\n          this.ns = ns;\n          this.name = name;\n          this.type = type;\n          this.id = id;\n          this.options = options || {\n            'matchBareFromJid': false,\n            'ignoreNamespaceFragment': false\n          }; // BBB: Maintain backward compatibility with old `matchBare` option\n\n          if (this.options.matchBare) {\n            Strophe.warn('The \"matchBare\" option is deprecated, use \"matchBareFromJid\" instead.');\n            this.options.matchBareFromJid = this.options.matchBare;\n            delete this.options.matchBare;\n          }\n\n          if (this.options.matchBareFromJid) {\n            this.from = from ? Strophe.getBareJidFromJid(from) : null;\n          } else {\n            this.from = from;\n          } // whether the handler is a user handler or a system handler\n\n\n          this.user = true;\n        };\n\n        Strophe.Handler.prototype = {\n          /** PrivateFunction: getNamespace\n           *  Returns the XML namespace attribute on an element.\n           *  If `ignoreNamespaceFragment` was passed in for this handler, then the\n           *  URL fragment will be stripped.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - The XML element with the namespace.\n           *\n           *  Returns:\n           *    The namespace, with optionally the fragment stripped.\n           */\n          getNamespace: function getNamespace(elem) {\n            var elNamespace = elem.getAttribute(\"xmlns\");\n\n            if (elNamespace && this.options.ignoreNamespaceFragment) {\n              elNamespace = elNamespace.split('#')[0];\n            }\n\n            return elNamespace;\n          },\n\n          /** PrivateFunction: namespaceMatch\n           *  Tests if a stanza matches the namespace set for this Strophe.Handler.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - The XML element to test.\n           *\n           *  Returns:\n           *    true if the stanza matches and false otherwise.\n           */\n          namespaceMatch: function namespaceMatch(elem) {\n            var _this = this;\n\n            var nsMatch = false;\n\n            if (!this.ns) {\n              return true;\n            } else {\n              Strophe.forEachChild(elem, null, function (elem) {\n                if (_this.getNamespace(elem) === _this.ns) {\n                  nsMatch = true;\n                }\n              });\n              return nsMatch || this.getNamespace(elem) === this.ns;\n            }\n          },\n\n          /** PrivateFunction: isMatch\n           *  Tests if a stanza matches the Strophe.Handler.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - The XML element to test.\n           *\n           *  Returns:\n           *    true if the stanza matches and false otherwise.\n           */\n          isMatch: function isMatch(elem) {\n            var from = elem.getAttribute('from');\n\n            if (this.options.matchBareFromJid) {\n              from = Strophe.getBareJidFromJid(from);\n            }\n\n            var elem_type = elem.getAttribute(\"type\");\n\n            if (this.namespaceMatch(elem) && (!this.name || Strophe.isTagEqual(elem, this.name)) && (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) !== -1 : elem_type === this.type)) && (!this.id || elem.getAttribute(\"id\") === this.id) && (!this.from || from === this.from)) {\n              return true;\n            }\n\n            return false;\n          },\n\n          /** PrivateFunction: run\n           *  Run the callback on a matching stanza.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - The DOM element that triggered the\n           *      Strophe.Handler.\n           *\n           *  Returns:\n           *    A boolean indicating if the handler should remain active.\n           */\n          run: function run(elem) {\n            var result = null;\n\n            try {\n              result = this.handler(elem);\n            } catch (e) {\n              Strophe._handleError(e);\n\n              throw e;\n            }\n\n            return result;\n          },\n\n          /** PrivateFunction: toString\n           *  Get a String representation of the Strophe.Handler object.\n           *\n           *  Returns:\n           *    A String.\n           */\n          toString: function toString() {\n            return \"{Handler: \" + this.handler + \"(\" + this.name + \",\" + this.id + \",\" + this.ns + \")}\";\n          }\n        };\n        /** PrivateClass: Strophe.TimedHandler\n         *  _Private_ helper class for managing timed handlers.\n         *\n         *  A Strophe.TimedHandler encapsulates a user provided callback that\n         *  should be called after a certain period of time or at regular\n         *  intervals.  The return value of the callback determines whether the\n         *  Strophe.TimedHandler will continue to fire.\n         *\n         *  Users will not use Strophe.TimedHandler objects directly, but instead\n         *  they will use Strophe.Connection.addTimedHandler() and\n         *  Strophe.Connection.deleteTimedHandler().\n         */\n\n        /** PrivateConstructor: Strophe.TimedHandler\n         *  Create and initialize a new Strophe.TimedHandler object.\n         *\n         *  Parameters:\n         *    (Integer) period - The number of milliseconds to wait before the\n         *      handler is called.\n         *    (Function) handler - The callback to run when the handler fires.  This\n         *      function should take no arguments.\n         *\n         *  Returns:\n         *    A new Strophe.TimedHandler object.\n         */\n\n        Strophe.TimedHandler = function (period, handler) {\n          this.period = period;\n          this.handler = handler;\n          this.lastCalled = new Date().getTime();\n          this.user = true;\n        };\n\n        Strophe.TimedHandler.prototype = {\n          /** PrivateFunction: run\n           *  Run the callback for the Strophe.TimedHandler.\n           *\n           *  Returns:\n           *    true if the Strophe.TimedHandler should be called again, and false\n           *      otherwise.\n           */\n          run: function run() {\n            this.lastCalled = new Date().getTime();\n            return this.handler();\n          },\n\n          /** PrivateFunction: reset\n           *  Reset the last called time for the Strophe.TimedHandler.\n           */\n          reset: function reset() {\n            this.lastCalled = new Date().getTime();\n          },\n\n          /** PrivateFunction: toString\n           *  Get a string representation of the Strophe.TimedHandler object.\n           *\n           *  Returns:\n           *    The string representation.\n           */\n          toString: function toString() {\n            return \"{TimedHandler: \" + this.handler + \"(\" + this.period + \")}\";\n          }\n        };\n        /** Class: Strophe.Connection\n         *  XMPP Connection manager.\n         *\n         *  This class is the main part of Strophe.  It manages a BOSH or websocket\n         *  connection to an XMPP server and dispatches events to the user callbacks\n         *  as data arrives. It supports SASL PLAIN, SASL DIGEST-MD5, SASL SCRAM-SHA1\n         *  and legacy authentication.\n         *\n         *  After creating a Strophe.Connection object, the user will typically\n         *  call connect() with a user supplied callback to handle connection level\n         *  events like authentication failure, disconnection, or connection\n         *  complete.\n         *\n         *  The user will also have several event handlers defined by using\n         *  addHandler() and addTimedHandler().  These will allow the user code to\n         *  respond to interesting stanzas or do something periodically with the\n         *  connection. These handlers will be active once authentication is\n         *  finished.\n         *\n         *  To send data to the connection, use send().\n         */\n\n        /** Constructor: Strophe.Connection\n         *  Create and initialize a Strophe.Connection object.\n         *\n         *  The transport-protocol for this connection will be chosen automatically\n         *  based on the given service parameter. URLs starting with \"ws://\" or\n         *  \"wss://\" will use WebSockets, URLs starting with \"http://\", \"https://\"\n         *  or without a protocol will use BOSH.\n         *\n         *  To make Strophe connect to the current host you can leave out the protocol\n         *  and host part and just pass the path, e.g.\n         *\n         *  > let conn = new Strophe.Connection(\"/http-bind/\");\n         *\n         *  Options common to both Websocket and BOSH:\n         *  ------------------------------------------\n         *\n         *  cookies:\n         *\n         *  The *cookies* option allows you to pass in cookies to be added to the\n         *  document. These cookies will then be included in the BOSH XMLHttpRequest\n         *  or in the websocket connection.\n         *\n         *  The passed in value must be a map of cookie names and string values.\n         *\n         *  > { \"myCookie\": {\n         *  >     \"value\": \"1234\",\n         *  >     \"domain\": \".example.org\",\n         *  >     \"path\": \"/\",\n         *  >     \"expires\": expirationDate\n         *  >     }\n         *  > }\n         *\n         *  Note that cookies can't be set in this way for other domains (i.e. cross-domain).\n         *  Those cookies need to be set under those domains, for example they can be\n         *  set server-side by making a XHR call to that domain to ask it to set any\n         *  necessary cookies.\n         *\n         *  mechanisms:\n         *\n         *  The *mechanisms* option allows you to specify the SASL mechanisms that this\n         *  instance of Strophe.Connection (and therefore your XMPP client) will\n         *  support.\n         *\n         *  The value must be an array of objects with Strophe.SASLMechanism\n         *  prototypes.\n         *\n         *  If nothing is specified, then the following mechanisms (and their\n         *  priorities) are registered:\n         *\n         *      SCRAM-SHA1 - 70\n         *      DIGEST-MD5 - 60\n         *      PLAIN - 50\n         *      OAUTH-BEARER - 40\n         *      OAUTH-2 - 30\n         *      ANONYMOUS - 20\n         *      EXTERNAL - 10\n         *\n         *  WebSocket options:\n         *  ------------------\n         *\n         *  If you want to connect to the current host with a WebSocket connection you\n         *  can tell Strophe to use WebSockets through a \"protocol\" attribute in the\n         *  optional options parameter. Valid values are \"ws\" for WebSocket and \"wss\"\n         *  for Secure WebSocket.\n         *  So to connect to \"wss://CURRENT_HOSTNAME/xmpp-websocket\" you would call\n         *\n         *  > let conn = new Strophe.Connection(\"/xmpp-websocket/\", {protocol: \"wss\"});\n         *\n         *  Note that relative URLs _NOT_ starting with a \"/\" will also include the path\n         *  of the current site.\n         *\n         *  Also because downgrading security is not permitted by browsers, when using\n         *  relative URLs both BOSH and WebSocket connections will use their secure\n         *  variants if the current connection to the site is also secure (https).\n         *\n         *  BOSH options:\n         *  -------------\n         *\n         *  By adding \"sync\" to the options, you can control if requests will\n         *  be made synchronously or not. The default behaviour is asynchronous.\n         *  If you want to make requests synchronous, make \"sync\" evaluate to true.\n         *  > let conn = new Strophe.Connection(\"/http-bind/\", {sync: true});\n         *\n         *  You can also toggle this on an already established connection.\n         *  > conn.options.sync = true;\n         *\n         *  The *customHeaders* option can be used to provide custom HTTP headers to be\n         *  included in the XMLHttpRequests made.\n         *\n         *  The *keepalive* option can be used to instruct Strophe to maintain the\n         *  current BOSH session across interruptions such as webpage reloads.\n         *\n         *  It will do this by caching the sessions tokens in sessionStorage, and when\n         *  \"restore\" is called it will check whether there are cached tokens with\n         *  which it can resume an existing session.\n         *\n         *  The *withCredentials* option should receive a Boolean value and is used to\n         *  indicate wether cookies should be included in ajax requests (by default\n         *  they're not).\n         *  Set this value to true if you are connecting to a BOSH service\n         *  and for some reason need to send cookies to it.\n         *  In order for this to work cross-domain, the server must also enable\n         *  credentials by setting the Access-Control-Allow-Credentials response header\n         *  to \"true\". For most usecases however this setting should be false (which\n         *  is the default).\n         *  Additionally, when using Access-Control-Allow-Credentials, the\n         *  Access-Control-Allow-Origin header can't be set to the wildcard \"*\", but\n         *  instead must be restricted to actual domains.\n         *\n         *  The *contentType* option can be set to change the default Content-Type\n         *  of \"text/xml; charset=utf-8\", which can be useful to reduce the amount of\n         *  CORS preflight requests that are sent to the server.\n         *\n         *  Parameters:\n         *    (String) service - The BOSH or WebSocket service URL.\n         *    (Object) options - A hash of configuration options\n         *\n         *  Returns:\n         *    A new Strophe.Connection object.\n         */\n\n        Strophe.Connection = function (service, options) {\n          var _this2 = this; // The service URL\n\n\n          this.service = service; // Configuration options\n\n          this.options = options || {};\n          var proto = this.options.protocol || \"\"; // Select protocal based on service or options\n\n          if (service.indexOf(\"ws:\") === 0 || service.indexOf(\"wss:\") === 0 || proto.indexOf(\"ws\") === 0) {\n            this._proto = new Strophe.Websocket(this);\n          } else {\n            this._proto = new Strophe.Bosh(this);\n          }\n          /* The connected JID. */\n\n\n          this.jid = \"\";\n          /* the JIDs domain */\n\n          this.domain = null;\n          /* stream:features */\n\n          this.features = null; // SASL\n\n          this._sasl_data = {};\n          this.do_session = false;\n          this.do_bind = false; // handler lists\n\n          this.timedHandlers = [];\n          this.handlers = [];\n          this.removeTimeds = [];\n          this.removeHandlers = [];\n          this.addTimeds = [];\n          this.addHandlers = [];\n          this.protocolErrorHandlers = {\n            'HTTP': {},\n            'websocket': {}\n          };\n          this._idleTimeout = null;\n          this._disconnectTimeout = null;\n          this.authenticated = false;\n          this.connected = false;\n          this.disconnecting = false;\n          this.do_authentication = true;\n          this.paused = false;\n          this.restored = false;\n          this._data = [];\n          this._uniqueId = 0;\n          this._sasl_success_handler = null;\n          this._sasl_failure_handler = null;\n          this._sasl_challenge_handler = null; // Max retries before disconnecting\n\n          this.maxRetries = 5; // Call onIdle callback every 1/10th of a second\n\n          this._idleTimeout = setTimeout(function () {\n            return _this2._onIdle();\n          }, 100);\n          utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].addCookies(this.options.cookies);\n          this.registerSASLMechanisms(this.options.mechanisms); // initialize plugins\n\n          for (var k in Strophe._connectionPlugins) {\n            if (Object.prototype.hasOwnProperty.call(Strophe._connectionPlugins, k)) {\n              var F = function F() {};\n\n              F.prototype = Strophe._connectionPlugins[k];\n              this[k] = new F();\n              this[k].init(this);\n            }\n          }\n        };\n\n        Strophe.Connection.prototype = {\n          /** Function: reset\n           *  Reset the connection.\n           *\n           *  This function should be called after a connection is disconnected\n           *  before that connection is reused.\n           */\n          reset: function reset() {\n            this._proto._reset(); // SASL\n\n\n            this.do_session = false;\n            this.do_bind = false; // handler lists\n\n            this.timedHandlers = [];\n            this.handlers = [];\n            this.removeTimeds = [];\n            this.removeHandlers = [];\n            this.addTimeds = [];\n            this.addHandlers = [];\n            this.authenticated = false;\n            this.connected = false;\n            this.disconnecting = false;\n            this.restored = false;\n            this._data = [];\n            this._requests = [];\n            this._uniqueId = 0;\n          },\n\n          /** Function: pause\n           *  Pause the request manager.\n           *\n           *  This will prevent Strophe from sending any more requests to the\n           *  server.  This is very useful for temporarily pausing\n           *  BOSH-Connections while a lot of send() calls are happening quickly.\n           *  This causes Strophe to send the data in a single request, saving\n           *  many request trips.\n           */\n          pause: function pause() {\n            this.paused = true;\n          },\n\n          /** Function: resume\n           *  Resume the request manager.\n           *\n           *  This resumes after pause() has been called.\n           */\n          resume: function resume() {\n            this.paused = false;\n          },\n\n          /** Function: getUniqueId\n           *  Generate a unique ID for use in <iq/> elements.\n           *\n           *  All <iq/> stanzas are required to have unique id attributes.  This\n           *  function makes creating these easy.  Each connection instance has\n           *  a counter which starts from zero, and the value of this counter\n           *  plus a colon followed by the suffix becomes the unique id. If no\n           *  suffix is supplied, the counter is used as the unique id.\n           *\n           *  Suffixes are used to make debugging easier when reading the stream\n           *  data, and their use is recommended.  The counter resets to 0 for\n           *  every new connection for the same reason.  For connections to the\n           *  same server that authenticate the same way, all the ids should be\n           *  the same, which makes it easy to see changes.  This is useful for\n           *  automated testing as well.\n           *\n           *  Parameters:\n           *    (String) suffix - A optional suffix to append to the id.\n           *\n           *  Returns:\n           *    A unique string to be used for the id attribute.\n           */\n          getUniqueId: function getUniqueId(suffix) {\n            var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n              var r = Math.random() * 16 | 0,\n                  v = c === 'x' ? r : r & 0x3 | 0x8;\n              return v.toString(16);\n            });\n\n            if (typeof suffix === \"string\" || typeof suffix === \"number\") {\n              return uuid + \":\" + suffix;\n            } else {\n              return uuid + \"\";\n            }\n          },\n\n          /** Function: addProtocolErrorHandler\n           *  Register a handler function for when a protocol (websocker or HTTP)\n           *  error occurs.\n           *\n           *  NOTE: Currently only HTTP errors for BOSH requests are handled.\n           *  Patches that handle websocket errors would be very welcome.\n           *\n           *  Parameters:\n           *    (String) protocol - 'HTTP' or 'websocket'\n           *    (Integer) status_code - Error status code (e.g 500, 400 or 404)\n           *    (Function) callback - Function that will fire on Http error\n           *\n           *  Example:\n           *  function onError(err_code){\n           *    //do stuff\n           *  }\n           *\n           *  let conn = Strophe.connect('http://example.com/http-bind');\n           *  conn.addProtocolErrorHandler('HTTP', 500, onError);\n           *  // Triggers HTTP 500 error and onError handler will be called\n           *  conn.connect('user_jid@incorrect_jabber_host', 'secret', onConnect);\n           */\n          addProtocolErrorHandler: function addProtocolErrorHandler(protocol, status_code, callback) {\n            this.protocolErrorHandlers[protocol][status_code] = callback;\n          },\n\n          /** Function: connect\n           *  Starts the connection process.\n           *\n           *  As the connection process proceeds, the user supplied callback will\n           *  be triggered multiple times with status updates.  The callback\n           *  should take two arguments - the status code and the error condition.\n           *\n           *  The status code will be one of the values in the Strophe.Status\n           *  constants.  The error condition will be one of the conditions\n           *  defined in RFC 3920 or the condition 'strophe-parsererror'.\n           *\n           *  The Parameters _wait_, _hold_ and _route_ are optional and only relevant\n           *  for BOSH connections. Please see XEP 124 for a more detailed explanation\n           *  of the optional parameters.\n           *\n           *  Parameters:\n           *    (String) jid - The user's JID.  This may be a bare JID,\n           *      or a full JID.  If a node is not supplied, SASL OAUTHBEARER or\n           *      SASL ANONYMOUS authentication will be attempted (OAUTHBEARER will\n           *      process the provided password value as an access token).\n           *    (String) pass - The user's password.\n           *    (Function) callback - The connect callback function.\n           *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n           *      time the server will wait before returning an empty result for\n           *      a request.  The default setting of 60 seconds is recommended.\n           *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n           *      number of connections the server will hold at one time.  This\n           *      should almost always be set to 1 (the default).\n           *    (String) route - The optional route value.\n           *    (String) authcid - The optional alternative authentication identity\n           *      (username) if intending to impersonate another user.\n           *      When using the SASL-EXTERNAL authentication mechanism, for example\n           *      with client certificates, then the authcid value is used to\n           *      determine whether an authorization JID (authzid) should be sent to\n           *      the server. The authzid should not be sent to the server if the\n           *      authzid and authcid are the same. So to prevent it from being sent\n           *      (for example when the JID is already contained in the client\n           *      certificate), set authcid to that same JID. See XEP-178 for more\n           *      details.\n           */\n          connect: function connect(jid, pass, callback, wait, hold, route, authcid) {\n            this.jid = jid;\n            /** Variable: authzid\n             *  Authorization identity.\n             */\n\n            this.authzid = Strophe.getBareJidFromJid(this.jid);\n            /** Variable: authcid\n             *  Authentication identity (User name).\n             */\n\n            this.authcid = authcid || Strophe.getNodeFromJid(this.jid);\n            /** Variable: pass\n             *  Authentication identity (User password).\n             */\n\n            this.pass = pass;\n            /** Variable: servtype\n             *  Digest MD5 compatibility.\n             */\n\n            this.servtype = \"xmpp\";\n            this.connect_callback = callback;\n            this.disconnecting = false;\n            this.connected = false;\n            this.authenticated = false;\n            this.restored = false; // parse jid for domain\n\n            this.domain = Strophe.getDomainFromJid(this.jid);\n\n            this._changeConnectStatus(Strophe.Status.CONNECTING, null);\n\n            this._proto._connect(wait, hold, route);\n          },\n\n          /** Function: attach\n           *  Attach to an already created and authenticated BOSH session.\n           *\n           *  This function is provided to allow Strophe to attach to BOSH\n           *  sessions which have been created externally, perhaps by a Web\n           *  application.  This is often used to support auto-login type features\n           *  without putting user credentials into the page.\n           *\n           *  Parameters:\n           *    (String) jid - The full JID that is bound by the session.\n           *    (String) sid - The SID of the BOSH session.\n           *    (String) rid - The current RID of the BOSH session.  This RID\n           *      will be used by the next request.\n           *    (Function) callback The connect callback function.\n           *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n           *      time the server will wait before returning an empty result for\n           *      a request.  The default setting of 60 seconds is recommended.\n           *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n           *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n           *      number of connections the server will hold at one time.  This\n           *      should almost always be set to 1 (the default).\n           *    (Integer) wind - The optional HTTBIND window value.  This is the\n           *      allowed range of request ids that are valid.  The default is 5.\n           */\n          attach: function attach(jid, sid, rid, callback, wait, hold, wind) {\n            if (this._proto instanceof Strophe.Bosh) {\n              this._proto._attach(jid, sid, rid, callback, wait, hold, wind);\n            } else {\n              var error = new Error('The \"attach\" method can only be used with a BOSH connection.');\n              error.name = 'StropheSessionError';\n              throw error;\n            }\n          },\n\n          /** Function: restore\n           *  Attempt to restore a cached BOSH session.\n           *\n           *  This function is only useful in conjunction with providing the\n           *  \"keepalive\":true option when instantiating a new Strophe.Connection.\n           *\n           *  When \"keepalive\" is set to true, Strophe will cache the BOSH tokens\n           *  RID (Request ID) and SID (Session ID) and then when this function is\n           *  called, it will attempt to restore the session from those cached\n           *  tokens.\n           *\n           *  This function must therefore be called instead of connect or attach.\n           *\n           *  For an example on how to use it, please see examples/restore.js\n           *\n           *  Parameters:\n           *    (String) jid - The user's JID.  This may be a bare JID or a full JID.\n           *    (Function) callback - The connect callback function.\n           *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n           *      time the server will wait before returning an empty result for\n           *      a request.  The default setting of 60 seconds is recommended.\n           *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n           *      number of connections the server will hold at one time.  This\n           *      should almost always be set to 1 (the default).\n           *    (Integer) wind - The optional HTTBIND window value.  This is the\n           *      allowed range of request ids that are valid.  The default is 5.\n           */\n          restore: function restore(jid, callback, wait, hold, wind) {\n            if (this._sessionCachingSupported()) {\n              this._proto._restore(jid, callback, wait, hold, wind);\n            } else {\n              var error = new Error('The \"restore\" method can only be used with a BOSH connection.');\n              error.name = 'StropheSessionError';\n              throw error;\n            }\n          },\n\n          /** PrivateFunction: _sessionCachingSupported\n           * Checks whether sessionStorage and JSON are supported and whether we're\n           * using BOSH.\n           */\n          _sessionCachingSupported: function _sessionCachingSupported() {\n            if (this._proto instanceof Strophe.Bosh) {\n              if (!JSON) {\n                return false;\n              }\n\n              try {\n                sessionStorage.setItem('_strophe_', '_strophe_');\n                sessionStorage.removeItem('_strophe_');\n              } catch (e) {\n                return false;\n              }\n\n              return true;\n            }\n\n            return false;\n          },\n\n          /** Function: xmlInput\n           *  User overrideable function that receives XML data coming into the\n           *  connection.\n           *\n           *  The default function does nothing.  User code can override this with\n           *  > Strophe.Connection.xmlInput = function (elem) {\n           *  >   (user code)\n           *  > };\n           *\n           *  Due to limitations of current Browsers' XML-Parsers the opening and closing\n           *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.\n           *\n           *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See\n           *  <Strophe.Bosh.strip> if you want to strip this tag.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - The XML data received by the connection.\n           */\n\n          /* jshint unused:false */\n          xmlInput: function xmlInput(elem) {\n            return;\n          },\n\n          /* jshint unused:true */\n\n          /** Function: xmlOutput\n           *  User overrideable function that receives XML data sent to the\n           *  connection.\n           *\n           *  The default function does nothing.  User code can override this with\n           *  > Strophe.Connection.xmlOutput = function (elem) {\n           *  >   (user code)\n           *  > };\n           *\n           *  Due to limitations of current Browsers' XML-Parsers the opening and closing\n           *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.\n           *\n           *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See\n           *  <Strophe.Bosh.strip> if you want to strip this tag.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - The XMLdata sent by the connection.\n           */\n\n          /* jshint unused:false */\n          xmlOutput: function xmlOutput(elem) {\n            return;\n          },\n\n          /* jshint unused:true */\n\n          /** Function: rawInput\n           *  User overrideable function that receives raw data coming into the\n           *  connection.\n           *\n           *  The default function does nothing.  User code can override this with\n           *  > Strophe.Connection.rawInput = function (data) {\n           *  >   (user code)\n           *  > };\n           *\n           *  Parameters:\n           *    (String) data - The data received by the connection.\n           */\n\n          /* jshint unused:false */\n          rawInput: function rawInput(data) {\n            return;\n          },\n\n          /* jshint unused:true */\n\n          /** Function: rawOutput\n           *  User overrideable function that receives raw data sent to the\n           *  connection.\n           *\n           *  The default function does nothing.  User code can override this with\n           *  > Strophe.Connection.rawOutput = function (data) {\n           *  >   (user code)\n           *  > };\n           *\n           *  Parameters:\n           *    (String) data - The data sent by the connection.\n           */\n\n          /* jshint unused:false */\n          rawOutput: function rawOutput(data) {\n            return;\n          },\n\n          /* jshint unused:true */\n\n          /** Function: nextValidRid\n           *  User overrideable function that receives the new valid rid.\n           *\n           *  The default function does nothing. User code can override this with\n           *  > Strophe.Connection.nextValidRid = function (rid) {\n           *  >    (user code)\n           *  > };\n           *\n           *  Parameters:\n           *    (Number) rid - The next valid rid\n           */\n\n          /* jshint unused:false */\n          nextValidRid: function nextValidRid(rid) {\n            return;\n          },\n\n          /* jshint unused:true */\n\n          /** Function: send\n           *  Send a stanza.\n           *\n           *  This function is called to push data onto the send queue to\n           *  go out over the wire.  Whenever a request is sent to the BOSH\n           *  server, all pending data is sent and the queue is flushed.\n           *\n           *  Parameters:\n           *    (XMLElement |\n           *     [XMLElement] |\n           *     Strophe.Builder) elem - The stanza to send.\n           */\n          send: function send(elem) {\n            if (elem === null) {\n              return;\n            }\n\n            if (typeof elem.sort === \"function\") {\n              for (var i = 0; i < elem.length; i++) {\n                this._queueData(elem[i]);\n              }\n            } else if (typeof elem.tree === \"function\") {\n              this._queueData(elem.tree());\n            } else {\n              this._queueData(elem);\n            }\n\n            this._proto._send();\n          },\n\n          /** Function: flush\n           *  Immediately send any pending outgoing data.\n           *\n           *  Normally send() queues outgoing data until the next idle period\n           *  (100ms), which optimizes network use in the common cases when\n           *  several send()s are called in succession. flush() can be used to\n           *  immediately send all pending data.\n           */\n          flush: function flush() {\n            // cancel the pending idle period and run the idle function\n            // immediately\n            clearTimeout(this._idleTimeout);\n\n            this._onIdle();\n          },\n\n          /** Function: sendPresence\n           *  Helper function to send presence stanzas. The main benefit is for\n           *  sending presence stanzas for which you expect a responding presence\n           *  stanza with the same id (for example when leaving a chat room).\n           *\n           *  Parameters:\n           *    (XMLElement) elem - The stanza to send.\n           *    (Function) callback - The callback function for a successful request.\n           *    (Function) errback - The callback function for a failed or timed\n           *      out request.  On timeout, the stanza will be null.\n           *    (Integer) timeout - The time specified in milliseconds for a\n           *      timeout to occur.\n           *\n           *  Returns:\n           *    The id used to send the presence.\n           */\n          sendPresence: function sendPresence(elem, callback, errback, timeout) {\n            var _this3 = this;\n\n            var timeoutHandler = null;\n\n            if (typeof elem.tree === \"function\") {\n              elem = elem.tree();\n            }\n\n            var id = elem.getAttribute('id');\n\n            if (!id) {\n              // inject id if not found\n              id = this.getUniqueId(\"sendPresence\");\n              elem.setAttribute(\"id\", id);\n            }\n\n            if (typeof callback === \"function\" || typeof errback === \"function\") {\n              var handler = this.addHandler(function (stanza) {\n                // remove timeout handler if there is one\n                if (timeoutHandler) {\n                  _this3.deleteTimedHandler(timeoutHandler);\n                }\n\n                if (stanza.getAttribute('type') === 'error') {\n                  if (errback) {\n                    errback(stanza);\n                  }\n                } else if (callback) {\n                  callback(stanza);\n                }\n              }, null, 'presence', null, id); // if timeout specified, set up a timeout handler.\n\n              if (timeout) {\n                timeoutHandler = this.addTimedHandler(timeout, function () {\n                  // get rid of normal handler\n                  _this3.deleteHandler(handler); // call errback on timeout with null stanza\n\n\n                  if (errback) {\n                    errback(null);\n                  }\n\n                  return false;\n                });\n              }\n            }\n\n            this.send(elem);\n            return id;\n          },\n\n          /** Function: sendIQ\n           *  Helper function to send IQ stanzas.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - The stanza to send.\n           *    (Function) callback - The callback function for a successful request.\n           *    (Function) errback - The callback function for a failed or timed\n           *      out request.  On timeout, the stanza will be null.\n           *    (Integer) timeout - The time specified in milliseconds for a\n           *      timeout to occur.\n           *\n           *  Returns:\n           *    The id used to send the IQ.\n          */\n          sendIQ: function sendIQ(elem, callback, errback, timeout) {\n            var _this4 = this;\n\n            var timeoutHandler = null;\n\n            if (typeof elem.tree === \"function\") {\n              elem = elem.tree();\n            }\n\n            var id = elem.getAttribute('id');\n\n            if (!id) {\n              // inject id if not found\n              id = this.getUniqueId(\"sendIQ\");\n              elem.setAttribute(\"id\", id);\n            }\n\n            if (typeof callback === \"function\" || typeof errback === \"function\") {\n              var handler = this.addHandler(function (stanza) {\n                // remove timeout handler if there is one\n                if (timeoutHandler) {\n                  _this4.deleteTimedHandler(timeoutHandler);\n                }\n\n                var iqtype = stanza.getAttribute('type');\n\n                if (iqtype === 'result') {\n                  if (callback) {\n                    callback(stanza);\n                  }\n                } else if (iqtype === 'error') {\n                  if (errback) {\n                    errback(stanza);\n                  }\n                } else {\n                  var error = new Error(\"Got bad IQ type of \".concat(iqtype));\n                  error.name = \"StropheError\";\n                  throw error;\n                }\n              }, null, 'iq', ['error', 'result'], id); // if timeout specified, set up a timeout handler.\n\n              if (timeout) {\n                timeoutHandler = this.addTimedHandler(timeout, function () {\n                  // get rid of normal handler\n                  _this4.deleteHandler(handler); // call errback on timeout with null stanza\n\n\n                  if (errback) {\n                    errback(null);\n                  }\n\n                  return false;\n                });\n              }\n            }\n\n            this.send(elem);\n            return id;\n          },\n\n          /** PrivateFunction: _queueData\n           *  Queue outgoing data for later sending.  Also ensures that the data\n           *  is a DOMElement.\n           */\n          _queueData: function _queueData(element) {\n            if (element === null || !element.tagName || !element.childNodes) {\n              var error = new Error(\"Cannot queue non-DOMElement.\");\n              error.name = \"StropheError\";\n              throw error;\n            }\n\n            this._data.push(element);\n          },\n\n          /** PrivateFunction: _sendRestart\n           *  Send an xmpp:restart stanza.\n           */\n          _sendRestart: function _sendRestart() {\n            var _this5 = this;\n\n            this._data.push(\"restart\");\n\n            this._proto._sendRestart();\n\n            this._idleTimeout = setTimeout(function () {\n              return _this5._onIdle();\n            }, 100);\n          },\n\n          /** Function: addTimedHandler\n           *  Add a timed handler to the connection.\n           *\n           *  This function adds a timed handler.  The provided handler will\n           *  be called every period milliseconds until it returns false,\n           *  the connection is terminated, or the handler is removed.  Handlers\n           *  that wish to continue being invoked should return true.\n           *\n           *  Because of method binding it is necessary to save the result of\n           *  this function if you wish to remove a handler with\n           *  deleteTimedHandler().\n           *\n           *  Note that user handlers are not active until authentication is\n           *  successful.\n           *\n           *  Parameters:\n           *    (Integer) period - The period of the handler.\n           *    (Function) handler - The callback function.\n           *\n           *  Returns:\n           *    A reference to the handler that can be used to remove it.\n           */\n          addTimedHandler: function addTimedHandler(period, handler) {\n            var thand = new Strophe.TimedHandler(period, handler);\n            this.addTimeds.push(thand);\n            return thand;\n          },\n\n          /** Function: deleteTimedHandler\n           *  Delete a timed handler for a connection.\n           *\n           *  This function removes a timed handler from the connection.  The\n           *  handRef parameter is *not* the function passed to addTimedHandler(),\n           *  but is the reference returned from addTimedHandler().\n           *\n           *  Parameters:\n           *    (Strophe.TimedHandler) handRef - The handler reference.\n           */\n          deleteTimedHandler: function deleteTimedHandler(handRef) {\n            // this must be done in the Idle loop so that we don't change\n            // the handlers during iteration\n            this.removeTimeds.push(handRef);\n          },\n\n          /** Function: addHandler\n           *  Add a stanza handler for the connection.\n           *\n           *  This function adds a stanza handler to the connection.  The\n           *  handler callback will be called for any stanza that matches\n           *  the parameters.  Note that if multiple parameters are supplied,\n           *  they must all match for the handler to be invoked.\n           *\n           *  The handler will receive the stanza that triggered it as its argument.\n           *  *The handler should return true if it is to be invoked again;\n           *  returning false will remove the handler after it returns.*\n           *\n           *  As a convenience, the ns parameters applies to the top level element\n           *  and also any of its immediate children.  This is primarily to make\n           *  matching /iq/query elements easy.\n           *\n           *  Options\n           *  ~~~~~~~\n           *  With the options argument, you can specify boolean flags that affect how\n           *  matches are being done.\n           *\n           *  Currently two flags exist:\n           *\n           *  - matchBareFromJid:\n           *      When set to true, the from parameter and the\n           *      from attribute on the stanza will be matched as bare JIDs instead\n           *      of full JIDs. To use this, pass {matchBareFromJid: true} as the\n           *      value of options. The default value for matchBareFromJid is false.\n           *\n           *  - ignoreNamespaceFragment:\n           *      When set to true, a fragment specified on the stanza's namespace\n           *      URL will be ignored when it's matched with the one configured for\n           *      the handler.\n           *\n           *      This means that if you register like this:\n           *      >   connection.addHandler(\n           *      >       handler,\n           *      >       'http://jabber.org/protocol/muc',\n           *      >       null, null, null, null,\n           *      >       {'ignoreNamespaceFragment': true}\n           *      >   );\n           *\n           *      Then a stanza with XML namespace of\n           *      'http://jabber.org/protocol/muc#user' will also be matched. If\n           *      'ignoreNamespaceFragment' is false, then only stanzas with\n           *      'http://jabber.org/protocol/muc' will be matched.\n           *\n           *  Deleting the handler\n           *  ~~~~~~~~~~~~~~~~~~~~\n           *  The return value should be saved if you wish to remove the handler\n           *  with deleteHandler().\n           *\n           *  Parameters:\n           *    (Function) handler - The user callback.\n           *    (String) ns - The namespace to match.\n           *    (String) name - The stanza name to match.\n           *    (String|Array) type - The stanza type (or types if an array) to match.\n           *    (String) id - The stanza id attribute to match.\n           *    (String) from - The stanza from attribute to match.\n           *    (String) options - The handler options\n           *\n           *  Returns:\n           *    A reference to the handler that can be used to remove it.\n           */\n          addHandler: function addHandler(handler, ns, name, type, id, from, options) {\n            var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);\n            this.addHandlers.push(hand);\n            return hand;\n          },\n\n          /** Function: deleteHandler\n           *  Delete a stanza handler for a connection.\n           *\n           *  This function removes a stanza handler from the connection.  The\n           *  handRef parameter is *not* the function passed to addHandler(),\n           *  but is the reference returned from addHandler().\n           *\n           *  Parameters:\n           *    (Strophe.Handler) handRef - The handler reference.\n           */\n          deleteHandler: function deleteHandler(handRef) {\n            // this must be done in the Idle loop so that we don't change\n            // the handlers during iteration\n            this.removeHandlers.push(handRef); // If a handler is being deleted while it is being added,\n            // prevent it from getting added\n\n            var i = this.addHandlers.indexOf(handRef);\n\n            if (i >= 0) {\n              this.addHandlers.splice(i, 1);\n            }\n          },\n\n          /** Function: registerSASLMechanisms\n           *\n           * Register the SASL mechanisms which will be supported by this instance of\n           * Strophe.Connection (i.e. which this XMPP client will support).\n           *\n           *  Parameters:\n           *    (Array) mechanisms - Array of objects with Strophe.SASLMechanism prototypes\n           *\n           */\n          registerSASLMechanisms: function registerSASLMechanisms(mechanisms) {\n            this.mechanisms = {};\n            mechanisms = mechanisms || [Strophe.SASLAnonymous, Strophe.SASLExternal, Strophe.SASLMD5, Strophe.SASLOAuthBearer, Strophe.SASLXOAuth2, Strophe.SASLPlain, Strophe.SASLSHA1];\n            mechanisms.forEach(this.registerSASLMechanism.bind(this));\n          },\n\n          /** Function: registerSASLMechanism\n           *\n           * Register a single SASL mechanism, to be supported by this client.\n           *\n           *  Parameters:\n           *    (Object) mechanism - Object with a Strophe.SASLMechanism prototype\n           *\n           */\n          registerSASLMechanism: function registerSASLMechanism(mechanism) {\n            this.mechanisms[mechanism.prototype.name] = mechanism;\n          },\n\n          /** Function: disconnect\n           *  Start the graceful disconnection process.\n           *\n           *  This function starts the disconnection process.  This process starts\n           *  by sending unavailable presence and sending BOSH body of type\n           *  terminate.  A timeout handler makes sure that disconnection happens\n           *  even if the BOSH server does not respond.\n           *  If the Connection object isn't connected, at least tries to abort all pending requests\n           *  so the connection object won't generate successful requests (which were already opened).\n           *\n           *  The user supplied connection callback will be notified of the\n           *  progress as this process happens.\n           *\n           *  Parameters:\n           *    (String) reason - The reason the disconnect is occuring.\n           */\n          disconnect: function disconnect(reason) {\n            this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);\n\n            Strophe.warn(\"Disconnect was called because: \" + reason);\n\n            if (this.connected) {\n              var pres = false;\n              this.disconnecting = true;\n\n              if (this.authenticated) {\n                pres = $pres({\n                  'xmlns': Strophe.NS.CLIENT,\n                  'type': 'unavailable'\n                });\n              } // setup timeout handler\n\n\n              this._disconnectTimeout = this._addSysTimedHandler(3000, this._onDisconnectTimeout.bind(this));\n\n              this._proto._disconnect(pres);\n            } else {\n              Strophe.warn(\"Disconnect was called before Strophe connected to the server\");\n\n              this._proto._abortAllRequests();\n\n              this._doDisconnect();\n            }\n          },\n\n          /** PrivateFunction: _changeConnectStatus\n           *  _Private_ helper function that makes sure plugins and the user's\n           *  callback are notified of connection status changes.\n           *\n           *  Parameters:\n           *    (Integer) status - the new connection status, one of the values\n           *      in Strophe.Status\n           *    (String) condition - the error condition or null\n           *    (XMLElement) elem - The triggering stanza.\n           */\n          _changeConnectStatus: function _changeConnectStatus(status, condition, elem) {\n            // notify all plugins listening for status changes\n            for (var k in Strophe._connectionPlugins) {\n              if (Object.prototype.hasOwnProperty.call(Strophe._connectionPlugins, k)) {\n                var plugin = this[k];\n\n                if (plugin.statusChanged) {\n                  try {\n                    plugin.statusChanged(status, condition);\n                  } catch (err) {\n                    Strophe.error(\"\".concat(k, \" plugin caused an exception changing status: \").concat(err));\n                  }\n                }\n              }\n            } // notify the user's callback\n\n\n            if (this.connect_callback) {\n              try {\n                this.connect_callback(status, condition, elem);\n              } catch (e) {\n                Strophe._handleError(e);\n\n                Strophe.error(\"User connection callback caused an exception: \".concat(e));\n              }\n            }\n          },\n\n          /** PrivateFunction: _doDisconnect\n           *  _Private_ function to disconnect.\n           *\n           *  This is the last piece of the disconnection logic.  This resets the\n           *  connection and alerts the user's connection callback.\n           */\n          _doDisconnect: function _doDisconnect(condition) {\n            if (typeof this._idleTimeout === \"number\") {\n              clearTimeout(this._idleTimeout);\n            } // Cancel Disconnect Timeout\n\n\n            if (this._disconnectTimeout !== null) {\n              this.deleteTimedHandler(this._disconnectTimeout);\n              this._disconnectTimeout = null;\n            }\n\n            Strophe.debug(\"_doDisconnect was called\");\n\n            this._proto._doDisconnect();\n\n            this.authenticated = false;\n            this.disconnecting = false;\n            this.restored = false; // delete handlers\n\n            this.handlers = [];\n            this.timedHandlers = [];\n            this.removeTimeds = [];\n            this.removeHandlers = [];\n            this.addTimeds = [];\n            this.addHandlers = []; // tell the parent we disconnected\n\n            this._changeConnectStatus(Strophe.Status.DISCONNECTED, condition);\n\n            this.connected = false;\n          },\n\n          /** PrivateFunction: _dataRecv\n           *  _Private_ handler to processes incoming data from the the connection.\n           *\n           *  Except for _connect_cb handling the initial connection request,\n           *  this function handles the incoming data for all requests.  This\n           *  function also fires stanza handlers that match each incoming\n           *  stanza.\n           *\n           *  Parameters:\n           *    (Strophe.Request) req - The request that has data ready.\n           *    (string) req - The stanza a raw string (optiona).\n           */\n          _dataRecv: function _dataRecv(req, raw) {\n            var _this6 = this;\n\n            Strophe.debug(\"_dataRecv called\");\n\n            var elem = this._proto._reqToData(req);\n\n            if (elem === null) {\n              return;\n            }\n\n            if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {\n              if (elem.nodeName === this._proto.strip && elem.childNodes.length) {\n                this.xmlInput(elem.childNodes[0]);\n              } else {\n                this.xmlInput(elem);\n              }\n            }\n\n            if (this.rawInput !== Strophe.Connection.prototype.rawInput) {\n              if (raw) {\n                this.rawInput(raw);\n              } else {\n                this.rawInput(Strophe.serialize(elem));\n              }\n            } // remove handlers scheduled for deletion\n\n\n            while (this.removeHandlers.length > 0) {\n              var hand = this.removeHandlers.pop();\n              var i = this.handlers.indexOf(hand);\n\n              if (i >= 0) {\n                this.handlers.splice(i, 1);\n              }\n            } // add handlers scheduled for addition\n\n\n            while (this.addHandlers.length > 0) {\n              this.handlers.push(this.addHandlers.pop());\n            } // handle graceful disconnect\n\n\n            if (this.disconnecting && this._proto._emptyQueue()) {\n              this._doDisconnect();\n\n              return;\n            }\n\n            var type = elem.getAttribute(\"type\");\n\n            if (type !== null && type === \"terminate\") {\n              // Don't process stanzas that come in after disconnect\n              if (this.disconnecting) {\n                return;\n              } // an error occurred\n\n\n              var cond = elem.getAttribute(\"condition\");\n              var conflict = elem.getElementsByTagName(\"conflict\");\n\n              if (cond !== null) {\n                if (cond === \"remote-stream-error\" && conflict.length > 0) {\n                  cond = \"conflict\";\n                }\n\n                this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);\n              } else {\n                this._changeConnectStatus(Strophe.Status.CONNFAIL, Strophe.ErrorCondition.UNKOWN_REASON);\n              }\n\n              this._doDisconnect(cond);\n\n              return;\n            } // send each incoming stanza through the handler chain\n\n\n            Strophe.forEachChild(elem, null, function (child) {\n              // process handlers\n              var newList = _this6.handlers;\n              _this6.handlers = [];\n\n              for (var _i5 = 0; _i5 < newList.length; _i5++) {\n                var _hand = newList[_i5]; // encapsulate 'handler.run' not to lose the whole handler list if\n                // one of the handlers throws an exception\n\n                try {\n                  if (_hand.isMatch(child) && (_this6.authenticated || !_hand.user)) {\n                    if (_hand.run(child)) {\n                      _this6.handlers.push(_hand);\n                    }\n                  } else {\n                    _this6.handlers.push(_hand);\n                  }\n                } catch (e) {\n                  // if the handler throws an exception, we consider it as false\n                  Strophe.warn('Removing Strophe handlers due to uncaught exception: ' + e.message);\n                }\n              }\n            });\n          },\n\n          /** Attribute: mechanisms\n           *  SASL Mechanisms available for Connection.\n           */\n          mechanisms: {},\n\n          /** PrivateFunction: _connect_cb\n           *  _Private_ handler for initial connection request.\n           *\n           *  This handler is used to process the initial connection request\n           *  response from the BOSH server. It is used to set up authentication\n           *  handlers and start the authentication process.\n           *\n           *  SASL authentication will be attempted if available, otherwise\n           *  the code will fall back to legacy authentication.\n           *\n           *  Parameters:\n           *    (Strophe.Request) req - The current request.\n           *    (Function) _callback - low level (xmpp) connect callback function.\n           *      Useful for plugins with their own xmpp connect callback (when they\n           *      want to do something special).\n           */\n          _connect_cb: function _connect_cb(req, _callback, raw) {\n            Strophe.debug(\"_connect_cb was called\");\n            this.connected = true;\n            var bodyWrap;\n\n            try {\n              bodyWrap = this._proto._reqToData(req);\n            } catch (e) {\n              if (e.name !== Strophe.ErrorCondition.BAD_FORMAT) {\n                throw e;\n              }\n\n              this._changeConnectStatus(Strophe.Status.CONNFAIL, Strophe.ErrorCondition.BAD_FORMAT);\n\n              this._doDisconnect(Strophe.ErrorCondition.BAD_FORMAT);\n            }\n\n            if (!bodyWrap) {\n              return;\n            }\n\n            if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {\n              if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {\n                this.xmlInput(bodyWrap.childNodes[0]);\n              } else {\n                this.xmlInput(bodyWrap);\n              }\n            }\n\n            if (this.rawInput !== Strophe.Connection.prototype.rawInput) {\n              if (raw) {\n                this.rawInput(raw);\n              } else {\n                this.rawInput(Strophe.serialize(bodyWrap));\n              }\n            }\n\n            var conncheck = this._proto._connect_cb(bodyWrap);\n\n            if (conncheck === Strophe.Status.CONNFAIL) {\n              return;\n            } // Check for the stream:features tag\n\n\n            var hasFeatures;\n\n            if (bodyWrap.getElementsByTagNameNS) {\n              hasFeatures = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, \"features\").length > 0;\n            } else {\n              hasFeatures = bodyWrap.getElementsByTagName(\"stream:features\").length > 0 || bodyWrap.getElementsByTagName(\"features\").length > 0;\n            }\n\n            if (!hasFeatures) {\n              this._proto._no_auth_received(_callback);\n\n              return;\n            }\n\n            var matched = [];\n            var mechanisms = bodyWrap.getElementsByTagName(\"mechanism\");\n\n            if (mechanisms.length > 0) {\n              for (var i = 0; i < mechanisms.length; i++) {\n                var mech = Strophe.getText(mechanisms[i]);\n                if (this.mechanisms[mech]) matched.push(this.mechanisms[mech]);\n              }\n            }\n\n            if (matched.length === 0) {\n              if (bodyWrap.getElementsByTagName(\"auth\").length === 0) {\n                // There are no matching SASL mechanisms and also no legacy\n                // auth available.\n                this._proto._no_auth_received(_callback);\n\n                return;\n              }\n            }\n\n            if (this.do_authentication !== false) {\n              this.authenticate(matched);\n            }\n          },\n\n          /** Function: sortMechanismsByPriority\n           *\n           *  Sorts an array of objects with prototype SASLMechanism according to\n           *  their priorities.\n           *\n           *  Parameters:\n           *    (Array) mechanisms - Array of SASL mechanisms.\n           *\n           */\n          sortMechanismsByPriority: function sortMechanismsByPriority(mechanisms) {\n            // Sorting mechanisms according to priority.\n            for (var i = 0; i < mechanisms.length - 1; ++i) {\n              var higher = i;\n\n              for (var j = i + 1; j < mechanisms.length; ++j) {\n                if (mechanisms[j].prototype.priority > mechanisms[higher].prototype.priority) {\n                  higher = j;\n                }\n              }\n\n              if (higher !== i) {\n                var swap = mechanisms[i];\n                mechanisms[i] = mechanisms[higher];\n                mechanisms[higher] = swap;\n              }\n            }\n\n            return mechanisms;\n          },\n\n          /** PrivateFunction: _attemptSASLAuth\n           *\n           *  Iterate through an array of SASL mechanisms and attempt authentication\n           *  with the highest priority (enabled) mechanism.\n           *\n           *  Parameters:\n           *    (Array) mechanisms - Array of SASL mechanisms.\n           *\n           *  Returns:\n           *    (Boolean) mechanism_found - true or false, depending on whether a\n           *          valid SASL mechanism was found with which authentication could be\n           *          started.\n           */\n          _attemptSASLAuth: function _attemptSASLAuth(mechanisms) {\n            mechanisms = this.sortMechanismsByPriority(mechanisms || []);\n            var mechanism_found = false;\n\n            for (var i = 0; i < mechanisms.length; ++i) {\n              if (!mechanisms[i].prototype.test(this)) {\n                continue;\n              }\n\n              this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, \"success\", null, null);\n              this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, \"failure\", null, null);\n              this._sasl_challenge_handler = this._addSysHandler(this._sasl_challenge_cb.bind(this), null, \"challenge\", null, null);\n              this._sasl_mechanism = new mechanisms[i]();\n\n              this._sasl_mechanism.onStart(this);\n\n              var request_auth_exchange = $build(\"auth\", {\n                'xmlns': Strophe.NS.SASL,\n                'mechanism': this._sasl_mechanism.name\n              });\n\n              if (this._sasl_mechanism.isClientFirst) {\n                var response = this._sasl_mechanism.onChallenge(this, null);\n\n                request_auth_exchange.t(btoa(response));\n              }\n\n              this.send(request_auth_exchange.tree());\n              mechanism_found = true;\n              break;\n            }\n\n            return mechanism_found;\n          },\n\n          /** PrivateFunction: _attemptLegacyAuth\n           *\n           *  Attempt legacy (i.e. non-SASL) authentication.\n           *\n           */\n          _attemptLegacyAuth: function _attemptLegacyAuth() {\n            if (Strophe.getNodeFromJid(this.jid) === null) {\n              // we don't have a node, which is required for non-anonymous\n              // client connections\n              this._changeConnectStatus(Strophe.Status.CONNFAIL, Strophe.ErrorCondition.MISSING_JID_NODE);\n\n              this.disconnect(Strophe.ErrorCondition.MISSING_JID_NODE);\n            } else {\n              // Fall back to legacy authentication\n              this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);\n\n              this._addSysHandler(this._auth1_cb.bind(this), null, null, null, \"_auth_1\");\n\n              this.send($iq({\n                'type': \"get\",\n                'to': this.domain,\n                'id': \"_auth_1\"\n              }).c(\"query\", {\n                xmlns: Strophe.NS.AUTH\n              }).c(\"username\", {}).t(Strophe.getNodeFromJid(this.jid)).tree());\n            }\n          },\n\n          /** Function: authenticate\n           * Set up authentication\n           *\n           *  Continues the initial connection request by setting up authentication\n           *  handlers and starting the authentication process.\n           *\n           *  SASL authentication will be attempted if available, otherwise\n           *  the code will fall back to legacy authentication.\n           *\n           *  Parameters:\n           *    (Array) matched - Array of SASL mechanisms supported.\n           *\n           */\n          authenticate: function authenticate(matched) {\n            if (!this._attemptSASLAuth(matched)) {\n              this._attemptLegacyAuth();\n            }\n          },\n\n          /** PrivateFunction: _sasl_challenge_cb\n           *  _Private_ handler for the SASL challenge\n           *\n           */\n          _sasl_challenge_cb: function _sasl_challenge_cb(elem) {\n            var challenge = atob(Strophe.getText(elem));\n\n            var response = this._sasl_mechanism.onChallenge(this, challenge);\n\n            var stanza = $build('response', {\n              'xmlns': Strophe.NS.SASL\n            });\n\n            if (response !== \"\") {\n              stanza.t(btoa(response));\n            }\n\n            this.send(stanza.tree());\n            return true;\n          },\n\n          /** PrivateFunction: _auth1_cb\n           *  _Private_ handler for legacy authentication.\n           *\n           *  This handler is called in response to the initial <iq type='get'/>\n           *  for legacy authentication.  It builds an authentication <iq/> and\n           *  sends it, creating a handler (calling back to _auth2_cb()) to\n           *  handle the result\n           *\n           *  Parameters:\n           *    (XMLElement) elem - The stanza that triggered the callback.\n           *\n           *  Returns:\n           *    false to remove the handler.\n           */\n\n          /* jshint unused:false */\n          _auth1_cb: function _auth1_cb(elem) {\n            // build plaintext auth iq\n            var iq = $iq({\n              type: \"set\",\n              id: \"_auth_2\"\n            }).c('query', {\n              xmlns: Strophe.NS.AUTH\n            }).c('username', {}).t(Strophe.getNodeFromJid(this.jid)).up().c('password').t(this.pass);\n\n            if (!Strophe.getResourceFromJid(this.jid)) {\n              // since the user has not supplied a resource, we pick\n              // a default one here.  unlike other auth methods, the server\n              // cannot do this for us.\n              this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';\n            }\n\n            iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));\n\n            this._addSysHandler(this._auth2_cb.bind(this), null, null, null, \"_auth_2\");\n\n            this.send(iq.tree());\n            return false;\n          },\n\n          /* jshint unused:true */\n\n          /** PrivateFunction: _sasl_success_cb\n           *  _Private_ handler for succesful SASL authentication.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - The matching stanza.\n           *\n           *  Returns:\n           *    false to remove the handler.\n           */\n          _sasl_success_cb: function _sasl_success_cb(elem) {\n            var _this7 = this;\n\n            if (this._sasl_data[\"server-signature\"]) {\n              var serverSignature;\n              var success = atob(Strophe.getText(elem));\n              var attribMatch = /([a-z]+)=([^,]+)(,|$)/;\n              var matches = success.match(attribMatch);\n\n              if (matches[1] === \"v\") {\n                serverSignature = matches[2];\n              }\n\n              if (serverSignature !== this._sasl_data[\"server-signature\"]) {\n                // remove old handlers\n                this.deleteHandler(this._sasl_failure_handler);\n                this._sasl_failure_handler = null;\n\n                if (this._sasl_challenge_handler) {\n                  this.deleteHandler(this._sasl_challenge_handler);\n                  this._sasl_challenge_handler = null;\n                }\n\n                this._sasl_data = {};\n                return this._sasl_failure_cb(null);\n              }\n            }\n\n            Strophe.info(\"SASL authentication succeeded.\");\n\n            if (this._sasl_mechanism) {\n              this._sasl_mechanism.onSuccess();\n            } // remove old handlers\n\n\n            this.deleteHandler(this._sasl_failure_handler);\n            this._sasl_failure_handler = null;\n\n            if (this._sasl_challenge_handler) {\n              this.deleteHandler(this._sasl_challenge_handler);\n              this._sasl_challenge_handler = null;\n            }\n\n            var streamfeature_handlers = [];\n\n            var wrapper = function wrapper(handlers, elem) {\n              while (handlers.length) {\n                _this7.deleteHandler(handlers.pop());\n              }\n\n              _this7._sasl_auth1_cb(elem);\n\n              return false;\n            };\n\n            streamfeature_handlers.push(this._addSysHandler(function (elem) {\n              return wrapper(streamfeature_handlers, elem);\n            }, null, \"stream:features\", null, null));\n            streamfeature_handlers.push(this._addSysHandler(function (elem) {\n              return wrapper(streamfeature_handlers, elem);\n            }, Strophe.NS.STREAM, \"features\", null, null)); // we must send an xmpp:restart now\n\n            this._sendRestart();\n\n            return false;\n          },\n\n          /** PrivateFunction: _sasl_auth1_cb\n           *  _Private_ handler to start stream binding.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - The matching stanza.\n           *\n           *  Returns:\n           *    false to remove the handler.\n           */\n          _sasl_auth1_cb: function _sasl_auth1_cb(elem) {\n            // save stream:features for future usage\n            this.features = elem;\n\n            for (var i = 0; i < elem.childNodes.length; i++) {\n              var child = elem.childNodes[i];\n\n              if (child.nodeName === 'bind') {\n                this.do_bind = true;\n              }\n\n              if (child.nodeName === 'session') {\n                this.do_session = true;\n              }\n            }\n\n            if (!this.do_bind) {\n              this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n\n              return false;\n            } else {\n              this._addSysHandler(this._sasl_bind_cb.bind(this), null, null, null, \"_bind_auth_2\");\n\n              var resource = Strophe.getResourceFromJid(this.jid);\n\n              if (resource) {\n                this.send($iq({\n                  type: \"set\",\n                  id: \"_bind_auth_2\"\n                }).c('bind', {\n                  xmlns: Strophe.NS.BIND\n                }).c('resource', {}).t(resource).tree());\n              } else {\n                this.send($iq({\n                  type: \"set\",\n                  id: \"_bind_auth_2\"\n                }).c('bind', {\n                  xmlns: Strophe.NS.BIND\n                }).tree());\n              }\n            }\n\n            return false;\n          },\n\n          /** PrivateFunction: _sasl_bind_cb\n           *  _Private_ handler for binding result and session start.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - The matching stanza.\n           *\n           *  Returns:\n           *    false to remove the handler.\n           */\n          _sasl_bind_cb: function _sasl_bind_cb(elem) {\n            if (elem.getAttribute(\"type\") === \"error\") {\n              Strophe.warn(\"SASL binding failed.\");\n              var conflict = elem.getElementsByTagName(\"conflict\");\n              var condition;\n\n              if (conflict.length > 0) {\n                condition = Strophe.ErrorCondition.CONFLICT;\n              }\n\n              this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition, elem);\n\n              return false;\n            } // TODO - need to grab errors\n\n\n            var bind = elem.getElementsByTagName(\"bind\");\n\n            if (bind.length > 0) {\n              var jidNode = bind[0].getElementsByTagName(\"jid\");\n\n              if (jidNode.length > 0) {\n                this.jid = Strophe.getText(jidNode[0]);\n\n                if (this.do_session) {\n                  this._addSysHandler(this._sasl_session_cb.bind(this), null, null, null, \"_session_auth_2\");\n\n                  this.send($iq({\n                    type: \"set\",\n                    id: \"_session_auth_2\"\n                  }).c('session', {\n                    xmlns: Strophe.NS.SESSION\n                  }).tree());\n                } else {\n                  this.authenticated = true;\n\n                  this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n                }\n              }\n            } else {\n              Strophe.warn(\"SASL binding failed.\");\n\n              this._changeConnectStatus(Strophe.Status.AUTHFAIL, null, elem);\n\n              return false;\n            }\n          },\n\n          /** PrivateFunction: _sasl_session_cb\n           *  _Private_ handler to finish successful SASL connection.\n           *\n           *  This sets Connection.authenticated to true on success, which\n           *  starts the processing of user handlers.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - The matching stanza.\n           *\n           *  Returns:\n           *    false to remove the handler.\n           */\n          _sasl_session_cb: function _sasl_session_cb(elem) {\n            if (elem.getAttribute(\"type\") === \"result\") {\n              this.authenticated = true;\n\n              this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n            } else if (elem.getAttribute(\"type\") === \"error\") {\n              Strophe.warn(\"Session creation failed.\");\n\n              this._changeConnectStatus(Strophe.Status.AUTHFAIL, null, elem);\n\n              return false;\n            }\n\n            return false;\n          },\n\n          /** PrivateFunction: _sasl_failure_cb\n           *  _Private_ handler for SASL authentication failure.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - The matching stanza.\n           *\n           *  Returns:\n           *    false to remove the handler.\n           */\n\n          /* jshint unused:false */\n          _sasl_failure_cb: function _sasl_failure_cb(elem) {\n            // delete unneeded handlers\n            if (this._sasl_success_handler) {\n              this.deleteHandler(this._sasl_success_handler);\n              this._sasl_success_handler = null;\n            }\n\n            if (this._sasl_challenge_handler) {\n              this.deleteHandler(this._sasl_challenge_handler);\n              this._sasl_challenge_handler = null;\n            }\n\n            if (this._sasl_mechanism) this._sasl_mechanism.onFailure();\n\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null, elem);\n\n            return false;\n          },\n\n          /* jshint unused:true */\n\n          /** PrivateFunction: _auth2_cb\n           *  _Private_ handler to finish legacy authentication.\n           *\n           *  This handler is called when the result from the jabber:iq:auth\n           *  <iq/> stanza is returned.\n           *\n           *  Parameters:\n           *    (XMLElement) elem - The stanza that triggered the callback.\n           *\n           *  Returns:\n           *    false to remove the handler.\n           */\n          _auth2_cb: function _auth2_cb(elem) {\n            if (elem.getAttribute(\"type\") === \"result\") {\n              this.authenticated = true;\n\n              this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n            } else if (elem.getAttribute(\"type\") === \"error\") {\n              this._changeConnectStatus(Strophe.Status.AUTHFAIL, null, elem);\n\n              this.disconnect('authentication failed');\n            }\n\n            return false;\n          },\n\n          /** PrivateFunction: _addSysTimedHandler\n           *  _Private_ function to add a system level timed handler.\n           *\n           *  This function is used to add a Strophe.TimedHandler for the\n           *  library code.  System timed handlers are allowed to run before\n           *  authentication is complete.\n           *\n           *  Parameters:\n           *    (Integer) period - The period of the handler.\n           *    (Function) handler - The callback function.\n           */\n          _addSysTimedHandler: function _addSysTimedHandler(period, handler) {\n            var thand = new Strophe.TimedHandler(period, handler);\n            thand.user = false;\n            this.addTimeds.push(thand);\n            return thand;\n          },\n\n          /** PrivateFunction: _addSysHandler\n           *  _Private_ function to add a system level stanza handler.\n           *\n           *  This function is used to add a Strophe.Handler for the\n           *  library code.  System stanza handlers are allowed to run before\n           *  authentication is complete.\n           *\n           *  Parameters:\n           *    (Function) handler - The callback function.\n           *    (String) ns - The namespace to match.\n           *    (String) name - The stanza name to match.\n           *    (String) type - The stanza type attribute to match.\n           *    (String) id - The stanza id attribute to match.\n           */\n          _addSysHandler: function _addSysHandler(handler, ns, name, type, id) {\n            var hand = new Strophe.Handler(handler, ns, name, type, id);\n            hand.user = false;\n            this.addHandlers.push(hand);\n            return hand;\n          },\n\n          /** PrivateFunction: _onDisconnectTimeout\n           *  _Private_ timeout handler for handling non-graceful disconnection.\n           *\n           *  If the graceful disconnect process does not complete within the\n           *  time allotted, this handler finishes the disconnect anyway.\n           *\n           *  Returns:\n           *    false to remove the handler.\n           */\n          _onDisconnectTimeout: function _onDisconnectTimeout() {\n            Strophe.debug(\"_onDisconnectTimeout was called\");\n\n            this._changeConnectStatus(Strophe.Status.CONNTIMEOUT, null);\n\n            this._proto._onDisconnectTimeout(); // actually disconnect\n\n\n            this._doDisconnect();\n\n            return false;\n          },\n\n          /** PrivateFunction: _onIdle\n           *  _Private_ handler to process events during idle cycle.\n           *\n           *  This handler is called every 100ms to fire timed handlers that\n           *  are ready and keep poll requests going.\n           */\n          _onIdle: function _onIdle() {\n            var _this8 = this; // add timed handlers scheduled for addition\n            // NOTE: we add before remove in the case a timed handler is\n            // added and then deleted before the next _onIdle() call.\n\n\n            while (this.addTimeds.length > 0) {\n              this.timedHandlers.push(this.addTimeds.pop());\n            } // remove timed handlers that have been scheduled for deletion\n\n\n            while (this.removeTimeds.length > 0) {\n              var thand = this.removeTimeds.pop();\n              var i = this.timedHandlers.indexOf(thand);\n\n              if (i >= 0) {\n                this.timedHandlers.splice(i, 1);\n              }\n            } // call ready timed handlers\n\n\n            var now = new Date().getTime();\n            var newList = [];\n\n            for (var _i6 = 0; _i6 < this.timedHandlers.length; _i6++) {\n              var _thand = this.timedHandlers[_i6];\n\n              if (this.authenticated || !_thand.user) {\n                var since = _thand.lastCalled + _thand.period;\n\n                if (since - now <= 0) {\n                  if (_thand.run()) {\n                    newList.push(_thand);\n                  }\n                } else {\n                  newList.push(_thand);\n                }\n              }\n            }\n\n            this.timedHandlers = newList;\n            clearTimeout(this._idleTimeout);\n\n            this._proto._onIdle(); // reactivate the timer only if connected\n\n\n            if (this.connected) {\n              this._idleTimeout = setTimeout(function () {\n                return _this8._onIdle();\n              }, 100);\n            }\n          }\n        };\n        /** Class: Strophe.SASLMechanism\n         *\n         *  encapsulates SASL authentication mechanisms.\n         *\n         *  User code may override the priority for each mechanism or disable it completely.\n         *  See <priority> for information about changing priority and <test> for informatian on\n         *  how to disable a mechanism.\n         *\n         *  By default, all mechanisms are enabled and the priorities are\n         *\n         *      OAUTHBEARER - 60\n         *      SCRAM-SHA1 - 50\n         *      DIGEST-MD5 - 40\n         *      PLAIN - 30\n         *      ANONYMOUS - 20\n         *      EXTERNAL - 10\n         *\n         *  See: Strophe.Connection.addSupportedSASLMechanisms\n         */\n\n        /**\n         * PrivateConstructor: Strophe.SASLMechanism\n         * SASL auth mechanism abstraction.\n         *\n         *  Parameters:\n         *    (String) name - SASL Mechanism name.\n         *    (Boolean) isClientFirst - If client should send response first without challenge.\n         *    (Number) priority - Priority.\n         *\n         *  Returns:\n         *    A new Strophe.SASLMechanism object.\n         */\n\n        Strophe.SASLMechanism = function (name, isClientFirst, priority) {\n          /** PrivateVariable: name\n           *  Mechanism name.\n           */\n          this.name = name;\n          /** PrivateVariable: isClientFirst\n           *  If client sends response without initial server challenge.\n           */\n\n          this.isClientFirst = isClientFirst;\n          /** Variable: priority\n           *  Determines which <SASLMechanism> is chosen for authentication (Higher is better).\n           *  Users may override this to prioritize mechanisms differently.\n           *\n           *  In the default configuration the priorities are\n           *\n           *  SCRAM-SHA1 - 40\n           *  DIGEST-MD5 - 30\n           *  Plain - 20\n           *\n           *  Example: (This will cause Strophe to choose the mechanism that the server sent first)\n           *\n           *  > Strophe.SASLMD5.priority = Strophe.SASLSHA1.priority;\n           *\n           *  See <SASL mechanisms> for a list of available mechanisms.\n           *\n           */\n\n          this.priority = priority;\n        };\n\n        Strophe.SASLMechanism.prototype = {\n          /**\n           *  Function: test\n           *  Checks if mechanism able to run.\n           *  To disable a mechanism, make this return false;\n           *\n           *  To disable plain authentication run\n           *  > Strophe.SASLPlain.test = function() {\n           *  >   return false;\n           *  > }\n           *\n           *  See <SASL mechanisms> for a list of available mechanisms.\n           *\n           *  Parameters:\n           *    (Strophe.Connection) connection - Target Connection.\n           *\n           *  Returns:\n           *    (Boolean) If mechanism was able to run.\n           */\n\n          /* jshint unused:false */\n          test: function test(connection) {\n            return true;\n          },\n\n          /* jshint unused:true */\n\n          /** PrivateFunction: onStart\n           *  Called before starting mechanism on some connection.\n           *\n           *  Parameters:\n           *    (Strophe.Connection) connection - Target Connection.\n           */\n          onStart: function onStart(connection) {\n            this._connection = connection;\n          },\n\n          /** PrivateFunction: onChallenge\n           *  Called by protocol implementation on incoming challenge. If client is\n           *  first (isClientFirst === true) challenge will be null on the first call.\n           *\n           *  Parameters:\n           *    (Strophe.Connection) connection - Target Connection.\n           *    (String) challenge - current challenge to handle.\n           *\n           *  Returns:\n           *    (String) Mechanism response.\n           */\n\n          /* jshint unused:false */\n          onChallenge: function onChallenge(connection, challenge) {\n            throw new Error(\"You should implement challenge handling!\");\n          },\n\n          /* jshint unused:true */\n\n          /** PrivateFunction: onFailure\n           *  Protocol informs mechanism implementation about SASL failure.\n           */\n          onFailure: function onFailure() {\n            this._connection = null;\n          },\n\n          /** PrivateFunction: onSuccess\n           *  Protocol informs mechanism implementation about SASL success.\n           */\n          onSuccess: function onSuccess() {\n            this._connection = null;\n          }\n        };\n        /** Constants: SASL mechanisms\n         *  Available authentication mechanisms\n         *\n         *  Strophe.SASLAnonymous - SASL ANONYMOUS authentication.\n         *  Strophe.SASLPlain - SASL PLAIN authentication.\n         *  Strophe.SASLMD5 - SASL DIGEST-MD5 authentication\n         *  Strophe.SASLSHA1 - SASL SCRAM-SHA1 authentication\n         *  Strophe.SASLOAuthBearer - SASL OAuth Bearer authentication\n         *  Strophe.SASLExternal - SASL EXTERNAL authentication\n         *  Strophe.SASLXOAuth2 - SASL X-OAuth2 authentication\n         */\n        // Building SASL callbacks\n\n        /** PrivateConstructor: SASLAnonymous\n         *  SASL ANONYMOUS authentication.\n         */\n\n        Strophe.SASLAnonymous = function () {};\n\n        Strophe.SASLAnonymous.prototype = new Strophe.SASLMechanism(\"ANONYMOUS\", false, 20);\n\n        Strophe.SASLAnonymous.prototype.test = function (connection) {\n          return connection.authcid === null;\n        };\n        /** PrivateConstructor: SASLPlain\n         *  SASL PLAIN authentication.\n         */\n\n\n        Strophe.SASLPlain = function () {};\n\n        Strophe.SASLPlain.prototype = new Strophe.SASLMechanism(\"PLAIN\", true, 50);\n\n        Strophe.SASLPlain.prototype.test = function (connection) {\n          return connection.authcid !== null;\n        };\n\n        Strophe.SASLPlain.prototype.onChallenge = function (connection) {\n          var auth_str = connection.authzid;\n          auth_str = auth_str + \"\\0\";\n          auth_str = auth_str + connection.authcid;\n          auth_str = auth_str + \"\\0\";\n          auth_str = auth_str + connection.pass;\n          return utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utf16to8(auth_str);\n        };\n        /** PrivateConstructor: SASLSHA1\n         *  SASL SCRAM SHA 1 authentication.\n         */\n\n\n        Strophe.SASLSHA1 = function () {};\n\n        Strophe.SASLSHA1.prototype = new Strophe.SASLMechanism(\"SCRAM-SHA-1\", true, 70);\n\n        Strophe.SASLSHA1.prototype.test = function (connection) {\n          return connection.authcid !== null;\n        };\n\n        Strophe.SASLSHA1.prototype.onChallenge = function (connection, challenge, test_cnonce) {\n          var cnonce = test_cnonce || md5__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hexdigest(\"\" + Math.random() * 1234567890);\n          var auth_str = \"n=\" + utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utf16to8(connection.authcid);\n          auth_str += \",r=\";\n          auth_str += cnonce;\n          connection._sasl_data.cnonce = cnonce;\n          connection._sasl_data[\"client-first-message-bare\"] = auth_str;\n          auth_str = \"n,,\" + auth_str;\n\n          this.onChallenge = function (connection, challenge) {\n            var nonce, salt, iter, Hi, U, U_old, i, k;\n            var responseText = \"c=biws,\";\n            var authMessage = \"\".concat(connection._sasl_data[\"client-first-message-bare\"], \",\").concat(challenge, \",\");\n            var cnonce = connection._sasl_data.cnonce;\n            var attribMatch = /([a-z]+)=([^,]+)(,|$)/;\n\n            while (challenge.match(attribMatch)) {\n              var matches = challenge.match(attribMatch);\n              challenge = challenge.replace(matches[0], \"\");\n\n              switch (matches[1]) {\n                case \"r\":\n                  nonce = matches[2];\n                  break;\n\n                case \"s\":\n                  salt = matches[2];\n                  break;\n\n                case \"i\":\n                  iter = matches[2];\n                  break;\n              }\n            }\n\n            if (nonce.substr(0, cnonce.length) !== cnonce) {\n              connection._sasl_data = {};\n              return connection._sasl_failure_cb();\n            }\n\n            responseText += \"r=\" + nonce;\n            authMessage += responseText;\n            salt = atob(salt);\n            salt += \"\\x00\\x00\\x00\\x01\";\n            var pass = utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utf16to8(connection.pass);\n            Hi = U_old = sha1__WEBPACK_IMPORTED_MODULE_1__[\"default\"].core_hmac_sha1(pass, salt);\n\n            for (i = 1; i < iter; i++) {\n              U = sha1__WEBPACK_IMPORTED_MODULE_1__[\"default\"].core_hmac_sha1(pass, sha1__WEBPACK_IMPORTED_MODULE_1__[\"default\"].binb2str(U_old));\n\n              for (k = 0; k < 5; k++) {\n                Hi[k] ^= U[k];\n              }\n\n              U_old = U;\n            }\n\n            Hi = sha1__WEBPACK_IMPORTED_MODULE_1__[\"default\"].binb2str(Hi);\n            var clientKey = sha1__WEBPACK_IMPORTED_MODULE_1__[\"default\"].core_hmac_sha1(Hi, \"Client Key\");\n            var serverKey = sha1__WEBPACK_IMPORTED_MODULE_1__[\"default\"].str_hmac_sha1(Hi, \"Server Key\");\n            var clientSignature = sha1__WEBPACK_IMPORTED_MODULE_1__[\"default\"].core_hmac_sha1(sha1__WEBPACK_IMPORTED_MODULE_1__[\"default\"].str_sha1(sha1__WEBPACK_IMPORTED_MODULE_1__[\"default\"].binb2str(clientKey)), authMessage);\n            connection._sasl_data[\"server-signature\"] = sha1__WEBPACK_IMPORTED_MODULE_1__[\"default\"].b64_hmac_sha1(serverKey, authMessage);\n\n            for (k = 0; k < 5; k++) {\n              clientKey[k] ^= clientSignature[k];\n            }\n\n            responseText += \",p=\" + btoa(sha1__WEBPACK_IMPORTED_MODULE_1__[\"default\"].binb2str(clientKey));\n            return responseText;\n          };\n\n          return auth_str;\n        };\n        /** PrivateConstructor: SASLMD5\n         *  SASL DIGEST MD5 authentication.\n         */\n\n\n        Strophe.SASLMD5 = function () {};\n\n        Strophe.SASLMD5.prototype = new Strophe.SASLMechanism(\"DIGEST-MD5\", false, 60);\n\n        Strophe.SASLMD5.prototype.test = function (connection) {\n          return connection.authcid !== null;\n        };\n        /** PrivateFunction: _quote\n         *  _Private_ utility function to backslash escape and quote strings.\n         *\n         *  Parameters:\n         *    (String) str - The string to be quoted.\n         *\n         *  Returns:\n         *    quoted string\n         */\n\n\n        Strophe.SASLMD5.prototype._quote = function (str) {\n          return '\"' + str.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"') + '\"'; //\" end string workaround for emacs\n        };\n\n        Strophe.SASLMD5.prototype.onChallenge = function (connection, challenge, test_cnonce) {\n          var attribMatch = /([a-z]+)=(\"[^\"]+\"|[^,\"]+)(?:,|$)/;\n          var cnonce = test_cnonce || md5__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hexdigest(\"\" + Math.random() * 1234567890);\n          var realm = \"\";\n          var host = null;\n          var nonce = \"\";\n          var qop = \"\";\n\n          while (challenge.match(attribMatch)) {\n            var matches = challenge.match(attribMatch);\n            challenge = challenge.replace(matches[0], \"\");\n            matches[2] = matches[2].replace(/^\"(.+)\"$/, \"$1\");\n\n            switch (matches[1]) {\n              case \"realm\":\n                realm = matches[2];\n                break;\n\n              case \"nonce\":\n                nonce = matches[2];\n                break;\n\n              case \"qop\":\n                qop = matches[2];\n                break;\n\n              case \"host\":\n                host = matches[2];\n                break;\n            }\n          }\n\n          var digest_uri = connection.servtype + \"/\" + connection.domain;\n\n          if (host !== null) {\n            digest_uri = digest_uri + \"/\" + host;\n          }\n\n          var cred = utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utf16to8(connection.authcid + \":\" + realm + \":\" + this._connection.pass);\n          var A1 = md5__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(cred) + \":\" + nonce + \":\" + cnonce;\n          var A2 = 'AUTHENTICATE:' + digest_uri;\n          var responseText = \"\";\n          responseText += 'charset=utf-8,';\n          responseText += 'username=' + this._quote(utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utf16to8(connection.authcid)) + ',';\n          responseText += 'realm=' + this._quote(realm) + ',';\n          responseText += 'nonce=' + this._quote(nonce) + ',';\n          responseText += 'nc=00000001,';\n          responseText += 'cnonce=' + this._quote(cnonce) + ',';\n          responseText += 'digest-uri=' + this._quote(digest_uri) + ',';\n          responseText += 'response=' + md5__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hexdigest(md5__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hexdigest(A1) + \":\" + nonce + \":00000001:\" + cnonce + \":auth:\" + md5__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hexdigest(A2)) + \",\";\n          responseText += 'qop=auth';\n\n          this.onChallenge = function () {\n            return \"\";\n          };\n\n          return responseText;\n        };\n        /** PrivateConstructor: SASLOAuthBearer\n         *  SASL OAuth Bearer authentication.\n         */\n\n\n        Strophe.SASLOAuthBearer = function () {};\n\n        Strophe.SASLOAuthBearer.prototype = new Strophe.SASLMechanism(\"OAUTHBEARER\", true, 40);\n\n        Strophe.SASLOAuthBearer.prototype.test = function (connection) {\n          return connection.pass !== null;\n        };\n\n        Strophe.SASLOAuthBearer.prototype.onChallenge = function (connection) {\n          var auth_str = 'n,';\n\n          if (connection.authcid !== null) {\n            auth_str = auth_str + 'a=' + connection.authzid;\n          }\n\n          auth_str = auth_str + ',';\n          auth_str = auth_str + \"\\x01\";\n          auth_str = auth_str + 'auth=Bearer ';\n          auth_str = auth_str + connection.pass;\n          auth_str = auth_str + \"\\x01\";\n          auth_str = auth_str + \"\\x01\";\n          return utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utf16to8(auth_str);\n        };\n        /** PrivateConstructor: SASLExternal\n         *  SASL EXTERNAL authentication.\n         *\n         *  The EXTERNAL mechanism allows a client to request the server to use\n         *  credentials established by means external to the mechanism to\n         *  authenticate the client. The external means may be, for instance,\n         *  TLS services.\n         */\n\n\n        Strophe.SASLExternal = function () {};\n\n        Strophe.SASLExternal.prototype = new Strophe.SASLMechanism(\"EXTERNAL\", true, 10);\n\n        Strophe.SASLExternal.prototype.onChallenge = function (connection) {\n          /** According to XEP-178, an authzid SHOULD NOT be presented when the\n           * authcid contained or implied in the client certificate is the JID (i.e.\n           * authzid) with which the user wants to log in as.\n           *\n           * To NOT send the authzid, the user should therefore set the authcid equal\n           * to the JID when instantiating a new Strophe.Connection object.\n           */\n          return connection.authcid === connection.authzid ? '' : connection.authzid;\n        };\n        /** PrivateConstructor: SASLXOAuth2\n         *  SASL X-OAuth2 authentication.\n         */\n\n\n        Strophe.SASLXOAuth2 = function () {};\n\n        Strophe.SASLXOAuth2.prototype = new Strophe.SASLMechanism(\"X-OAUTH2\", true, 30);\n\n        Strophe.SASLXOAuth2.prototype.test = function (connection) {\n          return connection.pass !== null;\n        };\n\n        Strophe.SASLXOAuth2.prototype.onChallenge = function (connection) {\n          var auth_str = \"\\0\";\n\n          if (connection.authcid !== null) {\n            auth_str = auth_str + connection.authzid;\n          }\n\n          auth_str = auth_str + \"\\0\";\n          auth_str = auth_str + connection.pass;\n          return utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].utf16to8(auth_str);\n        };\n        /* harmony default export */\n\n\n        __webpack_exports__[\"default\"] = {\n          'Strophe': Strophe,\n          '$build': $build,\n          '$iq': $iq,\n          '$msg': $msg,\n          '$pres': $pres,\n          'SHA1': sha1__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n          'MD5': md5__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n          'b64_hmac_sha1': sha1__WEBPACK_IMPORTED_MODULE_1__[\"default\"].b64_hmac_sha1,\n          'b64_sha1': sha1__WEBPACK_IMPORTED_MODULE_1__[\"default\"].b64_sha1,\n          'str_hmac_sha1': sha1__WEBPACK_IMPORTED_MODULE_1__[\"default\"].str_hmac_sha1,\n          'str_sha1': sha1__WEBPACK_IMPORTED_MODULE_1__[\"default\"].str_sha1\n        };\n        /***/\n      },\n\n      /***/\n      \"./src/md5.js\":\n      /*!********************!*\\\n        !*** ./src/md5.js ***!\n        \\********************/\n\n      /*! exports provided: default */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        \"use strict\";\n\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"default\", function () {\n          return MD5;\n        });\n        /*\n         * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n         * Digest Algorithm, as defined in RFC 1321.\n         * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\n         * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n         * Distributed under the BSD License\n         * See http://pajhome.org.uk/crypt/md5 for more info.\n         */\n\n        /*\n         * Everything that isn't used by Strophe has been stripped here!\n         */\n\n        /*\n         * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n         * to work around bugs in some JS interpreters.\n         */\n\n\n        var safe_add = function safe_add(x, y) {\n          var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n          var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n          return msw << 16 | lsw & 0xFFFF;\n        };\n        /*\n         * Bitwise rotate a 32-bit number to the left.\n         */\n\n\n        var bit_rol = function bit_rol(num, cnt) {\n          return num << cnt | num >>> 32 - cnt;\n        };\n        /*\n         * Convert a string to an array of little-endian words\n         */\n\n\n        var str2binl = function str2binl(str) {\n          if (typeof str !== \"string\") {\n            throw new Error(\"str2binl was passed a non-string\");\n          }\n\n          var bin = [];\n\n          for (var i = 0; i < str.length * 8; i += 8) {\n            bin[i >> 5] |= (str.charCodeAt(i / 8) & 255) << i % 32;\n          }\n\n          return bin;\n        };\n        /*\n         * Convert an array of little-endian words to a string\n         */\n\n\n        var binl2str = function binl2str(bin) {\n          var str = \"\";\n\n          for (var i = 0; i < bin.length * 32; i += 8) {\n            str += String.fromCharCode(bin[i >> 5] >>> i % 32 & 255);\n          }\n\n          return str;\n        };\n        /*\n         * Convert an array of little-endian words to a hex string.\n         */\n\n\n        var binl2hex = function binl2hex(binarray) {\n          var hex_tab = \"0123456789abcdef\";\n          var str = \"\";\n\n          for (var i = 0; i < binarray.length * 4; i++) {\n            str += hex_tab.charAt(binarray[i >> 2] >> i % 4 * 8 + 4 & 0xF) + hex_tab.charAt(binarray[i >> 2] >> i % 4 * 8 & 0xF);\n          }\n\n          return str;\n        };\n        /*\n         * These functions implement the four basic operations the algorithm uses.\n         */\n\n\n        var md5_cmn = function md5_cmn(q, a, b, x, s, t) {\n          return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);\n        };\n\n        var md5_ff = function md5_ff(a, b, c, d, x, s, t) {\n          return md5_cmn(b & c | ~b & d, a, b, x, s, t);\n        };\n\n        var md5_gg = function md5_gg(a, b, c, d, x, s, t) {\n          return md5_cmn(b & d | c & ~d, a, b, x, s, t);\n        };\n\n        var md5_hh = function md5_hh(a, b, c, d, x, s, t) {\n          return md5_cmn(b ^ c ^ d, a, b, x, s, t);\n        };\n\n        var md5_ii = function md5_ii(a, b, c, d, x, s, t) {\n          return md5_cmn(c ^ (b | ~d), a, b, x, s, t);\n        };\n        /*\n         * Calculate the MD5 of an array of little-endian words, and a bit length\n         */\n\n\n        var core_md5 = function core_md5(x, len) {\n          /* append padding */\n          x[len >> 5] |= 0x80 << len % 32;\n          x[(len + 64 >>> 9 << 4) + 14] = len;\n          var a = 1732584193;\n          var b = -271733879;\n          var c = -1732584194;\n          var d = 271733878;\n          var olda, oldb, oldc, oldd;\n\n          for (var i = 0; i < x.length; i += 16) {\n            olda = a;\n            oldb = b;\n            oldc = c;\n            oldd = d;\n            a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);\n            d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);\n            c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);\n            b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);\n            a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);\n            d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);\n            c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);\n            b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);\n            a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);\n            d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);\n            c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);\n            b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);\n            a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);\n            d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);\n            c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);\n            b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);\n            a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);\n            d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);\n            c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);\n            b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);\n            a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);\n            d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);\n            c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);\n            b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);\n            a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);\n            d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);\n            c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);\n            b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);\n            a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);\n            d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);\n            c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);\n            b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);\n            a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);\n            d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);\n            c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);\n            b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);\n            a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);\n            d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);\n            c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);\n            b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);\n            a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);\n            d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);\n            c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);\n            b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);\n            a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);\n            d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);\n            c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);\n            b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);\n            a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);\n            d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);\n            c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);\n            b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);\n            a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);\n            d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);\n            c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);\n            b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);\n            a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);\n            d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);\n            c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);\n            b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);\n            a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);\n            d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);\n            c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);\n            b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);\n            a = safe_add(a, olda);\n            b = safe_add(b, oldb);\n            c = safe_add(c, oldc);\n            d = safe_add(d, oldd);\n          }\n\n          return [a, b, c, d];\n        };\n        /*\n         * These are the functions you'll usually want to call.\n         * They take string arguments and return either hex or base-64 encoded\n         * strings.\n         */\n\n\n        var MD5 = {\n          hexdigest: function hexdigest(s) {\n            return binl2hex(core_md5(str2binl(s), s.length * 8));\n          },\n          hash: function hash(s) {\n            return binl2str(core_md5(str2binl(s), s.length * 8));\n          }\n        };\n        /***/\n      },\n\n      /***/\n      \"./src/sha1.js\":\n      /*!*********************!*\\\n        !*** ./src/sha1.js ***!\n        \\*********************/\n\n      /*! exports provided: default */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        \"use strict\";\n\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"default\", function () {\n          return SHA1;\n        });\n        /*\n         * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n         * in FIPS PUB 180-1\n         * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n         * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n         * Distributed under the BSD License\n         * See http://pajhome.org.uk/crypt/md5 for details.\n         */\n\n        /* jshint undef: true, unused: true:, noarg: true, latedef: false */\n\n        /* global define */\n\n        /* Some functions and variables have been stripped for use with Strophe */\n\n        /*\n         * Calculate the SHA-1 of an array of big-endian words, and a bit length\n         */\n\n\n        function core_sha1(x, len) {\n          /* append padding */\n          x[len >> 5] |= 0x80 << 24 - len % 32;\n          x[(len + 64 >> 9 << 4) + 15] = len;\n          var w = new Array(80);\n          var a = 1732584193;\n          var b = -271733879;\n          var c = -1732584194;\n          var d = 271733878;\n          var e = -1009589776;\n          var i, j, t, olda, oldb, oldc, oldd, olde;\n\n          for (i = 0; i < x.length; i += 16) {\n            olda = a;\n            oldb = b;\n            oldc = c;\n            oldd = d;\n            olde = e;\n\n            for (j = 0; j < 80; j++) {\n              if (j < 16) {\n                w[j] = x[i + j];\n              } else {\n                w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n              }\n\n              t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));\n              e = d;\n              d = c;\n              c = rol(b, 30);\n              b = a;\n              a = t;\n            }\n\n            a = safe_add(a, olda);\n            b = safe_add(b, oldb);\n            c = safe_add(c, oldc);\n            d = safe_add(d, oldd);\n            e = safe_add(e, olde);\n          }\n\n          return [a, b, c, d, e];\n        }\n        /*\n         * Perform the appropriate triplet combination function for the current\n         * iteration\n         */\n\n\n        function sha1_ft(t, b, c, d) {\n          if (t < 20) {\n            return b & c | ~b & d;\n          }\n\n          if (t < 40) {\n            return b ^ c ^ d;\n          }\n\n          if (t < 60) {\n            return b & c | b & d | c & d;\n          }\n\n          return b ^ c ^ d;\n        }\n        /*\n         * Determine the appropriate additive constant for the current iteration\n         */\n\n\n        function sha1_kt(t) {\n          return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;\n        }\n        /*\n         * Calculate the HMAC-SHA1 of a key and some data\n         */\n\n\n        function core_hmac_sha1(key, data) {\n          var bkey = str2binb(key);\n\n          if (bkey.length > 16) {\n            bkey = core_sha1(bkey, key.length * 8);\n          }\n\n          var ipad = new Array(16),\n              opad = new Array(16);\n\n          for (var i = 0; i < 16; i++) {\n            ipad[i] = bkey[i] ^ 0x36363636;\n            opad[i] = bkey[i] ^ 0x5C5C5C5C;\n          }\n\n          var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);\n          return core_sha1(opad.concat(hash), 512 + 160);\n        }\n        /*\n         * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n         * to work around bugs in some JS interpreters.\n         */\n\n\n        function safe_add(x, y) {\n          var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n          var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n          return msw << 16 | lsw & 0xFFFF;\n        }\n        /*\n         * Bitwise rotate a 32-bit number to the left.\n         */\n\n\n        function rol(num, cnt) {\n          return num << cnt | num >>> 32 - cnt;\n        }\n        /*\n         * Convert an 8-bit or 16-bit string to an array of big-endian words\n         * In 8-bit function, characters >255 have their hi-byte silently ignored.\n         */\n\n\n        function str2binb(str) {\n          var bin = [];\n          var mask = 255;\n\n          for (var i = 0; i < str.length * 8; i += 8) {\n            bin[i >> 5] |= (str.charCodeAt(i / 8) & mask) << 24 - i % 32;\n          }\n\n          return bin;\n        }\n        /*\n         * Convert an array of big-endian words to a base-64 string\n         */\n\n\n        function binb2b64(binarray) {\n          var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n          var str = \"\";\n          var triplet, j;\n\n          for (var i = 0; i < binarray.length * 4; i += 3) {\n            triplet = (binarray[i >> 2] >> 8 * (3 - i % 4) & 0xFF) << 16 | (binarray[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4) & 0xFF) << 8 | binarray[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4) & 0xFF;\n\n            for (j = 0; j < 4; j++) {\n              if (i * 8 + j * 6 > binarray.length * 32) {\n                str += \"=\";\n              } else {\n                str += tab.charAt(triplet >> 6 * (3 - j) & 0x3F);\n              }\n            }\n          }\n\n          return str;\n        }\n        /*\n         * Convert an array of big-endian words to a string\n         */\n\n\n        function binb2str(bin) {\n          var str = \"\";\n          var mask = 255;\n\n          for (var i = 0; i < bin.length * 32; i += 8) {\n            str += String.fromCharCode(bin[i >> 5] >>> 24 - i % 32 & mask);\n          }\n\n          return str;\n        }\n        /*\n         * These are the functions you'll usually want to call\n         * They take string arguments and return either hex or base-64 encoded strings\n         */\n\n\n        var SHA1 = {\n          b64_hmac_sha1: function b64_hmac_sha1(key, data) {\n            return binb2b64(core_hmac_sha1(key, data));\n          },\n          b64_sha1: function b64_sha1(s) {\n            return binb2b64(core_sha1(str2binb(s), s.length * 8));\n          },\n          binb2str: binb2str,\n          core_hmac_sha1: core_hmac_sha1,\n          str_hmac_sha1: function str_hmac_sha1(key, data) {\n            return binb2str(core_hmac_sha1(key, data));\n          },\n          str_sha1: function str_sha1(s) {\n            return binb2str(core_sha1(str2binb(s), s.length * 8));\n          }\n        };\n        /***/\n      },\n\n      /***/\n      \"./src/strophe.js\":\n      /*!************************!*\\\n        !*** ./src/strophe.js ***!\n        \\************************/\n\n      /*! exports provided: default */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        \"use strict\";\n\n        __webpack_require__.r(__webpack_exports__);\n        /* WEBPACK VAR INJECTION */\n\n\n        (function (global) {\n          /* harmony import */\n          var core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n          /*! core */\n          \"./src/core.js\");\n          /* harmony import */\n\n\n          var bosh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\n          /*! bosh */\n          \"./src/bosh.js\");\n          /* harmony import */\n\n\n          var websocket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\n          /*! websocket */\n          \"./src/websocket.js\");\n          /* harmony reexport (safe) */\n\n\n          __webpack_require__.d(__webpack_exports__, \"default\", function () {\n            return core__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n          });\n          /*global global*/\n\n\n          global.Strophe = core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Strophe;\n          global.$build = core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].$build;\n          global.$iq = core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].$iq;\n          global.$msg = core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].$msg;\n          global.$pres = core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].$pres;\n          /* WEBPACK VAR INJECTION */\n        }).call(this, __webpack_require__(\n        /*! ./../node_modules/webpack/buildin/global.js */\n        \"./node_modules/webpack/buildin/global.js\"));\n        /***/\n      },\n\n      /***/\n      \"./src/utils.js\":\n      /*!**********************!*\\\n        !*** ./src/utils.js ***!\n        \\**********************/\n\n      /*! exports provided: default */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        \"use strict\";\n\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony export (binding) */\n\n\n        __webpack_require__.d(__webpack_exports__, \"default\", function () {\n          return utils;\n        });\n\n        function _typeof(obj) {\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        var utils = {\n          utf16to8: function utf16to8(str) {\n            var i, c;\n            var out = \"\";\n            var len = str.length;\n\n            for (i = 0; i < len; i++) {\n              c = str.charCodeAt(i);\n\n              if (c >= 0x0000 && c <= 0x007F) {\n                out += str.charAt(i);\n              } else if (c > 0x07FF) {\n                out += String.fromCharCode(0xE0 | c >> 12 & 0x0F);\n                out += String.fromCharCode(0x80 | c >> 6 & 0x3F);\n                out += String.fromCharCode(0x80 | c >> 0 & 0x3F);\n              } else {\n                out += String.fromCharCode(0xC0 | c >> 6 & 0x1F);\n                out += String.fromCharCode(0x80 | c >> 0 & 0x3F);\n              }\n            }\n\n            return out;\n          },\n          addCookies: function addCookies(cookies) {\n            /* Parameters:\n             *  (Object) cookies - either a map of cookie names\n             *    to string values or to maps of cookie values.\n             *\n             * For example:\n             * { \"myCookie\": \"1234\" }\n             *\n             * or:\n             * { \"myCookie\": {\n             *      \"value\": \"1234\",\n             *      \"domain\": \".example.org\",\n             *      \"path\": \"/\",\n             *      \"expires\": expirationDate\n             *      }\n             *  }\n             *\n             *  These values get passed to Strophe.Connection via\n             *   options.cookies\n             */\n            cookies = cookies || {};\n\n            for (var cookieName in cookies) {\n              if (Object.prototype.hasOwnProperty.call(cookies, cookieName)) {\n                var expires = '';\n                var domain = '';\n                var path = '';\n                var cookieObj = cookies[cookieName];\n                var isObj = _typeof(cookieObj) === \"object\";\n                var cookieValue = escape(unescape(isObj ? cookieObj.value : cookieObj));\n\n                if (isObj) {\n                  expires = cookieObj.expires ? \";expires=\" + cookieObj.expires : '';\n                  domain = cookieObj.domain ? \";domain=\" + cookieObj.domain : '';\n                  path = cookieObj.path ? \";path=\" + cookieObj.path : '';\n                }\n\n                document.cookie = cookieName + '=' + cookieValue + expires + domain + path;\n              }\n            }\n          }\n        };\n        /***/\n      },\n\n      /***/\n      \"./src/websocket.js\":\n      /*!**************************!*\\\n        !*** ./src/websocket.js ***!\n        \\**************************/\n\n      /*! no exports provided */\n\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        \"use strict\";\n\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony import */\n\n\n        var core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\n        /*! core */\n        \"./src/core.js\");\n        /*\n            This program is distributed under the terms of the MIT license.\n            Please see the LICENSE file for details.\n        \n            Copyright 2006-2008, OGG, LLC\n        */\n\n        /* global window, clearTimeout, WebSocket, DOMParser */\n\n\n        var Strophe = core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Strophe;\n        var $build = core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].$build;\n        /** Class: Strophe.WebSocket\n         *  _Private_ helper class that handles WebSocket Connections\n         *\n         *  The Strophe.WebSocket class is used internally by Strophe.Connection\n         *  to encapsulate WebSocket sessions. It is not meant to be used from user's code.\n         */\n\n        /** File: websocket.js\n         *  A JavaScript library to enable XMPP over Websocket in Strophejs.\n         *\n         *  This file implements XMPP over WebSockets for Strophejs.\n         *  If a Connection is established with a Websocket url (ws://...)\n         *  Strophe will use WebSockets.\n         *  For more information on XMPP-over-WebSocket see RFC 7395:\n         *  http://tools.ietf.org/html/rfc7395\n         *\n         *  WebSocket support implemented by Andreas Guth (andreas.guth@rwth-aachen.de)\n         */\n\n        /** PrivateConstructor: Strophe.Websocket\n         *  Create and initialize a Strophe.WebSocket object.\n         *  Currently only sets the connection Object.\n         *\n         *  Parameters:\n         *    (Strophe.Connection) connection - The Strophe.Connection that will use WebSockets.\n         *\n         *  Returns:\n         *    A new Strophe.WebSocket object.\n         */\n\n        Strophe.Websocket = function (connection) {\n          this._conn = connection;\n          this.strip = \"wrapper\";\n          var service = connection.service;\n\n          if (service.indexOf(\"ws:\") !== 0 && service.indexOf(\"wss:\") !== 0) {\n            // If the service is not an absolute URL, assume it is a path and put the absolute\n            // URL together from options, current URL and the path.\n            var new_service = \"\";\n\n            if (connection.options.protocol === \"ws\" && window.location.protocol !== \"https:\") {\n              new_service += \"ws\";\n            } else {\n              new_service += \"wss\";\n            }\n\n            new_service += \"://\" + window.location.host;\n\n            if (service.indexOf(\"/\") !== 0) {\n              new_service += window.location.pathname + service;\n            } else {\n              new_service += service;\n            }\n\n            connection.service = new_service;\n          }\n        };\n\n        Strophe.Websocket.prototype = {\n          /** PrivateFunction: _buildStream\n           *  _Private_ helper function to generate the <stream> start tag for WebSockets\n           *\n           *  Returns:\n           *    A Strophe.Builder with a <stream> element.\n           */\n          _buildStream: function _buildStream() {\n            return $build(\"open\", {\n              \"xmlns\": Strophe.NS.FRAMING,\n              \"to\": this._conn.domain,\n              \"version\": '1.0'\n            });\n          },\n\n          /** PrivateFunction: _check_streamerror\n           * _Private_ checks a message for stream:error\n           *\n           *  Parameters:\n           *    (Strophe.Request) bodyWrap - The received stanza.\n           *    connectstatus - The ConnectStatus that will be set on error.\n           *  Returns:\n           *     true if there was a streamerror, false otherwise.\n           */\n          _check_streamerror: function _check_streamerror(bodyWrap, connectstatus) {\n            var errors;\n\n            if (bodyWrap.getElementsByTagNameNS) {\n              errors = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, \"error\");\n            } else {\n              errors = bodyWrap.getElementsByTagName(\"stream:error\");\n            }\n\n            if (errors.length === 0) {\n              return false;\n            }\n\n            var error = errors[0];\n            var condition = \"\";\n            var text = \"\";\n            var ns = \"urn:ietf:params:xml:ns:xmpp-streams\";\n\n            for (var i = 0; i < error.childNodes.length; i++) {\n              var e = error.childNodes[i];\n\n              if (e.getAttribute(\"xmlns\") !== ns) {\n                break;\n              }\n\n              if (e.nodeName === \"text\") {\n                text = e.textContent;\n              } else {\n                condition = e.nodeName;\n              }\n            }\n\n            var errorString = \"WebSocket stream error: \";\n\n            if (condition) {\n              errorString += condition;\n            } else {\n              errorString += \"unknown\";\n            }\n\n            if (text) {\n              errorString += \" - \" + text;\n            }\n\n            Strophe.error(errorString); // close the connection on stream_error\n\n            this._conn._changeConnectStatus(connectstatus, condition);\n\n            this._conn._doDisconnect();\n\n            return true;\n          },\n\n          /** PrivateFunction: _reset\n           *  Reset the connection.\n           *\n           *  This function is called by the reset function of the Strophe Connection.\n           *  Is not needed by WebSockets.\n           */\n          _reset: function _reset() {\n            return;\n          },\n\n          /** PrivateFunction: _connect\n           *  _Private_ function called by Strophe.Connection.connect\n           *\n           *  Creates a WebSocket for a connection and assigns Callbacks to it.\n           *  Does nothing if there already is a WebSocket.\n           */\n          _connect: function _connect() {\n            // Ensure that there is no open WebSocket from a previous Connection.\n            this._closeSocket(); // Create the new WobSocket\n\n\n            this.socket = new WebSocket(this._conn.service, \"xmpp\");\n            this.socket.onopen = this._onOpen.bind(this);\n            this.socket.onerror = this._onError.bind(this);\n            this.socket.onclose = this._onClose.bind(this);\n            this.socket.onmessage = this._connect_cb_wrapper.bind(this);\n          },\n\n          /** PrivateFunction: _connect_cb\n           *  _Private_ function called by Strophe.Connection._connect_cb\n           *\n           * checks for stream:error\n           *\n           *  Parameters:\n           *    (Strophe.Request) bodyWrap - The received stanza.\n           */\n          _connect_cb: function _connect_cb(bodyWrap) {\n            var error = this._check_streamerror(bodyWrap, Strophe.Status.CONNFAIL);\n\n            if (error) {\n              return Strophe.Status.CONNFAIL;\n            }\n          },\n\n          /** PrivateFunction: _handleStreamStart\n           * _Private_ function that checks the opening <open /> tag for errors.\n           *\n           * Disconnects if there is an error and returns false, true otherwise.\n           *\n           *  Parameters:\n           *    (Node) message - Stanza containing the <open /> tag.\n           */\n          _handleStreamStart: function _handleStreamStart(message) {\n            var error = false; // Check for errors in the <open /> tag\n\n            var ns = message.getAttribute(\"xmlns\");\n\n            if (typeof ns !== \"string\") {\n              error = \"Missing xmlns in <open />\";\n            } else if (ns !== Strophe.NS.FRAMING) {\n              error = \"Wrong xmlns in <open />: \" + ns;\n            }\n\n            var ver = message.getAttribute(\"version\");\n\n            if (typeof ver !== \"string\") {\n              error = \"Missing version in <open />\";\n            } else if (ver !== \"1.0\") {\n              error = \"Wrong version in <open />: \" + ver;\n            }\n\n            if (error) {\n              this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);\n\n              this._conn._doDisconnect();\n\n              return false;\n            }\n\n            return true;\n          },\n\n          /** PrivateFunction: _connect_cb_wrapper\n           * _Private_ function that handles the first connection messages.\n           *\n           * On receiving an opening stream tag this callback replaces itself with the real\n           * message handler. On receiving a stream error the connection is terminated.\n           */\n          _connect_cb_wrapper: function _connect_cb_wrapper(message) {\n            if (message.data.indexOf(\"<open \") === 0 || message.data.indexOf(\"<?xml\") === 0) {\n              // Strip the XML Declaration, if there is one\n              var data = message.data.replace(/^(<\\?.*?\\?>\\s*)*/, \"\");\n              if (data === '') return;\n              var streamStart = new DOMParser().parseFromString(data, \"text/xml\").documentElement;\n\n              this._conn.xmlInput(streamStart);\n\n              this._conn.rawInput(message.data); //_handleStreamSteart will check for XML errors and disconnect on error\n\n\n              if (this._handleStreamStart(streamStart)) {\n                //_connect_cb will check for stream:error and disconnect on error\n                this._connect_cb(streamStart);\n              }\n            } else if (message.data.indexOf(\"<close \") === 0) {\n              // <close xmlns=\"urn:ietf:params:xml:ns:xmpp-framing />\n              // Parse the raw string to an XML element\n              var parsedMessage = new DOMParser().parseFromString(message.data, \"text/xml\").documentElement; // Report this input to the raw and xml handlers\n\n              this._conn.xmlInput(parsedMessage);\n\n              this._conn.rawInput(message.data);\n\n              var see_uri = parsedMessage.getAttribute(\"see-other-uri\");\n\n              if (see_uri) {\n                var service = this._conn.service; // Valid scenarios: WSS->WSS, WS->ANY\n\n                var isSecureRedirect = service.indexOf(\"wss:\") >= 0 && see_uri.indexOf(\"wss:\") >= 0 || service.indexOf(\"ws:\") >= 0;\n\n                if (isSecureRedirect) {\n                  this._conn._changeConnectStatus(Strophe.Status.REDIRECT, \"Received see-other-uri, resetting connection\");\n\n                  this._conn.reset();\n\n                  this._conn.service = see_uri;\n\n                  this._connect();\n                }\n              } else {\n                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"Received closing stream\");\n\n                this._conn._doDisconnect();\n              }\n            } else {\n              var string = this._streamWrap(message.data);\n\n              var elem = new DOMParser().parseFromString(string, \"text/xml\").documentElement;\n              this.socket.onmessage = this._onMessage.bind(this);\n\n              this._conn._connect_cb(elem, null, message.data);\n            }\n          },\n\n          /** PrivateFunction: _disconnect\n           *  _Private_ function called by Strophe.Connection.disconnect\n           *\n           *  Disconnects and sends a last stanza if one is given\n           *\n           *  Parameters:\n           *    (Request) pres - This stanza will be sent before disconnecting.\n           */\n          _disconnect: function _disconnect(pres) {\n            if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {\n              if (pres) {\n                this._conn.send(pres);\n              }\n\n              var close = $build(\"close\", {\n                \"xmlns\": Strophe.NS.FRAMING\n              });\n\n              this._conn.xmlOutput(close.tree());\n\n              var closeString = Strophe.serialize(close);\n\n              this._conn.rawOutput(closeString);\n\n              try {\n                this.socket.send(closeString);\n              } catch (e) {\n                Strophe.warn(\"Couldn't send <close /> tag.\");\n              }\n            }\n\n            this._conn._doDisconnect();\n          },\n\n          /** PrivateFunction: _doDisconnect\n           *  _Private_ function to disconnect.\n           *\n           *  Just closes the Socket for WebSockets\n           */\n          _doDisconnect: function _doDisconnect() {\n            Strophe.debug(\"WebSockets _doDisconnect was called\");\n\n            this._closeSocket();\n          },\n\n          /** PrivateFunction _streamWrap\n           *  _Private_ helper function to wrap a stanza in a <stream> tag.\n           *  This is used so Strophe can process stanzas from WebSockets like BOSH\n           */\n          _streamWrap: function _streamWrap(stanza) {\n            return \"<wrapper>\" + stanza + '</wrapper>';\n          },\n\n          /** PrivateFunction: _closeSocket\n           *  _Private_ function to close the WebSocket.\n           *\n           *  Closes the socket if it is still open and deletes it\n           */\n          _closeSocket: function _closeSocket() {\n            if (this.socket) {\n              try {\n                this.socket.onerror = null;\n                this.socket.close();\n              } catch (e) {\n                Strophe.debug(e.message);\n              }\n            }\n\n            this.socket = null;\n          },\n\n          /** PrivateFunction: _emptyQueue\n           * _Private_ function to check if the message queue is empty.\n           *\n           *  Returns:\n           *    True, because WebSocket messages are send immediately after queueing.\n           */\n          _emptyQueue: function _emptyQueue() {\n            return true;\n          },\n\n          /** PrivateFunction: _onClose\n           * _Private_ function to handle websockets closing.\n           *\n           * Nothing to do here for WebSockets\n           */\n          _onClose: function _onClose(e) {\n            if (this._conn.connected && !this._conn.disconnecting) {\n              Strophe.error(\"Websocket closed unexpectedly\");\n\n              this._conn._doDisconnect();\n            } else if (e && e.code === 1006 && !this._conn.connected && this.socket) {\n              // in case the onError callback was not called (Safari 10 does not\n              // call onerror when the initial connection fails) we need to\n              // dispatch a CONNFAIL status update to be consistent with the\n              // behavior on other browsers.\n              Strophe.error(\"Websocket closed unexcectedly\");\n\n              this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"The WebSocket connection could not be established or was disconnected.\");\n\n              this._conn._doDisconnect();\n            } else {\n              Strophe.debug(\"Websocket closed\");\n            }\n          },\n\n          /** PrivateFunction: _no_auth_received\n           *\n           * Called on stream start/restart when no stream:features\n           * has been received.\n           */\n          _no_auth_received: function _no_auth_received(callback) {\n            Strophe.error(\"Server did not offer a supported authentication mechanism\");\n\n            this._changeConnectStatus(Strophe.Status.CONNFAIL, Strophe.ErrorCondition.NO_AUTH_MECH);\n\n            if (callback) {\n              callback.call(this._conn);\n            }\n\n            this._conn._doDisconnect();\n          },\n\n          /** PrivateFunction: _onDisconnectTimeout\n           *  _Private_ timeout handler for handling non-graceful disconnection.\n           *\n           *  This does nothing for WebSockets\n           */\n          _onDisconnectTimeout: function _onDisconnectTimeout() {},\n\n          /** PrivateFunction: _abortAllRequests\n           *  _Private_ helper function that makes sure all pending requests are aborted.\n           */\n          _abortAllRequests: function _abortAllRequests() {},\n\n          /** PrivateFunction: _onError\n           * _Private_ function to handle websockets errors.\n           *\n           * Parameters:\n           * (Object) error - The websocket error.\n           */\n          _onError: function _onError(error) {\n            Strophe.error(\"Websocket error \" + error);\n\n            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"The WebSocket connection could not be established or was disconnected.\");\n\n            this._disconnect();\n          },\n\n          /** PrivateFunction: _onIdle\n           *  _Private_ function called by Strophe.Connection._onIdle\n           *\n           *  sends all queued stanzas\n           */\n          _onIdle: function _onIdle() {\n            var data = this._conn._data;\n\n            if (data.length > 0 && !this._conn.paused) {\n              for (var i = 0; i < data.length; i++) {\n                if (data[i] !== null) {\n                  var stanza = void 0;\n\n                  if (data[i] === \"restart\") {\n                    stanza = this._buildStream().tree();\n                  } else {\n                    stanza = data[i];\n                  }\n\n                  var rawStanza = Strophe.serialize(stanza);\n\n                  this._conn.xmlOutput(stanza);\n\n                  this._conn.rawOutput(rawStanza);\n\n                  this.socket.send(rawStanza);\n                }\n              }\n\n              this._conn._data = [];\n            }\n          },\n\n          /** PrivateFunction: _onMessage\n           * _Private_ function to handle websockets messages.\n           *\n           * This function parses each of the messages as if they are full documents.\n           * [TODO : We may actually want to use a SAX Push parser].\n           *\n           * Since all XMPP traffic starts with\n           *  <stream:stream version='1.0'\n           *                 xml:lang='en'\n           *                 xmlns='jabber:client'\n           *                 xmlns:stream='http://etherx.jabber.org/streams'\n           *                 id='3697395463'\n           *                 from='SERVER'>\n           *\n           * The first stanza will always fail to be parsed.\n           *\n           * Additionally, the seconds stanza will always be <stream:features> with\n           * the stream NS defined in the previous stanza, so we need to 'force'\n           * the inclusion of the NS in this stanza.\n           *\n           * Parameters:\n           * (string) message - The websocket message.\n           */\n          _onMessage: function _onMessage(message) {\n            var elem; // check for closing stream\n\n            var close = '<close xmlns=\"urn:ietf:params:xml:ns:xmpp-framing\" />';\n\n            if (message.data === close) {\n              this._conn.rawInput(close);\n\n              this._conn.xmlInput(message);\n\n              if (!this._conn.disconnecting) {\n                this._conn._doDisconnect();\n              }\n\n              return;\n            } else if (message.data.search(\"<open \") === 0) {\n              // This handles stream restarts\n              elem = new DOMParser().parseFromString(message.data, \"text/xml\").documentElement;\n\n              if (!this._handleStreamStart(elem)) {\n                return;\n              }\n            } else {\n              var data = this._streamWrap(message.data);\n\n              elem = new DOMParser().parseFromString(data, \"text/xml\").documentElement;\n            }\n\n            if (this._check_streamerror(elem, Strophe.Status.ERROR)) {\n              return;\n            } //handle unavailable presence stanza before disconnecting\n\n\n            if (this._conn.disconnecting && elem.firstChild.nodeName === \"presence\" && elem.firstChild.getAttribute(\"type\") === \"unavailable\") {\n              this._conn.xmlInput(elem);\n\n              this._conn.rawInput(Strophe.serialize(elem)); // if we are already disconnecting we will ignore the unavailable stanza and\n              // wait for the </stream:stream> tag before we close the connection\n\n\n              return;\n            }\n\n            this._conn._dataRecv(elem, message.data);\n          },\n\n          /** PrivateFunction: _onOpen\n           * _Private_ function to handle websockets connection setup.\n           *\n           * The opening stream tag is sent here.\n           */\n          _onOpen: function _onOpen() {\n            Strophe.debug(\"Websocket open\");\n\n            var start = this._buildStream();\n\n            this._conn.xmlOutput(start.tree());\n\n            var startString = Strophe.serialize(start);\n\n            this._conn.rawOutput(startString);\n\n            this.socket.send(startString);\n          },\n\n          /** PrivateFunction: _reqToData\n           * _Private_ function to get a stanza out of a request.\n           *\n           * WebSockets don't use requests, so the passed argument is just returned.\n           *\n           *  Parameters:\n           *    (Object) stanza - The stanza.\n           *\n           *  Returns:\n           *    The stanza that was passed.\n           */\n          _reqToData: function _reqToData(stanza) {\n            return stanza;\n          },\n\n          /** PrivateFunction: _send\n           *  _Private_ part of the Connection.send function for WebSocket\n           *\n           * Just flushes the messages that are in the queue\n           */\n          _send: function _send() {\n            this._conn.flush();\n          },\n\n          /** PrivateFunction: _sendRestart\n           *\n           *  Send an xmpp:restart stanza.\n           */\n          _sendRestart: function _sendRestart() {\n            clearTimeout(this._conn._idleTimeout);\n\n            this._conn._onIdle.bind(this._conn)();\n          }\n        };\n        /***/\n      }\n      /******/\n\n    })[\"default\"]\n  );\n});","map":null,"metadata":{},"sourceType":"script"}