{"ast":null,"code":"const EventEmitter = require('events').EventEmitter;\n\nconst JsSIP_C = require('../Constants');\n\nconst Exceptions = require('../Exceptions');\n\nconst Utils = require('../Utils');\n\nconst debug = require('debug')('JsSIP:RTCSession:DTMF');\n\nconst debugerror = require('debug')('JsSIP:ERROR:RTCSession:DTMF');\n\ndebugerror.log = console.warn.bind(console);\nconst C = {\n  MIN_DURATION: 70,\n  MAX_DURATION: 6000,\n  DEFAULT_DURATION: 100,\n  MIN_INTER_TONE_GAP: 50,\n  DEFAULT_INTER_TONE_GAP: 500\n};\nmodule.exports = class DTMF extends EventEmitter {\n  constructor(session) {\n    super();\n    this._session = session;\n    this._direction = null;\n    this._tone = null;\n    this._duration = null;\n    this._request = null;\n  }\n\n  get tone() {\n    return this._tone;\n  }\n\n  get duration() {\n    return this._duration;\n  }\n\n  send(tone, options = {}) {\n    if (tone === undefined) {\n      throw new TypeError('Not enough arguments');\n    }\n\n    this._direction = 'outgoing'; // Check RTCSession Status.\n\n    if (this._session.status !== this._session.C.STATUS_CONFIRMED && this._session.status !== this._session.C.STATUS_WAITING_FOR_ACK) {\n      throw new Exceptions.InvalidStateError(this._session.status);\n    }\n\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    this.eventHandlers = options.eventHandlers || {}; // Check tone type.\n\n    if (typeof tone === 'string') {\n      tone = tone.toUpperCase();\n    } else if (typeof tone === 'number') {\n      tone = tone.toString();\n    } else {\n      throw new TypeError(\"Invalid tone: \".concat(tone));\n    } // Check tone value.\n\n\n    if (!tone.match(/^[0-9A-DR#*]$/)) {\n      throw new TypeError(\"Invalid tone: \".concat(tone));\n    } else {\n      this._tone = tone;\n    } // Duration is checked/corrected in RTCSession.\n\n\n    this._duration = options.duration;\n    extraHeaders.push('Content-Type: application/dtmf-relay');\n    let body = \"Signal=\".concat(this._tone, \"\\r\\n\");\n    body += \"Duration=\".concat(this._duration);\n\n    this._session.newDTMF({\n      originator: 'local',\n      dtmf: this,\n      request: this._request\n    });\n\n    this._session.sendRequest(JsSIP_C.INFO, {\n      extraHeaders,\n      eventHandlers: {\n        onSuccessResponse: response => {\n          this.emit('succeeded', {\n            originator: 'remote',\n            response\n          });\n        },\n        onErrorResponse: response => {\n          if (this.eventHandlers.onFailed) {\n            this.eventHandlers.onFailed();\n          }\n\n          this.emit('failed', {\n            originator: 'remote',\n            response\n          });\n        },\n        onRequestTimeout: () => {\n          this._session.onRequestTimeout();\n        },\n        onTransportError: () => {\n          this._session.onTransportError();\n        },\n        onDialogError: () => {\n          this._session.onDialogError();\n        }\n      },\n      body\n    });\n  }\n\n  init_incoming(request) {\n    const reg_tone = /^(Signal\\s*?=\\s*?)([0-9A-D#*]{1})(\\s)?.*/;\n    const reg_duration = /^(Duration\\s?=\\s?)([0-9]{1,4})(\\s)?.*/;\n    this._direction = 'incoming';\n    this._request = request;\n    request.reply(200);\n\n    if (request.body) {\n      const body = request.body.split('\\n');\n\n      if (body.length >= 1) {\n        if (reg_tone.test(body[0])) {\n          this._tone = body[0].replace(reg_tone, '$2');\n        }\n      }\n\n      if (body.length >= 2) {\n        if (reg_duration.test(body[1])) {\n          this._duration = parseInt(body[1].replace(reg_duration, '$2'), 10);\n        }\n      }\n    }\n\n    if (!this._duration) {\n      this._duration = C.DEFAULT_DURATION;\n    }\n\n    if (!this._tone) {\n      debug('invalid INFO DTMF received, discarded');\n    } else {\n      this._session.newDTMF({\n        originator: 'remote',\n        dtmf: this,\n        request\n      });\n    }\n  }\n\n};\n/**\n * Expose C object.\n */\n\nmodule.exports.C = C;","map":null,"metadata":{},"sourceType":"script"}