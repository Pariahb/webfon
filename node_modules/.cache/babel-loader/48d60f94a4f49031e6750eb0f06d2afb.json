{"ast":null,"code":"const Socket = require('./Socket');\n\nconst debug = require('debug')('JsSIP:Transport');\n\nconst debugerror = require('debug')('JsSIP:ERROR:Transport');\n\nconst JsSIP_C = require('./Constants');\n\ndebugerror.log = console.warn.bind(console);\n/**\n * Constants\n */\n\nconst C = {\n  // Transport status.\n  STATUS_CONNECTED: 0,\n  STATUS_CONNECTING: 1,\n  STATUS_DISCONNECTED: 2,\n  // Socket status.\n  SOCKET_STATUS_READY: 0,\n  SOCKET_STATUS_ERROR: 1,\n  // Recovery options.\n  recovery_options: {\n    // minimum interval in seconds between recover attempts.\n    min_interval: JsSIP_C.CONNECTION_RECOVERY_MIN_INTERVAL,\n    // maximum interval in seconds between recover attempts.\n    max_interval: JsSIP_C.CONNECTION_RECOVERY_MAX_INTERVAL\n  }\n};\n/*\n * Manages one or multiple JsSIP.Socket instances.\n * Is reponsible for transport recovery logic among all socket instances.\n *\n * @socket JsSIP::Socket instance\n */\n\nmodule.exports = class Transport {\n  constructor(sockets, recovery_options = C.recovery_options) {\n    debug('new()');\n    this.status = C.STATUS_DISCONNECTED; // Current socket.\n\n    this.socket = null; // Socket collection.\n\n    this.sockets = [];\n    this.recovery_options = recovery_options;\n    this.recover_attempts = 0;\n    this.recovery_timer = null;\n    this.close_requested = false;\n\n    if (typeof sockets === 'undefined') {\n      throw new TypeError('Invalid argument.' + ' undefined \\'sockets\\' argument');\n    }\n\n    if (!(sockets instanceof Array)) {\n      sockets = [sockets];\n    }\n\n    sockets.forEach(function (socket) {\n      if (!Socket.isSocket(socket.socket)) {\n        throw new TypeError('Invalid argument.' + ' invalid \\'JsSIP.Socket\\' instance');\n      }\n\n      if (socket.weight && !Number(socket.weight)) {\n        throw new TypeError('Invalid argument.' + ' \\'weight\\' attribute is not a number');\n      }\n\n      this.sockets.push({\n        socket: socket.socket,\n        weight: socket.weight || 0,\n        status: C.SOCKET_STATUS_READY\n      });\n    }, this); // Get the socket with higher weight.\n\n    this._getSocket();\n  }\n  /**\n   * Instance Methods\n   */\n\n\n  get via_transport() {\n    return this.socket.via_transport;\n  }\n\n  get url() {\n    return this.socket.url;\n  }\n\n  get sip_uri() {\n    return this.socket.sip_uri;\n  }\n\n  connect() {\n    debug('connect()');\n\n    if (this.isConnected()) {\n      debug('Transport is already connected');\n      return;\n    } else if (this.isConnecting()) {\n      debug('Transport is connecting');\n      return;\n    }\n\n    this.close_requested = false;\n    this.status = C.STATUS_CONNECTING;\n    this.onconnecting({\n      socket: this.socket,\n      attempts: this.recover_attempts\n    });\n\n    if (!this.close_requested) {\n      // Bind socket event callbacks.\n      this.socket.onconnect = this._onConnect.bind(this);\n      this.socket.ondisconnect = this._onDisconnect.bind(this);\n      this.socket.ondata = this._onData.bind(this);\n      this.socket.connect();\n    }\n\n    return;\n  }\n\n  disconnect() {\n    debug('close()');\n    this.close_requested = true;\n    this.recover_attempts = 0;\n    this.status = C.STATUS_DISCONNECTED; // Clear recovery_timer.\n\n    if (this.recovery_timer !== null) {\n      clearTimeout(this.recovery_timer);\n      this.recovery_timer = null;\n    } // Unbind socket event callbacks.\n\n\n    this.socket.onconnect = () => {};\n\n    this.socket.ondisconnect = () => {};\n\n    this.socket.ondata = () => {};\n\n    this.socket.disconnect();\n    this.ondisconnect({\n      socket: this.socket,\n      error: false\n    });\n  }\n\n  send(data) {\n    debug('send()');\n\n    if (!this.isConnected()) {\n      debugerror('unable to send message, transport is not connected');\n      return false;\n    }\n\n    const message = data.toString();\n    debug(\"sending message:\\n\\n\".concat(message, \"\\n\"));\n    return this.socket.send(message);\n  }\n\n  isConnected() {\n    return this.status === C.STATUS_CONNECTED;\n  }\n\n  isConnecting() {\n    return this.status === C.STATUS_CONNECTING;\n  }\n  /**\n   * Private API.\n   */\n\n\n  _reconnect() {\n    this.recover_attempts += 1;\n    let k = Math.floor(Math.random() * Math.pow(2, this.recover_attempts) + 1);\n\n    if (k < this.recovery_options.min_interval) {\n      k = this.recovery_options.min_interval;\n    } else if (k > this.recovery_options.max_interval) {\n      k = this.recovery_options.max_interval;\n    }\n\n    debug(\"reconnection attempt: \".concat(this.recover_attempts, \". next connection attempt in \").concat(k, \" seconds\"));\n    this.recovery_timer = setTimeout(() => {\n      if (!this.close_requested && !(this.isConnected() || this.isConnecting())) {\n        // Get the next available socket with higher weight.\n        this._getSocket(); // Connect the socket.\n\n\n        this.connect();\n      }\n    }, k * 1000);\n  }\n  /**\n   * get the next available socket with higher weight\n   */\n\n\n  _getSocket() {\n    let candidates = [];\n    this.sockets.forEach(socket => {\n      if (socket.status === C.SOCKET_STATUS_ERROR) {\n        return; // continue the array iteration\n      } else if (candidates.length === 0) {\n        candidates.push(socket);\n      } else if (socket.weight > candidates[0].weight) {\n        candidates = [socket];\n      } else if (socket.weight === candidates[0].weight) {\n        candidates.push(socket);\n      }\n    });\n\n    if (candidates.length === 0) {\n      // All sockets have failed. reset sockets status.\n      this.sockets.forEach(socket => {\n        socket.status = C.SOCKET_STATUS_READY;\n      }); // Get next available socket.\n\n      this._getSocket();\n\n      return;\n    }\n\n    const idx = Math.floor(Math.random() * candidates.length);\n    this.socket = candidates[idx].socket;\n  }\n  /**\n   * Socket Event Handlers\n   */\n\n\n  _onConnect() {\n    this.recover_attempts = 0;\n    this.status = C.STATUS_CONNECTED; // Clear recovery_timer.\n\n    if (this.recovery_timer !== null) {\n      clearTimeout(this.recovery_timer);\n      this.recovery_timer = null;\n    }\n\n    this.onconnect({\n      socket: this\n    });\n  }\n\n  _onDisconnect(error, code, reason) {\n    this.status = C.STATUS_DISCONNECTED;\n    this.ondisconnect({\n      socket: this.socket,\n      error,\n      code,\n      reason\n    });\n\n    if (this.close_requested) {\n      return;\n    } // Update socket status.\n    else {\n        this.sockets.forEach(function (socket) {\n          if (this.socket === socket.socket) {\n            socket.status = C.SOCKET_STATUS_ERROR;\n          }\n        }, this);\n      }\n\n    this._reconnect(error);\n  }\n\n  _onData(data) {\n    // CRLF Keep Alive response from server. Ignore it.\n    if (data === '\\r\\n') {\n      debug('received message with CRLF Keep Alive response');\n      return;\n    } // Binary message.\n    else if (typeof data !== 'string') {\n        try {\n          data = String.fromCharCode.apply(null, new Uint8Array(data));\n        } catch (evt) {\n          debug('received binary message failed to be converted into string,' + ' message discarded');\n          return;\n        }\n\n        debug(\"received binary message:\\n\\n\".concat(data, \"\\n\"));\n      } // Text message.\n      else {\n          debug(\"received text message:\\n\\n\".concat(data, \"\\n\"));\n        }\n\n    this.ondata({\n      transport: this,\n      message: data\n    });\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}