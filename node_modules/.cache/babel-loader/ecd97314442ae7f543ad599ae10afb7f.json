{"ast":null,"code":"const EventEmitter = require('events').EventEmitter;\n\nconst JsSIP_C = require('../Constants');\n\nconst Grammar = require('../Grammar');\n\nconst Utils = require('../Utils');\n\nconst debug = require('debug')('JsSIP:RTCSession:ReferSubscriber');\n\nmodule.exports = class ReferSubscriber extends EventEmitter {\n  constructor(session) {\n    super();\n    this._id = null;\n    this._session = session;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  sendRefer(target, options = {}) {\n    debug('sendRefer()');\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const eventHandlers = options.eventHandlers || {}; // Set event handlers.\n\n    for (const event in eventHandlers) {\n      if (Object.prototype.hasOwnProperty.call(eventHandlers, event)) {\n        this.on(event, eventHandlers[event]);\n      }\n    } // Replaces URI header field.\n\n\n    let replaces = null;\n\n    if (options.replaces) {\n      replaces = options.replaces._request.call_id;\n      replaces += \";to-tag=\".concat(options.replaces._to_tag);\n      replaces += \";from-tag=\".concat(options.replaces._from_tag);\n      replaces = encodeURIComponent(replaces);\n    } // Refer-To header field.\n\n\n    const referTo = \"Refer-To: <\".concat(target).concat(replaces ? \"?Replaces=\".concat(replaces) : '', \">\");\n    extraHeaders.push(referTo); // Referred-By header field.\n\n    const referredBy = \"Referred-By: <\".concat(this._session._ua._configuration.uri._scheme, \":\").concat(this._session._ua._configuration.uri._user, \"@\").concat(this._session._ua._configuration.uri._host, \">\");\n    extraHeaders.push(referredBy);\n    extraHeaders.push(\"Contact: \".concat(this._session.contact));\n\n    const request = this._session.sendRequest(JsSIP_C.REFER, {\n      extraHeaders,\n      eventHandlers: {\n        onSuccessResponse: response => {\n          this._requestSucceeded(response);\n        },\n        onErrorResponse: response => {\n          this._requestFailed(response, JsSIP_C.causes.REJECTED);\n        },\n        onTransportError: () => {\n          this._requestFailed(null, JsSIP_C.causes.CONNECTION_ERROR);\n        },\n        onRequestTimeout: () => {\n          this._requestFailed(null, JsSIP_C.causes.REQUEST_TIMEOUT);\n        },\n        onDialogError: () => {\n          this._requestFailed(null, JsSIP_C.causes.DIALOG_ERROR);\n        }\n      }\n    });\n\n    this._id = request.cseq;\n  }\n\n  receiveNotify(request) {\n    debug('receiveNotify()');\n\n    if (!request.body) {\n      return;\n    }\n\n    const status_line = Grammar.parse(request.body.trim(), 'Status_Line');\n\n    if (status_line === -1) {\n      debug(\"receiveNotify() | error parsing NOTIFY body: \\\"\".concat(request.body, \"\\\"\"));\n      return;\n    }\n\n    switch (true) {\n      case /^100$/.test(status_line.status_code):\n        this.emit('trying', {\n          request,\n          status_line\n        });\n        break;\n\n      case /^1[0-9]{2}$/.test(status_line.status_code):\n        this.emit('progress', {\n          request,\n          status_line\n        });\n        break;\n\n      case /^2[0-9]{2}$/.test(status_line.status_code):\n        this.emit('accepted', {\n          request,\n          status_line\n        });\n        break;\n\n      default:\n        this.emit('failed', {\n          request,\n          status_line\n        });\n        break;\n    }\n  }\n\n  _requestSucceeded(response) {\n    debug('REFER succeeded');\n    debug('emit \"requestSucceeded\"');\n    this.emit('requestSucceeded', {\n      response\n    });\n  }\n\n  _requestFailed(response, cause) {\n    debug('REFER failed');\n    debug('emit \"requestFailed\"');\n    this.emit('requestFailed', {\n      response: response || null,\n      cause\n    });\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}