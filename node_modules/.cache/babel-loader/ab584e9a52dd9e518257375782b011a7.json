{"ast":null,"code":"const Utils = require('./Utils');\n\nconst JsSIP_C = require('./Constants');\n\nconst SIPMessage = require('./SIPMessage');\n\nconst RequestSender = require('./RequestSender');\n\nconst debug = require('debug')('JsSIP:Registrator');\n\nconst MIN_REGISTER_EXPIRES = 10; // In seconds.\n\nmodule.exports = class Registrator {\n  constructor(ua, transport) {\n    const reg_id = 1; // Force reg_id to 1.\n\n    this._ua = ua;\n    this._transport = transport;\n    this._registrar = ua.configuration.registrar_server;\n    this._expires = ua.configuration.register_expires; // Call-ID and CSeq values RFC3261 10.2.\n\n    this._call_id = Utils.createRandomToken(22);\n    this._cseq = 0;\n    this._to_uri = ua.configuration.uri;\n    this._registrationTimer = null; // Ongoing Register request.\n\n    this._registering = false; // Set status.\n\n    this._registered = false; // Contact header.\n\n    this._contact = this._ua.contact.toString(); // Sip.ice media feature tag (RFC 5768).\n\n    this._contact += ';+sip.ice'; // Custom headers for REGISTER and un-REGISTER.\n\n    this._extraHeaders = []; // Custom Contact header params for REGISTER and un-REGISTER.\n\n    this._extraContactParams = '';\n\n    if (reg_id) {\n      this._contact += \";reg-id=\".concat(reg_id);\n      this._contact += \";+sip.instance=\\\"<urn:uuid:\".concat(this._ua.configuration.instance_id, \">\\\"\");\n    }\n  }\n\n  get registered() {\n    return this._registered;\n  }\n\n  setExtraHeaders(extraHeaders) {\n    if (!Array.isArray(extraHeaders)) {\n      extraHeaders = [];\n    }\n\n    this._extraHeaders = extraHeaders.slice();\n  }\n\n  setExtraContactParams(extraContactParams) {\n    if (!(extraContactParams instanceof Object)) {\n      extraContactParams = {};\n    } // Reset it.\n\n\n    this._extraContactParams = '';\n\n    for (const param_key in extraContactParams) {\n      if (Object.prototype.hasOwnProperty.call(extraContactParams, param_key)) {\n        const param_value = extraContactParams[param_key];\n        this._extraContactParams += \";\".concat(param_key);\n\n        if (param_value) {\n          this._extraContactParams += \"=\".concat(param_value);\n        }\n      }\n    }\n  }\n\n  register() {\n    if (this._registering) {\n      debug('Register request in progress...');\n      return;\n    }\n\n    const extraHeaders = this._extraHeaders.slice();\n\n    extraHeaders.push(\"Contact: \".concat(this._contact, \";expires=\").concat(this._expires).concat(this._extraContactParams));\n    extraHeaders.push(\"Expires: \".concat(this._expires));\n    const request = new SIPMessage.OutgoingRequest(JsSIP_C.REGISTER, this._registrar, this._ua, {\n      'to_uri': this._to_uri,\n      'call_id': this._call_id,\n      'cseq': this._cseq += 1\n    }, extraHeaders);\n    const request_sender = new RequestSender(this._ua, request, {\n      onRequestTimeout: () => {\n        this._registrationFailure(null, JsSIP_C.causes.REQUEST_TIMEOUT);\n      },\n      onTransportError: () => {\n        this._registrationFailure(null, JsSIP_C.causes.CONNECTION_ERROR);\n      },\n      // Increase the CSeq on authentication.\n      onAuthenticated: () => {\n        this._cseq += 1;\n      },\n      onReceiveResponse: response => {\n        // Discard responses to older REGISTER/un-REGISTER requests.\n        if (response.cseq !== this._cseq) {\n          return;\n        } // Clear registration timer.\n\n\n        if (this._registrationTimer !== null) {\n          clearTimeout(this._registrationTimer);\n          this._registrationTimer = null;\n        }\n\n        switch (true) {\n          case /^1[0-9]{2}$/.test(response.status_code):\n            {\n              // Ignore provisional responses.\n              break;\n            }\n\n          case /^2[0-9]{2}$/.test(response.status_code):\n            {\n              this._registering = false;\n\n              if (!response.hasHeader('Contact')) {\n                debug('no Contact header in response to REGISTER, response ignored');\n                break;\n              }\n\n              const contacts = response.headers['Contact'].reduce((a, b) => a.concat(b.parsed), []); // Get the Contact pointing to us and update the expires value accordingly.\n\n              const contact = contacts.find(element => element.uri.user === this._ua.contact.uri.user);\n\n              if (!contact) {\n                debug('no Contact header pointing to us, response ignored');\n                break;\n              }\n\n              let expires = contact.getParam('expires');\n\n              if (!expires && response.hasHeader('expires')) {\n                expires = response.getHeader('expires');\n              }\n\n              if (!expires) {\n                expires = this._expires;\n              }\n\n              expires = Number(expires);\n              if (expires < MIN_REGISTER_EXPIRES) expires = MIN_REGISTER_EXPIRES; // Re-Register or emit an event before the expiration interval has elapsed.\n              // For that, decrease the expires value. ie: 3 seconds.\n\n              this._registrationTimer = setTimeout(() => {\n                this._registrationTimer = null; // If there are no listeners for registrationExpiring, renew registration.\n                // If there are listeners, let the function listening do the register call.\n\n                if (this._ua.listeners('registrationExpiring').length === 0) {\n                  this.register();\n                } else {\n                  this._ua.emit('registrationExpiring');\n                }\n              }, expires * 1000 - 5000); // Save gruu values.\n\n              if (contact.hasParam('temp-gruu')) {\n                this._ua.contact.temp_gruu = contact.getParam('temp-gruu').replace(/\"/g, '');\n              }\n\n              if (contact.hasParam('pub-gruu')) {\n                this._ua.contact.pub_gruu = contact.getParam('pub-gruu').replace(/\"/g, '');\n              }\n\n              if (!this._registered) {\n                this._registered = true;\n\n                this._ua.registered({\n                  response\n                });\n              }\n\n              break;\n            }\n          // Interval too brief RFC3261 10.2.8.\n\n          case /^423$/.test(response.status_code):\n            {\n              if (response.hasHeader('min-expires')) {\n                // Increase our registration interval to the suggested minimum.\n                this._expires = Number(response.getHeader('min-expires'));\n                if (this._expires < MIN_REGISTER_EXPIRES) this._expires = MIN_REGISTER_EXPIRES; // Attempt the registration again immediately.\n\n                this.register();\n              } else {\n                // This response MUST contain a Min-Expires header field.\n                debug('423 response received for REGISTER without Min-Expires');\n\n                this._registrationFailure(response, JsSIP_C.causes.SIP_FAILURE_CODE);\n              }\n\n              break;\n            }\n\n          default:\n            {\n              const cause = Utils.sipErrorCause(response.status_code);\n\n              this._registrationFailure(response, cause);\n            }\n        }\n      }\n    });\n    this._registering = true;\n    request_sender.send();\n  }\n\n  unregister(options = {}) {\n    if (!this._registered) {\n      debug('already unregistered');\n      return;\n    }\n\n    this._registered = false; // Clear the registration timer.\n\n    if (this._registrationTimer !== null) {\n      clearTimeout(this._registrationTimer);\n      this._registrationTimer = null;\n    }\n\n    const extraHeaders = this._extraHeaders.slice();\n\n    if (options.all) {\n      extraHeaders.push(\"Contact: *\".concat(this._extraContactParams));\n    } else {\n      extraHeaders.push(\"Contact: \".concat(this._contact, \";expires=0\").concat(this._extraContactParams));\n    }\n\n    extraHeaders.push('Expires: 0');\n    const request = new SIPMessage.OutgoingRequest(JsSIP_C.REGISTER, this._registrar, this._ua, {\n      'to_uri': this._to_uri,\n      'call_id': this._call_id,\n      'cseq': this._cseq += 1\n    }, extraHeaders);\n    const request_sender = new RequestSender(this._ua, request, {\n      onRequestTimeout: () => {\n        this._unregistered(null, JsSIP_C.causes.REQUEST_TIMEOUT);\n      },\n      onTransportError: () => {\n        this._unregistered(null, JsSIP_C.causes.CONNECTION_ERROR);\n      },\n      // Increase the CSeq on authentication.\n      onAuthenticated: () => {\n        this._cseq += 1;\n      },\n      onReceiveResponse: response => {\n        switch (true) {\n          case /^1[0-9]{2}$/.test(response.status_code):\n            // Ignore provisional responses.\n            break;\n\n          case /^2[0-9]{2}$/.test(response.status_code):\n            this._unregistered(response);\n\n            break;\n\n          default:\n            {\n              const cause = Utils.sipErrorCause(response.status_code);\n\n              this._unregistered(response, cause);\n            }\n        }\n      }\n    });\n    request_sender.send();\n  }\n\n  close() {\n    if (this._registered) {\n      this.unregister();\n    }\n  }\n\n  onTransportClosed() {\n    this._registering = false;\n\n    if (this._registrationTimer !== null) {\n      clearTimeout(this._registrationTimer);\n      this._registrationTimer = null;\n    }\n\n    if (this._registered) {\n      this._registered = false;\n\n      this._ua.unregistered({});\n    }\n  }\n\n  _registrationFailure(response, cause) {\n    this._registering = false;\n\n    this._ua.registrationFailed({\n      response: response || null,\n      cause\n    });\n\n    if (this._registered) {\n      this._registered = false;\n\n      this._ua.unregistered({\n        response: response || null,\n        cause\n      });\n    }\n  }\n\n  _unregistered(response, cause) {\n    this._registering = false;\n    this._registered = false;\n\n    this._ua.unregistered({\n      response: response || null,\n      cause: cause || null\n    });\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}