{"ast":null,"code":"const EventEmitter = require('events').EventEmitter;\n\nconst JsSIP_C = require('./Constants');\n\nconst SIPMessage = require('./SIPMessage');\n\nconst Utils = require('./Utils');\n\nconst RequestSender = require('./RequestSender');\n\nconst Exceptions = require('./Exceptions');\n\nconst debug = require('debug')('JsSIP:Message');\n\nmodule.exports = class Message extends EventEmitter {\n  constructor(ua) {\n    super();\n    this._ua = ua;\n    this._request = null;\n    this._closed = false;\n    this._direction = null;\n    this._local_identity = null;\n    this._remote_identity = null; // Whether an incoming message has been replied.\n\n    this._is_replied = false; // Custom message empty object for high level use.\n\n    this._data = {};\n  }\n\n  get direction() {\n    return this._direction;\n  }\n\n  get local_identity() {\n    return this._local_identity;\n  }\n\n  get remote_identity() {\n    return this._remote_identity;\n  }\n\n  send(target, body, options = {}) {\n    const originalTarget = target;\n\n    if (target === undefined || body === undefined) {\n      throw new TypeError('Not enough arguments');\n    } // Check target validity.\n\n\n    target = this._ua.normalizeTarget(target);\n\n    if (!target) {\n      throw new TypeError(\"Invalid target: \".concat(originalTarget));\n    } // Get call options.\n\n\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const eventHandlers = options.eventHandlers || {};\n    const contentType = options.contentType || 'text/plain'; // Set event handlers.\n\n    for (const event in eventHandlers) {\n      if (Object.prototype.hasOwnProperty.call(eventHandlers, event)) {\n        this.on(event, eventHandlers[event]);\n      }\n    }\n\n    extraHeaders.push(\"Content-Type: \".concat(contentType));\n    this._request = new SIPMessage.OutgoingRequest(JsSIP_C.MESSAGE, target, this._ua, null, extraHeaders);\n\n    if (body) {\n      this._request.body = body;\n    }\n\n    const request_sender = new RequestSender(this._ua, this._request, {\n      onRequestTimeout: () => {\n        this._onRequestTimeout();\n      },\n      onTransportError: () => {\n        this._onTransportError();\n      },\n      onReceiveResponse: response => {\n        this._receiveResponse(response);\n      }\n    });\n\n    this._newMessage('local', this._request);\n\n    request_sender.send();\n  }\n\n  init_incoming(request) {\n    this._request = request;\n\n    this._newMessage('remote', request); // Reply with a 200 OK if the user didn't reply.\n\n\n    if (!this._is_replied) {\n      this._is_replied = true;\n      request.reply(200);\n    }\n\n    this._close();\n  }\n  /**\n   * Accept the incoming Message\n   * Only valid for incoming Messages\n   */\n\n\n  accept(options = {}) {\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const body = options.body;\n\n    if (this._direction !== 'incoming') {\n      throw new Exceptions.NotSupportedError('\"accept\" not supported for outgoing Message');\n    }\n\n    if (this._is_replied) {\n      throw new Error('incoming Message already replied');\n    }\n\n    this._is_replied = true;\n\n    this._request.reply(200, null, extraHeaders, body);\n  }\n  /**\n   * Reject the incoming Message\n   * Only valid for incoming Messages\n   */\n\n\n  reject(options = {}) {\n    const status_code = options.status_code || 480;\n    const reason_phrase = options.reason_phrase;\n    const extraHeaders = Utils.cloneArray(options.extraHeaders);\n    const body = options.body;\n\n    if (this._direction !== 'incoming') {\n      throw new Exceptions.NotSupportedError('\"reject\" not supported for outgoing Message');\n    }\n\n    if (this._is_replied) {\n      throw new Error('incoming Message already replied');\n    }\n\n    if (status_code < 300 || status_code >= 700) {\n      throw new TypeError(\"Invalid status_code: \".concat(status_code));\n    }\n\n    this._is_replied = true;\n\n    this._request.reply(status_code, reason_phrase, extraHeaders, body);\n  }\n\n  _receiveResponse(response) {\n    if (this._closed) {\n      return;\n    }\n\n    switch (true) {\n      case /^1[0-9]{2}$/.test(response.status_code):\n        // Ignore provisional responses.\n        break;\n\n      case /^2[0-9]{2}$/.test(response.status_code):\n        this._succeeded('remote', response);\n\n        break;\n\n      default:\n        {\n          const cause = Utils.sipErrorCause(response.status_code);\n\n          this._failed('remote', response, cause);\n\n          break;\n        }\n    }\n  }\n\n  _onRequestTimeout() {\n    if (this._closed) {\n      return;\n    }\n\n    this._failed('system', null, JsSIP_C.causes.REQUEST_TIMEOUT);\n  }\n\n  _onTransportError() {\n    if (this._closed) {\n      return;\n    }\n\n    this._failed('system', null, JsSIP_C.causes.CONNECTION_ERROR);\n  }\n\n  _close() {\n    this._closed = true;\n\n    this._ua.destroyMessage(this);\n  }\n  /**\n   * Internal Callbacks\n   */\n\n\n  _newMessage(originator, request) {\n    if (originator === 'remote') {\n      this._direction = 'incoming';\n      this._local_identity = request.to;\n      this._remote_identity = request.from;\n    } else if (originator === 'local') {\n      this._direction = 'outgoing';\n      this._local_identity = request.from;\n      this._remote_identity = request.to;\n    }\n\n    this._ua.newMessage(this, {\n      originator,\n      message: this,\n      request\n    });\n  }\n\n  _failed(originator, response, cause) {\n    debug('MESSAGE failed');\n\n    this._close();\n\n    debug('emit \"failed\"');\n    this.emit('failed', {\n      originator,\n      response: response || null,\n      cause\n    });\n  }\n\n  _succeeded(originator, response) {\n    debug('MESSAGE succeeded');\n\n    this._close();\n\n    debug('emit \"succeeded\"');\n    this.emit('succeeded', {\n      originator,\n      response\n    });\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}