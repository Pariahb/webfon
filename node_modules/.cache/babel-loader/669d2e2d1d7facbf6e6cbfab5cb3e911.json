{"ast":null,"code":"const JsSIP_C = require('./Constants');\n\nconst DigestAuthentication = require('./DigestAuthentication');\n\nconst Transactions = require('./Transactions');\n\nconst debug = require('debug')('JsSIP:RequestSender'); // Default event handlers.\n\n\nconst EventHandlers = {\n  onRequestTimeout: () => {},\n  onTransportError: () => {},\n  onReceiveResponse: () => {},\n  onAuthenticated: () => {}\n};\nmodule.exports = class RequestSender {\n  constructor(ua, request, eventHandlers) {\n    this._ua = ua;\n    this._eventHandlers = eventHandlers;\n    this._method = request.method;\n    this._request = request;\n    this._auth = null;\n    this._challenged = false;\n    this._staled = false; // Define the undefined handlers.\n\n    for (const handler in EventHandlers) {\n      if (Object.prototype.hasOwnProperty.call(EventHandlers, handler)) {\n        if (!this._eventHandlers[handler]) {\n          this._eventHandlers[handler] = EventHandlers[handler];\n        }\n      }\n    } // If ua is in closing process or even closed just allow sending Bye and ACK.\n\n\n    if (ua.status === ua.C.STATUS_USER_CLOSED && (this._method !== JsSIP_C.BYE || this._method !== JsSIP_C.ACK)) {\n      this._eventHandlers.onTransportError();\n    }\n  }\n  /**\n  * Create the client transaction and send the message.\n  */\n\n\n  send() {\n    const eventHandlers = {\n      onRequestTimeout: () => {\n        this._eventHandlers.onRequestTimeout();\n      },\n      onTransportError: () => {\n        this._eventHandlers.onTransportError();\n      },\n      onReceiveResponse: response => {\n        this._receiveResponse(response);\n      }\n    };\n\n    switch (this._method) {\n      case 'INVITE':\n        this.clientTransaction = new Transactions.InviteClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);\n        break;\n\n      case 'ACK':\n        this.clientTransaction = new Transactions.AckClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);\n        break;\n\n      default:\n        this.clientTransaction = new Transactions.NonInviteClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);\n    }\n\n    this.clientTransaction.send();\n  }\n  /**\n  * Called from client transaction when receiving a correct response to the request.\n  * Authenticate request if needed or pass the response back to the applicant.\n  */\n\n\n  _receiveResponse(response) {\n    let challenge;\n    let authorization_header_name;\n    const status_code = response.status_code;\n    /*\n    * Authentication\n    * Authenticate once. _challenged_ flag used to avoid infinite authentications.\n    */\n\n    if ((status_code === 401 || status_code === 407) && (this._ua.configuration.password !== null || this._ua.configuration.ha1 !== null)) {\n      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n      if (response.status_code === 401) {\n        challenge = response.parseHeader('www-authenticate');\n        authorization_header_name = 'authorization';\n      } else {\n        challenge = response.parseHeader('proxy-authenticate');\n        authorization_header_name = 'proxy-authorization';\n      } // Verify it seems a valid challenge.\n\n\n      if (!challenge) {\n        debug(\"\".concat(response.status_code, \" with wrong or missing challenge, cannot authenticate\"));\n\n        this._eventHandlers.onReceiveResponse(response);\n\n        return;\n      }\n\n      if (!this._challenged || !this._staled && challenge.stale === true) {\n        if (!this._auth) {\n          this._auth = new DigestAuthentication({\n            username: this._ua.configuration.authorization_user,\n            password: this._ua.configuration.password,\n            realm: this._ua.configuration.realm,\n            ha1: this._ua.configuration.ha1\n          });\n        } // Verify that the challenge is really valid.\n\n\n        if (!this._auth.authenticate(this._request, challenge)) {\n          this._eventHandlers.onReceiveResponse(response);\n\n          return;\n        }\n\n        this._challenged = true; // Update ha1 and realm in the UA.\n\n        this._ua.set('realm', this._auth.get('realm'));\n\n        this._ua.set('ha1', this._auth.get('ha1'));\n\n        if (challenge.stale) {\n          this._staled = true;\n        }\n\n        this._request = this._request.clone();\n        this._request.cseq += 1;\n\n        this._request.setHeader('cseq', \"\".concat(this._request.cseq, \" \").concat(this._method));\n\n        this._request.setHeader(authorization_header_name, this._auth.toString());\n\n        this._eventHandlers.onAuthenticated(this._request);\n\n        this.send();\n      } else {\n        this._eventHandlers.onReceiveResponse(response);\n      }\n    } else {\n      this._eventHandlers.onReceiveResponse(response);\n    }\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}