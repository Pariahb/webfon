{"ast":null,"code":"const EventEmitter = require('events').EventEmitter;\n\nconst JsSIP_C = require('./Constants');\n\nconst Registrator = require('./Registrator');\n\nconst RTCSession = require('./RTCSession');\n\nconst Message = require('./Message');\n\nconst Transactions = require('./Transactions');\n\nconst Transport = require('./Transport');\n\nconst Utils = require('./Utils');\n\nconst Exceptions = require('./Exceptions');\n\nconst URI = require('./URI');\n\nconst Parser = require('./Parser');\n\nconst SIPMessage = require('./SIPMessage');\n\nconst sanityCheck = require('./sanityCheck');\n\nconst config = require('./Config');\n\nconst debug = require('debug')('JsSIP:UA');\n\nconst debugerror = require('debug')('JsSIP:ERROR:UA');\n\ndebugerror.log = console.warn.bind(console);\nconst C = {\n  // UA status codes.\n  STATUS_INIT: 0,\n  STATUS_READY: 1,\n  STATUS_USER_CLOSED: 2,\n  STATUS_NOT_READY: 3,\n  // UA error codes.\n  CONFIGURATION_ERROR: 1,\n  NETWORK_ERROR: 2\n};\n/**\n * The User-Agent class.\n * @class JsSIP.UA\n * @param {Object} configuration Configuration parameters.\n * @throws {JsSIP.Exceptions.ConfigurationError} If a configuration parameter is invalid.\n * @throws {TypeError} If no configuration is given.\n */\n\nmodule.exports = class UA extends EventEmitter {\n  // Expose C object.\n  static get C() {\n    return C;\n  }\n\n  constructor(configuration) {\n    debug('new() [configuration:%o]', configuration);\n    super();\n    this._cache = {\n      credentials: {}\n    };\n    this._configuration = Object.assign({}, config.settings);\n    this._dynConfiguration = {};\n    this._dialogs = {}; // User actions outside any session/dialog (MESSAGE).\n\n    this._applicants = {};\n    this._sessions = {};\n    this._transport = null;\n    this._contact = null;\n    this._status = C.STATUS_INIT;\n    this._error = null;\n    this._transactions = {\n      nist: {},\n      nict: {},\n      ist: {},\n      ict: {}\n    }; // Custom UA empty object for high level use.\n\n    this._data = {};\n    this._closeTimer = null; // Check configuration argument.\n\n    if (configuration === undefined) {\n      throw new TypeError('Not enough arguments');\n    } // Load configuration.\n\n\n    try {\n      this._loadConfig(configuration);\n    } catch (e) {\n      this._status = C.STATUS_NOT_READY;\n      this._error = C.CONFIGURATION_ERROR;\n      throw e;\n    } // Initialize registrator.\n\n\n    this._registrator = new Registrator(this);\n  }\n\n  get C() {\n    return C;\n  }\n\n  get status() {\n    return this._status;\n  }\n\n  get contact() {\n    return this._contact;\n  }\n\n  get configuration() {\n    return this._configuration;\n  }\n\n  get transport() {\n    return this._transport;\n  } // =================\n  //  High Level API\n  // =================\n\n  /**\n   * Connect to the server if status = STATUS_INIT.\n   * Resume UA after being closed.\n   */\n\n\n  start() {\n    debug('start()');\n\n    if (this._status === C.STATUS_INIT) {\n      this._transport.connect();\n    } else if (this._status === C.STATUS_USER_CLOSED) {\n      debug('restarting UA'); // Disconnect.\n\n      if (this._closeTimer !== null) {\n        clearTimeout(this._closeTimer);\n        this._closeTimer = null;\n\n        this._transport.disconnect();\n      } // Reconnect.\n\n\n      this._status = C.STATUS_INIT;\n\n      this._transport.connect();\n    } else if (this._status === C.STATUS_READY) {\n      debug('UA is in READY status, not restarted');\n    } else {\n      debug('ERROR: connection is down, Auto-Recovery system is trying to reconnect');\n    } // Set dynamic configuration.\n\n\n    this._dynConfiguration.register = this._configuration.register;\n  }\n  /**\n   * Register.\n   */\n\n\n  register() {\n    debug('register()');\n    this._dynConfiguration.register = true;\n\n    this._registrator.register();\n  }\n  /**\n   * Unregister.\n   */\n\n\n  unregister(options) {\n    debug('unregister()');\n    this._dynConfiguration.register = false;\n\n    this._registrator.unregister(options);\n  }\n  /**\n   * Get the Registrator instance.\n   */\n\n\n  registrator() {\n    return this._registrator;\n  }\n  /**\n   * Registration state.\n   */\n\n\n  isRegistered() {\n    return this._registrator.registered;\n  }\n  /**\n   * Connection state.\n   */\n\n\n  isConnected() {\n    return this._transport.isConnected();\n  }\n  /**\n   * Make an outgoing call.\n   *\n   * -param {String} target\n   * -param {Object} [options]\n   *\n   * -throws {TypeError}\n   *\n   */\n\n\n  call(target, options) {\n    debug('call()');\n    const session = new RTCSession(this);\n    session.connect(target, options);\n    return session;\n  }\n  /**\n   * Send a message.\n   *\n   * -param {String} target\n   * -param {String} body\n   * -param {Object} [options]\n   *\n   * -throws {TypeError}\n   *\n   */\n\n\n  sendMessage(target, body, options) {\n    debug('sendMessage()');\n    const message = new Message(this);\n    message.send(target, body, options);\n    return message;\n  }\n  /**\n   * Terminate ongoing sessions.\n   */\n\n\n  terminateSessions(options) {\n    debug('terminateSessions()');\n\n    for (const idx in this._sessions) {\n      if (!this._sessions[idx].isEnded()) {\n        this._sessions[idx].terminate(options);\n      }\n    }\n  }\n  /**\n   * Gracefully close.\n   *\n   */\n\n\n  stop() {\n    debug('stop()'); // Remove dynamic settings.\n\n    this._dynConfiguration = {};\n\n    if (this._status === C.STATUS_USER_CLOSED) {\n      debug('UA already closed');\n      return;\n    } // Close registrator.\n\n\n    this._registrator.close(); // If there are session wait a bit so CANCEL/BYE can be sent and their responses received.\n\n\n    const num_sessions = Object.keys(this._sessions).length; // Run  _terminate_ on every Session.\n\n    for (const session in this._sessions) {\n      if (Object.prototype.hasOwnProperty.call(this._sessions, session)) {\n        debug(\"closing session \".concat(session));\n\n        try {\n          this._sessions[session].terminate();\n        } catch (error) {}\n      }\n    } // Run  _close_ on every applicant.\n\n\n    for (const applicant in this._applicants) {\n      if (Object.prototype.hasOwnProperty.call(this._applicants, applicant)) try {\n        this._applicants[applicant].close();\n      } catch (error) {}\n    }\n\n    this._status = C.STATUS_USER_CLOSED;\n    const num_transactions = Object.keys(this._transactions.nict).length + Object.keys(this._transactions.nist).length + Object.keys(this._transactions.ict).length + Object.keys(this._transactions.ist).length;\n\n    if (num_transactions === 0 && num_sessions === 0) {\n      this._transport.disconnect();\n    } else {\n      this._closeTimer = setTimeout(() => {\n        this._closeTimer = null;\n\n        this._transport.disconnect();\n      }, 2000);\n    }\n  }\n  /**\n   * Normalice a string into a valid SIP request URI\n   * -param {String} target\n   * -returns {JsSIP.URI|undefined}\n   */\n\n\n  normalizeTarget(target) {\n    return Utils.normalizeTarget(target, this._configuration.hostport_params);\n  }\n  /**\n   * Allow retrieving configuration and autogenerated fields in runtime.\n   */\n\n\n  get(parameter) {\n    switch (parameter) {\n      case 'realm':\n        return this._configuration.realm;\n\n      case 'ha1':\n        return this._configuration.ha1;\n\n      default:\n        debugerror('get() | cannot get \"%s\" parameter in runtime', parameter);\n        return undefined;\n    }\n  }\n  /**\n   * Allow configuration changes in runtime.\n   * Returns true if the parameter could be set.\n   */\n\n\n  set(parameter, value) {\n    switch (parameter) {\n      case 'password':\n        {\n          this._configuration.password = String(value);\n          break;\n        }\n\n      case 'realm':\n        {\n          this._configuration.realm = String(value);\n          break;\n        }\n\n      case 'ha1':\n        {\n          this._configuration.ha1 = String(value); // Delete the plain SIP password.\n\n          this._configuration.password = null;\n          break;\n        }\n\n      case 'display_name':\n        {\n          this._configuration.display_name = value;\n          break;\n        }\n\n      default:\n        debugerror('set() | cannot set \"%s\" parameter in runtime', parameter);\n        return false;\n    }\n\n    return true;\n  } // ==========================\n  // Event Handlers.\n  // ==========================\n\n  /**\n   * new Transaction\n   */\n\n\n  newTransaction(transaction) {\n    this._transactions[transaction.type][transaction.id] = transaction;\n    this.emit('newTransaction', {\n      transaction\n    });\n  }\n  /**\n   * Transaction destroyed.\n   */\n\n\n  destroyTransaction(transaction) {\n    delete this._transactions[transaction.type][transaction.id];\n    this.emit('transactionDestroyed', {\n      transaction\n    });\n  }\n  /**\n   * new Dialog\n   */\n\n\n  newDialog(dialog) {\n    this._dialogs[dialog.id] = dialog;\n  }\n  /**\n   * Dialog destroyed.\n   */\n\n\n  destroyDialog(dialog) {\n    delete this._dialogs[dialog.id];\n  }\n  /**\n   *  new Message\n   */\n\n\n  newMessage(message, data) {\n    this._applicants[message] = message;\n    this.emit('newMessage', data);\n  }\n  /**\n   *  Message destroyed.\n   */\n\n\n  destroyMessage(message) {\n    delete this._applicants[message];\n  }\n  /**\n   * new RTCSession\n   */\n\n\n  newRTCSession(session, data) {\n    this._sessions[session.id] = session;\n    this.emit('newRTCSession', data);\n  }\n  /**\n   * RTCSession destroyed.\n   */\n\n\n  destroyRTCSession(session) {\n    delete this._sessions[session.id];\n  }\n  /**\n   * Registered\n   */\n\n\n  registered(data) {\n    this.emit('registered', data);\n  }\n  /**\n   * Unregistered\n   */\n\n\n  unregistered(data) {\n    this.emit('unregistered', data);\n  }\n  /**\n   * Registration Failed\n   */\n\n\n  registrationFailed(data) {\n    this.emit('registrationFailed', data);\n  } // =========================\n  // ReceiveRequest.\n  // =========================\n\n  /**\n   * Request reception\n   */\n\n\n  receiveRequest(request) {\n    const method = request.method; // Check that request URI points to us.\n\n    if (request.ruri.user !== this._configuration.uri.user && request.ruri.user !== this._contact.uri.user) {\n      debug('Request-URI does not point to us');\n\n      if (request.method !== JsSIP_C.ACK) {\n        request.reply_sl(404);\n      }\n\n      return;\n    } // Check request URI scheme.\n\n\n    if (request.ruri.scheme === JsSIP_C.SIPS) {\n      request.reply_sl(416);\n      return;\n    } // Check transaction.\n\n\n    if (Transactions.checkTransaction(this, request)) {\n      return;\n    } // Create the server transaction.\n\n\n    if (method === JsSIP_C.INVITE) {\n      /* eslint-disable no-new */\n      new Transactions.InviteServerTransaction(this, this._transport, request);\n      /* eslint-enable no-new */\n    } else if (method !== JsSIP_C.ACK && method !== JsSIP_C.CANCEL) {\n      /* eslint-disable no-new */\n      new Transactions.NonInviteServerTransaction(this, this._transport, request);\n      /* eslint-enable no-new */\n    }\n    /* RFC3261 12.2.2\n     * Requests that do not change in any way the state of a dialog may be\n     * received within a dialog (for example, an OPTIONS request).\n     * They are processed as if they had been received outside the dialog.\n     */\n\n\n    if (method === JsSIP_C.OPTIONS) {\n      request.reply(200);\n    } else if (method === JsSIP_C.MESSAGE) {\n      if (this.listeners('newMessage').length === 0) {\n        request.reply(405);\n        return;\n      }\n\n      const message = new Message(this);\n      message.init_incoming(request);\n    } else if (method === JsSIP_C.INVITE) {\n      // Initial INVITE.\n      if (!request.to_tag && this.listeners('newRTCSession').length === 0) {\n        request.reply(405);\n        return;\n      }\n    }\n\n    let dialog;\n    let session; // Initial Request.\n\n    if (!request.to_tag) {\n      switch (method) {\n        case JsSIP_C.INVITE:\n          if (window.RTCPeerConnection) {\n            // TODO\n            if (request.hasHeader('replaces')) {\n              const replaces = request.replaces;\n              dialog = this._findDialog(replaces.call_id, replaces.from_tag, replaces.to_tag);\n\n              if (dialog) {\n                session = dialog.owner;\n\n                if (!session.isEnded()) {\n                  session.receiveRequest(request);\n                } else {\n                  request.reply(603);\n                }\n              } else {\n                request.reply(481);\n              }\n            } else {\n              session = new RTCSession(this);\n              session.init_incoming(request);\n            }\n          } else {\n            debugerror('INVITE received but WebRTC is not supported');\n            request.reply(488);\n          }\n\n          break;\n\n        case JsSIP_C.BYE:\n          // Out of dialog BYE received.\n          request.reply(481);\n          break;\n\n        case JsSIP_C.CANCEL:\n          session = this._findSession(request);\n\n          if (session) {\n            session.receiveRequest(request);\n          } else {\n            debug('received CANCEL request for a non existent session');\n          }\n\n          break;\n\n        case JsSIP_C.ACK:\n          /* Absorb it.\n           * ACK request without a corresponding Invite Transaction\n           * and without To tag.\n           */\n          break;\n\n        case JsSIP_C.NOTIFY:\n          // Receive new sip event.\n          this.emit('sipEvent', {\n            event: request.event,\n            request\n          });\n          request.reply(200);\n          break;\n\n        default:\n          request.reply(405);\n          break;\n      }\n    } // In-dialog request.\n    else {\n        dialog = this._findDialog(request.call_id, request.from_tag, request.to_tag);\n\n        if (dialog) {\n          dialog.receiveRequest(request);\n        } else if (method === JsSIP_C.NOTIFY) {\n          session = this._findSession(request);\n\n          if (session) {\n            session.receiveRequest(request);\n          } else {\n            debug('received NOTIFY request for a non existent subscription');\n            request.reply(481, 'Subscription does not exist');\n          }\n        }\n        /* RFC3261 12.2.2\n         * Request with to tag, but no matching dialog found.\n         * Exception: ACK for an Invite request for which a dialog has not\n         * been created.\n         */\n        else if (method !== JsSIP_C.ACK) {\n            request.reply(481);\n          }\n      }\n  } // =================\n  // Utils.\n  // =================\n\n  /**\n   * Get the session to which the request belongs to, if any.\n   */\n\n\n  _findSession({\n    call_id,\n    from_tag,\n    to_tag\n  }) {\n    const sessionIDa = call_id + from_tag;\n    const sessionA = this._sessions[sessionIDa];\n    const sessionIDb = call_id + to_tag;\n    const sessionB = this._sessions[sessionIDb];\n\n    if (sessionA) {\n      return sessionA;\n    } else if (sessionB) {\n      return sessionB;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Get the dialog to which the request belongs to, if any.\n   */\n\n\n  _findDialog(call_id, from_tag, to_tag) {\n    let id = call_id + from_tag + to_tag;\n    let dialog = this._dialogs[id];\n\n    if (dialog) {\n      return dialog;\n    } else {\n      id = call_id + to_tag + from_tag;\n      dialog = this._dialogs[id];\n\n      if (dialog) {\n        return dialog;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  _loadConfig(configuration) {\n    // Check and load the given configuration.\n    try {\n      config.load(this._configuration, configuration);\n    } catch (e) {\n      throw e;\n    } // Post Configuration Process.\n    // Allow passing 0 number as display_name.\n\n\n    if (this._configuration.display_name === 0) {\n      this._configuration.display_name = '0';\n    } // Instance-id for GRUU.\n\n\n    if (!this._configuration.instance_id) {\n      this._configuration.instance_id = Utils.newUUID();\n    } // Jssip_id instance parameter. Static random tag of length 5.\n\n\n    this._configuration.jssip_id = Utils.createRandomToken(5); // String containing this._configuration.uri without scheme and user.\n\n    const hostport_params = this._configuration.uri.clone();\n\n    hostport_params.user = null;\n    this._configuration.hostport_params = hostport_params.toString().replace(/^sip:/i, ''); // Transport.\n\n    try {\n      this._transport = new Transport(this._configuration.sockets, {\n        // Recovery options.\n        max_interval: this._configuration.connection_recovery_max_interval,\n        min_interval: this._configuration.connection_recovery_min_interval\n      }); // Transport event callbacks.\n\n      this._transport.onconnecting = onTransportConnecting.bind(this);\n      this._transport.onconnect = onTransportConnect.bind(this);\n      this._transport.ondisconnect = onTransportDisconnect.bind(this);\n      this._transport.ondata = onTransportData.bind(this);\n    } catch (e) {\n      debugerror(e);\n      throw new Exceptions.ConfigurationError('sockets', this._configuration.sockets);\n    } // Remove sockets instance from configuration object.\n\n\n    delete this._configuration.sockets; // Check whether authorization_user is explicitly defined.\n    // Take 'this._configuration.uri.user' value if not.\n\n    if (!this._configuration.authorization_user) {\n      this._configuration.authorization_user = this._configuration.uri.user;\n    } // If no 'registrar_server' is set use the 'uri' value without user portion and\n    // without URI params/headers.\n\n\n    if (!this._configuration.registrar_server) {\n      const registrar_server = this._configuration.uri.clone();\n\n      registrar_server.user = null;\n      registrar_server.clearParams();\n      registrar_server.clearHeaders();\n      this._configuration.registrar_server = registrar_server;\n    } // User no_answer_timeout.\n\n\n    this._configuration.no_answer_timeout *= 1000; // Via Host.\n\n    if (this._configuration.contact_uri) {\n      this._configuration.via_host = this._configuration.contact_uri.host;\n    } // Contact URI.\n    else {\n        this._configuration.contact_uri = new URI('sip', Utils.createRandomToken(8), this._configuration.via_host, null, {\n          transport: 'ws'\n        });\n      }\n\n    this._contact = {\n      pub_gruu: null,\n      temp_gruu: null,\n      uri: this._configuration.contact_uri,\n\n      toString(options = {}) {\n        const anonymous = options.anonymous || null;\n        const outbound = options.outbound || null;\n        let contact = '<';\n\n        if (anonymous) {\n          contact += this.temp_gruu || 'sip:anonymous@anonymous.invalid;transport=ws';\n        } else {\n          contact += this.pub_gruu || this.uri.toString();\n        }\n\n        if (outbound && (anonymous ? !this.temp_gruu : !this.pub_gruu)) {\n          contact += ';ob';\n        }\n\n        contact += '>';\n        return contact;\n      }\n\n    }; // Seal the configuration.\n\n    const writable_parameters = ['password', 'realm', 'ha1', 'display_name', 'register'];\n\n    for (const parameter in this._configuration) {\n      if (Object.prototype.hasOwnProperty.call(this._configuration, parameter)) {\n        if (writable_parameters.indexOf(parameter) !== -1) {\n          Object.defineProperty(this._configuration, parameter, {\n            writable: true,\n            configurable: false\n          });\n        } else {\n          Object.defineProperty(this._configuration, parameter, {\n            writable: false,\n            configurable: false\n          });\n        }\n      }\n    }\n\n    debug('configuration parameters after validation:');\n\n    for (const parameter in this._configuration) {\n      // Only show the user user configurable parameters.\n      if (Object.prototype.hasOwnProperty.call(config.settings, parameter)) {\n        switch (parameter) {\n          case 'uri':\n          case 'registrar_server':\n            debug(\"- \".concat(parameter, \": \").concat(this._configuration[parameter]));\n            break;\n\n          case 'password':\n          case 'ha1':\n            debug(\"- \".concat(parameter, \": NOT SHOWN\"));\n            break;\n\n          default:\n            debug(\"- \".concat(parameter, \": \").concat(JSON.stringify(this._configuration[parameter])));\n        }\n      }\n    }\n\n    return;\n  }\n\n};\n/**\n * Transport event handlers\n */\n// Transport connecting event.\n\nfunction onTransportConnecting(data) {\n  this.emit('connecting', data);\n} // Transport connected event.\n\n\nfunction onTransportConnect(data) {\n  if (this._status === C.STATUS_USER_CLOSED) {\n    return;\n  }\n\n  this._status = C.STATUS_READY;\n  this._error = null;\n  this.emit('connected', data);\n\n  if (this._dynConfiguration.register) {\n    this._registrator.register();\n  }\n} // Transport disconnected event.\n\n\nfunction onTransportDisconnect(data) {\n  // Run _onTransportError_ callback on every client transaction using _transport_.\n  const client_transactions = ['nict', 'ict', 'nist', 'ist'];\n\n  for (const type of client_transactions) {\n    for (const id in this._transactions[type]) {\n      if (Object.prototype.hasOwnProperty.call(this._transactions[type], id)) {\n        this._transactions[type][id].onTransportError();\n      }\n    }\n  }\n\n  this.emit('disconnected', data); // Call registrator _onTransportClosed_.\n\n  this._registrator.onTransportClosed();\n\n  if (this._status !== C.STATUS_USER_CLOSED) {\n    this._status = C.STATUS_NOT_READY;\n    this._error = C.NETWORK_ERROR;\n  }\n} // Transport data event.\n\n\nfunction onTransportData(data) {\n  const transport = data.transport;\n  let message = data.message;\n  message = Parser.parseMessage(message, this);\n\n  if (!message) {\n    return;\n  }\n\n  if (this._status === C.STATUS_USER_CLOSED && message instanceof SIPMessage.IncomingRequest) {\n    return;\n  } // Do some sanity check.\n\n\n  if (!sanityCheck(message, this, transport)) {\n    return;\n  }\n\n  if (message instanceof SIPMessage.IncomingRequest) {\n    message.transport = transport;\n    this.receiveRequest(message);\n  } else if (message instanceof SIPMessage.IncomingResponse) {\n    /* Unike stated in 18.1.2, if a response does not match\n    * any transaction, it is discarded here and no passed to the core\n    * in order to be discarded there.\n    */\n    let transaction;\n\n    switch (message.method) {\n      case JsSIP_C.INVITE:\n        transaction = this._transactions.ict[message.via_branch];\n\n        if (transaction) {\n          transaction.receiveResponse(message);\n        }\n\n        break;\n\n      case JsSIP_C.ACK:\n        // Just in case ;-).\n        break;\n\n      default:\n        transaction = this._transactions.nict[message.via_branch];\n\n        if (transaction) {\n          transaction.receiveResponse(message);\n        }\n\n        break;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}